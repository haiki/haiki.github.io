---
title: Cpp debug
date: 2019-11-29 09:58:19
categories:
- CPP
tags:
---

# bazel 
1. .bazelrc 中关闭 copt
2. bazel build --copt="-g" --strip="never" ...

build --cxxopt="--std=c++17"
#build --copt=-O2
build --incompatible_no_support_tools_in_action_inputs=false

https://blog.csdn.net/shaomingliang499/article/details/50536796

- 想要随机产生0-100间的整数，从而做排序的操作

  - [C++产生随机数](https://www.cnblogs.com/VVingerfly/p/5990714.html)             
  - 通常用 `srand((unsigned)time(0)) `或者`srand((unsigned)time(NULL))`来 产生种子。如果仍然觉得时间间隔太小。可以在`(unsigned)time(0)`或者`(unsigned)time(NULL)`后面乘上某个合适的整数。 例如,`srand((unsigned)time(NULL)*10)`。
  - [浮点随机数产生](https://blog.csdn.net/yangziluomu/article/details/102013793)

  

# C++ 类访问控制（public/protected/private）
C++中 public，protected， private 访问标号小结
第一：private, public, protected 访问标号的访问范围。
private：只能由1.该类中的函数、2.其友元函数访问。
不能被任何其他访问，该类的对象也不能访问。
protected：可以被1.该类中的函数、2.子类的函数、以及3.其友元函数访问。
但不能被该类的对象访问。
public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。
注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。
————————————————
版权声明：本文为CSDN博主「sppg1949」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/sppg1949/article/details/6716561


// const, inline, this, 引用, 列表初始化 


声明是用户可以看到的部分，客户非常信任地使用这个特性，希望得到一定的结果，但是你在实现里使用了不同的缺省值，那么将是灾难性的。因此编译器禁止声明和定义时同时定义缺省参数值。

类的成员函数的参数表在声明时默认参数位于参数表右部，如int fn(int a,int b=0,int c=5)之类的，但在它定义的时候则不能加默认参数，只能写int fn(int a,int b,int c);

若声明时没有定义缺省参数值，那么在定义成员函数时可以定义缺省参数值。但这种情况通常用户是看不见的，因此应避免。

对于非类中的函数，在函数声明中定义默认参数的另外一个好处时，可以利用声明来随意更改默认参数的值。
————————————————
版权声明：本文为CSDN博主「abraham_li」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/abraham_li/article/details/49611719


5、char test[4]={'t','e','s','t'}或char test[]={'t','e','s','t'}  这种情况下因为不管是数字长度缺省还是刚好填充字符个数，编译器都不会添加结尾符，所以这两种情况得到的结果不确定！
其他和 char 相关的都会自动在后面加 '\0'


- 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。
  - 所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。

- 定义在类声明之中的成员函数将自动地成为内联函数
  
- 慎用内联
  - 内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着“内联”这个关键字吗？内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
  - 以下情况不宜使用内联：
    - （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
    - （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如“偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。

- 如果inline函数出现的话，其定义必须相同。建议把inline函数的定义放到头文件中。在每个调用该inline函数的文件中包含该头文件。这种方法保证对每个inline函数只有一个定义，且程序员无需复制代码，并且不可能在程序的生命期中引起无意的不匹配的事情。
https://blog.csdn.net/nanhaizhixin/article/details/7564084

