<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>bazel_usage | haiki</title>
  <meta name="keywords" content=" bazel ">
  <meta name="description" content="bazel_usage | haiki">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Oops～，我崩溃了！找不到你想要的页面 :(">
<meta property="og:type" content="website">
<meta property="og:title" content="404">
<meta property="og:url" content="https://github.com/haiki/haiki.github.io/404.html">
<meta property="og:site_name" content="haiki">
<meta property="og:description" content="Oops～，我崩溃了！找不到你想要的页面 :(">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-10-03T12:16:10.000Z">
<meta property="article:modified_time" content="2022-01-03T11:20:49.316Z">
<meta property="article:author" content="haiki">
<meta property="article:tag" content="computer science,blockchain,leetcode,record life">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/darcula.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.0.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>haiki</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="http://haiki.github.io"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/haiki"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="csdn"
               href="https://blog.csdn.net/haiki66"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-csdn"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:peiqi66@163.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(37)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="编程语言">
                        
                        编程语言
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="读书">
                        
                        读书
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="工具">
                        
                        工具
                        <small>(10)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="框架">
                        
                        框架
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="区块链">
                        
                        区块链
                        <small>(7)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="运维">
                        
                        运维
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="CPP">
                        
                        CPP
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="leetcode">
                        
                        leetcode
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="37">
<input type="hidden" id="yelog_site_word_count" value="90.2k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>笔记</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>编译</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>工具成长类</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>基础</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>零碎</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>命令</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>私链</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>以太坊</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>智能合约</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>API</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>bash</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>bazel</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>DApp</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>easy</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ethereum</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>geth</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>go环境配置</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>golang</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hexo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>IDEA</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Javascript</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>linkedList</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>problem</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>shell</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>solidity</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>stack</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>string</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>token</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>transaction</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a id="top" class="全部文章 工具 "
           href="/2019/10/03/my-first-article/"
           data-tag="hexo,problem"
           data-author="" >
            <span class="post-title" title="my first article">my first article</span>
            <span class="post-date" title="2019-10-03 16:03:38">2019/10/03</span>
        </a>
        
        <a  class="全部文章 CPP "
           href="/2023/03/12/cmake/"
           data-tag="编译,基础"
           data-author="" >
            <span class="post-title" title="cmake">cmake</span>
            <span class="post-date" title="2023-03-12 21:24:37">2023/03/12</span>
        </a>
        
        <a  class="全部文章 "
           href="/2023/01/15/mysql/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="mysql">mysql</span>
            <span class="post-date" title="2023-01-15 09:00:25">2023/01/15</span>
        </a>
        
        <a  class="全部文章 编程语言 "
           href="/2022/08/12/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
           data-tag="golang,笔记"
           data-author="" >
            <span class="post-title" title="go语言圣经学习笔记">go语言圣经学习笔记</span>
            <span class="post-date" title="2022-08-12 17:06:52">2022/08/12</span>
        </a>
        
        <a  class="全部文章 "
           href="/2022/06/19/bazel-backup/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="bazel-backup">bazel-backup</span>
            <span class="post-date" title="2022-06-19 09:08:59">2022/06/19</span>
        </a>
        
        <a  class="全部文章 框架 "
           href="/2022/06/03/rpc/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="rpc">rpc</span>
            <span class="post-date" title="2022-06-03 09:44:30">2022/06/03</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/2022/06/03/bazel-usage/"
           data-tag="bazel"
           data-author="" >
            <span class="post-title" title="bazel_usage">bazel_usage</span>
            <span class="post-date" title="2022-06-03 09:31:09">2022/06/03</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/2022/04/25/bash-base/"
           data-tag="bash"
           data-author="" >
            <span class="post-title" title="bash_base">bash_base</span>
            <span class="post-date" title="2022-04-25 09:53:36">2022/04/25</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/2022/04/23/bash-function/"
           data-tag="bash"
           data-author="" >
            <span class="post-title" title="bash_function">bash_function</span>
            <span class="post-date" title="2022-04-23 22:21:56">2022/04/23</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/2022/04/23/bash-if/"
           data-tag="bash"
           data-author="" >
            <span class="post-title" title="bash_if">bash_if</span>
            <span class="post-date" title="2022-04-23 21:06:06">2022/04/23</span>
        </a>
        
        <a  class="全部文章 CPP "
           href="/2022/02/19/generic-algorithm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="generic_algorithm">generic_algorithm</span>
            <span class="post-date" title="2022-02-19 11:01:59">2022/02/19</span>
        </a>
        
        <a  class="全部文章 CPP "
           href="/2022/02/15/lambda/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="lambda">lambda</span>
            <span class="post-date" title="2022-02-15 10:07:26">2022/02/15</span>
        </a>
        
        <a  class="全部文章 "
           href="/2022/02/15/smart-ptr/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="smart_ptr">smart_ptr</span>
            <span class="post-date" title="2022-02-15 10:06:52">2022/02/15</span>
        </a>
        
        <a  class="全部文章 "
           href="/2022/02/15/namespace/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="namespace">namespace</span>
            <span class="post-date" title="2022-02-15 10:06:25">2022/02/15</span>
        </a>
        
        <a  class="全部文章 CPP "
           href="/2022/02/14/gccVSg/"
           data-tag="编译,基础"
           data-author="" >
            <span class="post-title" title="gccVSg++">gccVSg++</span>
            <span class="post-date" title="2022-02-14 19:44:47">2022/02/14</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/2022/02/13/regex/"
           data-tag="linux"
           data-author="" >
            <span class="post-title" title="regex">regex</span>
            <span class="post-date" title="2022-02-13 10:31:34">2022/02/13</span>
        </a>
        
        <a  class="全部文章 运维 "
           href="/2022/02/08/chore/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="chore">chore</span>
            <span class="post-date" title="2022-02-08 15:24:56">2022/02/08</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/2022/01/10/sed/"
           data-tag="linux"
           data-author="" >
            <span class="post-title" title="sed">sed</span>
            <span class="post-date" title="2022-01-10 09:44:13">2022/01/10</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/2022/01/10/awk/"
           data-tag="linux"
           data-author="" >
            <span class="post-title" title="awk">awk</span>
            <span class="post-date" title="2022-01-10 09:42:10">2022/01/10</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/2022/01/06/grep/"
           data-tag="linux,shell"
           data-author="" >
            <span class="post-title" title="grep">grep</span>
            <span class="post-date" title="2022-01-06 09:22:20">2022/01/06</span>
        </a>
        
        <a  class="全部文章 编程语言 "
           href="/2021/08/22/go%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"
           data-tag="golang,笔记"
           data-author="" >
            <span class="post-title" title="golang 学习">golang 学习</span>
            <span class="post-date" title="2021-08-22 15:39:24">2021/08/22</span>
        </a>
        
        <a  class="全部文章 区块链 "
           href="/2019/12/23/%E4%BB%A5%E5%A4%AA%E5%9D%8AERC20/"
           data-tag="以太坊,solidity,智能合约,token"
           data-author="" >
            <span class="post-title" title="以太坊ERC20">以太坊ERC20</span>
            <span class="post-date" title="2019-12-23 10:13:29">2019/12/23</span>
        </a>
        
        <a  class="全部文章 区块链 "
           href="/2019/12/22/%E4%BB%A5%E5%A4%AA%E5%9D%8A-Transaction/"
           data-tag="以太坊,transaction"
           data-author="" >
            <span class="post-title" title="以太坊-Transaction">以太坊-Transaction</span>
            <span class="post-date" title="2019-12-22 10:55:27">2019/12/22</span>
        </a>
        
        <a  class="全部文章 CPP "
           href="/2019/11/29/C-%E9%9A%8F%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cpp debug">Cpp debug</span>
            <span class="post-date" title="2019-11-29 09:58:19">2019/11/29</span>
        </a>
        
        <a  class="全部文章 区块链 "
           href="/2019/11/05/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E5%89%8D%E6%B2%BF%E6%B4%9E%E5%AF%9F/"
           data-tag="零碎"
           data-author="" >
            <span class="post-title" title="区块链相关技术前沿洞察">区块链相关技术前沿洞察</span>
            <span class="post-date" title="2019-11-05 14:54:48">2019/11/05</span>
        </a>
        
        <a  class="全部文章 leetcode "
           href="/2019/11/03/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E5%BF%85%E5%A4%87/"
           data-tag="算法"
           data-author="" >
            <span class="post-title" title="算法与数据结构学习必备">算法与数据结构学习必备</span>
            <span class="post-date" title="2019-11-03 09:34:47">2019/11/03</span>
        </a>
        
        <a  class="全部文章 区块链 "
           href="/2019/10/26/%E4%BB%A5%E5%A4%AA%E5%9D%8ADApp/"
           data-tag="ethereum,DApp"
           data-author="" >
            <span class="post-title" title="以太坊DApp">以太坊DApp</span>
            <span class="post-date" title="2019-10-26 18:55:09">2019/10/26</span>
        </a>
        
        <a  class="全部文章 区块链 "
           href="/2019/10/25/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%9E%E8%B7%B5/"
           data-tag="以太坊,solidity,智能合约"
           data-author="" >
            <span class="post-title" title="以太坊智能合约实践">以太坊智能合约实践</span>
            <span class="post-date" title="2019-10-25 10:15:12">2019/10/25</span>
        </a>
        
        <a  class="全部文章 区块链 "
           href="/2019/10/22/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E5%BF%B5%E5%8F%8AAPI%E7%9A%84%E6%95%B4%E5%90%88%E4%B8%8E%E7%90%86%E8%A7%A3/"
           data-tag="以太坊,API,Javascript"
           data-author="" >
            <span class="post-title" title="以太坊概念及API的整合与理解">以太坊概念及API的整合与理解</span>
            <span class="post-date" title="2019-10-22 17:21:16">2019/10/22</span>
        </a>
        
        <a  class="全部文章 区块链 "
           href="/2019/10/19/%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/"
           data-tag="以太坊,私链,geth,go环境配置"
           data-author="" >
            <span class="post-title" title="从头搭建以太坊私链">从头搭建以太坊私链</span>
            <span class="post-date" title="2019-10-19 16:15:54">2019/10/19</span>
        </a>
        
        <a  class="全部文章 运维 "
           href="/2019/10/10/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"
           data-tag="linux,命令"
           data-author="" >
            <span class="post-title" title="linux常用命令">linux常用命令</span>
            <span class="post-date" title="2019-10-10 16:32:59">2019/10/10</span>
        </a>
        
        <a  class="全部文章 编程语言 "
           href="/2019/10/10/java/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="java">java</span>
            <span class="post-date" title="2019-10-10 14:04:57">2019/10/10</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/2019/10/09/IDEA%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"
           data-tag="IDEA,java"
           data-author="" >
            <span class="post-title" title="IDEA的使用：提升看源码效率">IDEA的使用：提升看源码效率</span>
            <span class="post-date" title="2019-10-09 20:21:52">2019/10/09</span>
        </a>
        
        <a  class="全部文章 读书 "
           href="/2019/10/06/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%E6%91%98%E5%BD%95%E5%8F%8A%E8%A7%82%E5%90%8E%E6%84%9F/"
           data-tag="工具成长类"
           data-author="" >
            <span class="post-title" title="非暴力沟通摘录及观后感">非暴力沟通摘录及观后感</span>
            <span class="post-date" title="2019-10-06 18:41:57">2019/10/06</span>
        </a>
        
        <a  class="全部文章 leetcode "
           href="/2019/10/05/string-problems-easy/"
           data-tag="easy,string"
           data-author="" >
            <span class="post-title" title="string-problems-easy">string-problems-easy</span>
            <span class="post-date" title="2019-10-05 10:30:38">2019/10/05</span>
        </a>
        
        <a  class="全部文章 leetcode "
           href="/2019/08/28/LinkedList-problems-easy/"
           data-tag="linkedList,easy"
           data-author="" >
            <span class="post-title" title="LinkedList-problems-easy">LinkedList-problems-easy</span>
            <span class="post-date" title="2019-08-28 21:40:38">2019/08/28</span>
        </a>
        
        <a  class="全部文章 leetcode "
           href="/2019/08/23/stack-problems-easy/"
           data-tag="easy,stack"
           data-author="" >
            <span class="post-title" title="stack-problems-easy">stack-problems-easy</span>
            <span class="post-date" title="2019-08-23 21:40:38">2019/08/23</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-bazel-usage" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">bazel_usage</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="工具">工具</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color1">bazel</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2022-06-19 23:39:04'>2022-06-03 09:31</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:10.4k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E8%AF%86-Bazel"><span class="toc-text">初识 Bazel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bazel-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Bazel 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8-Bazel"><span class="toc-text">如何用 Bazel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bazel-%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-text">Bazel 构建流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bazel-%E5%9F%BA%E7%A1%80"><span class="toc-text">Bazel 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Workspaces-Packages-targets"><span class="toc-text">Workspaces,Packages, targets</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Workspace"><span class="toc-text">Workspace</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Repository"><span class="toc-text">Repository</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Packages"><span class="toc-text">Packages</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Targets"><span class="toc-text">Targets</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Labels"><span class="toc-text">Labels</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#label-%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-text">label 的命名规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Target-names-%E2%80%94-package-name-target-name"><span class="toc-text">Target names —  package-name:target-name</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Package-names-%E2%80%94-package-name-target-name"><span class="toc-text">Package names — &#x2F;&#x2F;package-name:target-name</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rule"><span class="toc-text">Rule</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BUILD%E6%96%87%E4%BB%B6"><span class="toc-text">BUILD文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Loading-an-extension"><span class="toc-text">Loading an extension</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%A7%84%E5%88%99%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">构建规则的类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96"><span class="toc-text">依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E4%BE%9D%E8%B5%96%E5%92%8C%E5%A3%B0%E6%98%8E%E4%BE%9D%E8%B5%96"><span class="toc-text">实际依赖和声明依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">依赖的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-labels-%E5%BC%95%E7%94%A8%E7%9B%AE%E5%BD%95"><span class="toc-text">使用 labels 引用目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Visibility"><span class="toc-text">Visibility</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Visibility-specifications"><span class="toc-text">Visibility specifications</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Visibility-of-a-rule-target-generated-file-target"><span class="toc-text">Visibility of a rule target&#x2F;generated file target</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Visibility-of-a-source-file-target"><span class="toc-text">Visibility of a source file target</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Visibility-of-bzl-files"><span class="toc-text">Visibility of bzl files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Visibility-of-implicit-dependencies"><span class="toc-text">Visibility of implicit dependencies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Platforms"><span class="toc-text">Platforms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hermeticity"><span class="toc-text">Hermeticity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cc-libraryxxxx"><span class="toc-text">cc_libraryxxxx</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Output-Directory-Layout-xxx"><span class="toc-text">Output Directory Layout xxx</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Wrokspace-Rules%E3%80%82xxxx"><span class="toc-text">Wrokspace Rules。xxxx</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86-bazelrc%E6%96%87%E4%BB%B6-xxxx"><span class="toc-text">认识.bazelrc文件 xxxx</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E5%86%99-BUILD-%E6%96%87%E4%BB%B6"><span class="toc-text">编写 BUILD 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BUILD-%E6%96%87%E4%BB%B6%E7%9A%84%E9%A3%8E%E6%A0%BC"><span class="toc-text">BUILD 文件的风格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F"><span class="toc-text">共享变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96"><span class="toc-text">外部依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bazel-%E6%94%AF%E6%8C%81%E7%9A%84%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E7%B1%BB%E5%9E%8B"><span class="toc-text">bazel 支持的外部依赖类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-1"><span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Bzlmod-%E7%AE%A1%E7%90%86%E4%BE%9D%E8%B5%96-new-xxx"><span class="toc-text">通过 Bzlmod 管理依赖 new xxx</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C-bazel"><span class="toc-text">运行 bazel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-bazel-%E6%9E%84%E5%BB%BA"><span class="toc-text">用 bazel 构建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8%E7%9A%84-bazel-%E5%91%BD%E4%BB%A4"><span class="toc-text">可用的 bazel 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%B8%AE%E5%8A%A9"><span class="toc-text">获取帮助</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%8D%95%E4%B8%AA-target"><span class="toc-text">构建单个 target</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%A4%9A%E4%B8%AA-target"><span class="toc-text">构建多个 target</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%89%E5%8F%96%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96"><span class="toc-text">拉取外部依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#repository-cache"><span class="toc-text">repository cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Distribution-files-directories"><span class="toc-text">Distribution files directories</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%90%E8%A1%8C-bazel"><span class="toc-text">隔离环境中运行 bazel</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Build-configurations-and-cross-compilation"><span class="toc-text">Build configurations and cross-compilation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#commands-%E5%92%8C-options"><span class="toc-text">commands 和 options</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99-bazelrc-%E6%96%87%E4%BB%B6"><span class="toc-text">编写 bazelrc 文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%84%9A%E6%9C%AC%E8%B0%83%E7%94%A8-Bazel"><span class="toc-text">通过脚本调用 Bazel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9E%B6%E6%9E%84"><span class="toc-text">客户端和服务端架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA"><span class="toc-text">配置构建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%85%8D%E7%BD%AE%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">可配置的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E-c-%E8%A7%84%E5%88%99%E9%9B%86%E6%88%90"><span class="toc-text">与 c++ 规则集成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Toolchain-Resolution-Implementation-Details%EF%BC%9Fno-need"><span class="toc-text">Toolchain Resolution Implementation Details？no need</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87"><span class="toc-text">代码覆盖率</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BUILD-%E5%92%8C-bzl-%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">BUILD 和 .bzl 文件的区别</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-4 i,
    .toc-level-4 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>官网入口：<del><a target="_blank" rel="noopener" href="https://docs.bazel.build/versions/main/bazel-overview.html">https://docs.bazel.build/versions/main/bazel-overview.html</a></del> <a target="_blank" rel="noopener" href="https://bazel.build/start">https://bazel.build/start</a></p>
<h1 id="初识-Bazel"><a href="#初识-Bazel" class="headerlink" title="初识 Bazel"></a>初识 Bazel</h1><h2 id="Bazel-是什么"><a href="#Bazel-是什么" class="headerlink" title="Bazel 是什么"></a>Bazel 是什么</h2><p>开源的<strong>编译和测试</strong>的工具（类似Make，Maven，Gradle）。</p>
<ul>
<li><p><strong>High-level build language</strong></p>
<ul>
<li>使用易读，抽象的编译语言，以高层次的语义描述项目构建属性。</li>
<li>在 libraries，binaries，scripts，date sets 的概念上运行，用户无需单独写规则调用编译器/链接器。</li>
</ul>
</li>
<li><p><strong>Bazel is fast and reliable</strong></p>
<ul>
<li>Bazel 缓存之前编译的结果，追踪修改的文件内容和构建命令，从而知道哪些内容需要重新构建，并只构建修改的内容和命令。想要加速构建，<strong>可设置高并行和增量的方式</strong>。</li>
</ul>
</li>
<li><p><strong>Bazel is multi-platform</strong></p>
<ul>
<li>可在多种平台（macos，windows，linux）运行。</li>
<li>支持为同个项目在多种平台（桌面，服务端，移动端）构建二进制文件和可部署的包。</li>
</ul>
</li>
<li><p><strong>Bazel scales.</strong></p>
<ul>
<li>支持多达100k+源文件的编译，支持多个代码库，可供多人（万+）使用。</li>
</ul>
</li>
<li><p><strong>Bazel is extensible</strong></p>
<ul>
<li>支持<a target="_blank" rel="noopener" href="https://bazel.build/rules">多种语言</a>（C++，Go，Java等），且可以做延伸去支持其他语言或框架。</li>
</ul>
</li>
</ul>
<h2 id="如何用-Bazel"><a href="#如何用-Bazel" class="headerlink" title="如何用 Bazel"></a>如何用 Bazel</h2><ul>
<li><p>下载 Bazel</p>
<ul>
<li>推荐用 Bazelisk 在 Ubuntu，Windows，MacOs 安装 Bazel，官方团队维护。<ul>
<li>MacOs：brew install bazelisk。</li>
<li><a href="https://github.com/bazelbuild/bazelisk">bazelisk</a> 是用go写的bazel的wrapper，会自动选择当前工作目录适合的 Bazel 版本，从官方服务器下载，将所有的命令行参数透传给真正的Bazel二进制文件。所以可以像调用 bazel 一样调用 bazelisk。</li>
</ul>
</li>
</ul>
</li>
<li><p>新建项目的 <a target="_blank" rel="noopener" href="https://bazel.build/concepts/build-ref#workspaces">WORKSPACE</a> </p>
<ul>
<li>工作目录，Bazel 寻找构建的输入和 BUILD 文件，并存储构建输出。</li>
</ul>
</li>
<li><p>写 BUILD 文件</p>
<ul>
<li>定义了需要构建以及如何构建的内容，可以使用<a target="_blank" rel="noopener" href="https://bazel.build/rules/language">Starlark</a> 声明构建 target，<a href="https://github.com/bazelbuild/bazel/blob/master/examples/cpp/BUILD">example</a>。</li>
<li>构建 target 声明了构建需要的输入和依赖，构建它们需要的 rule，以及配置 rule 的 options。</li>
<li>构建 rule 声明了 Bazel 用来构建的工具，如编译器，链接器以及其配置，bazel 配备了多种构建 rule，可覆盖所支持平台上，所支持语言的大部分类型。</li>
</ul>
</li>
<li><p>通过<a target="_blank" rel="noopener" href="https://bazel.build/reference/command-line-reference">命令行</a>运行 Bazel </p>
<ul>
<li>build 命令 <a target="_blank" rel="noopener" href="https://docs.bazel.build/versions/main/guide.html#specifying-targets-to-build">https://docs.bazel.build/versions/main/guide.html#specifying-targets-to-build</a></li>
</ul>
</li>
</ul>
<p> <strong>除了编译，Bazel还可以执行<a target="_blank" rel="noopener" href="https://bazel.build/reference/test-encyclopedia">测试</a>，并<a target="_blank" rel="noopener" href="https://bazel.build/docs/query-how-to">查询</a> 构建链路，追踪代码中的依赖。</strong></p>
<h2 id="Bazel-构建流程"><a href="#Bazel-构建流程" class="headerlink" title="Bazel 构建流程"></a>Bazel 构建流程</h2><p>当执行构建/测试，Bazel 如下执行：</p>
<ul>
<li><strong>加载</strong>与目标相关的 BUILD 文件。</li>
<li><strong>分析</strong>输入，以及输入的<a target="_blank" rel="noopener" href="https://bazel.build/concepts/dependencies">依赖</a>，应用特定的构建规则，生成<a target="_blank" rel="noopener" href="https://bazel.build/rules/concepts#evaluation-model">行为图</a> 。<ul>
<li>行为图表示构建artifacts，artifacts 之间的关系，以及 Bazel 要执行的构建行为。</li>
<li>根据行为图，Bazel 可以<a target="_blank" rel="noopener" href="https://bazel.build/docs/build#build-consistency">追踪</a>文件内容以及构建/测试行为的改变，曾经的构建结果，也可以<a target="_blank" rel="noopener" href="https://bazel.build/docs/query-how-to">追踪代码的依赖</a>。</li>
</ul>
</li>
<li>在输入上<strong>执行</strong>构建行为，直到输出最后的构建产物。</li>
</ul>
<p>Bazel 会将之前的构建工作缓存，只构建/测试修改了的内容。为了确保正确性，可以通过 sandBoxing <a target="_blank" rel="noopener" href="https://bazel.build/concepts/hermeticity#overview">Hermetically</a> 构建和测试，minimizing skew and maximizing <a target="_blank" rel="noopener" href="https://bazel.build/docs/build#correct-incremental-rebuilds">reproducibility</a> 。</p>
<h1 id="Bazel-基础"><a href="#Bazel-基础" class="headerlink" title="Bazel 基础"></a>Bazel 基础</h1><p>Bazel 构建 workspace 中以目录树组织的源文件。workspace 中的源文件由嵌套层级的 packages 组织，每个 packag 是一个目录，包含相关的源文件和一个BUILD 文件。BUILD 文件定义了可以从源文件编译出的输出。</p>
<h2 id="Workspaces-Packages-targets"><a href="#Workspaces-Packages-targets" class="headerlink" title="Workspaces,Packages, targets"></a><a target="_blank" rel="noopener" href="https://bazel.build/concepts/build-ref">Workspaces,Packages, targets</a></h2><h3 id="Workspace"><a href="#Workspace" class="headerlink" title="Workspace"></a>Workspace</h3><ul>
<li>Bazel 的构建基于工作区(workspace) 概念。每个使用 bazel 的项目，在根目录下都必须有一个 WORKSPACE 文件，WORKSPACE 文件所在的目录就是项目的根目录。<ul>
<li>如果<strong>当前 WORKSPACE 文件</strong>所在的<strong>子目录中包含 WORKSPACE 文件</strong>，Bazel 构建时会忽略子目录，子目录成为另一个 workspace 。</li>
<li>WORKSPACE  文件的别名是 WORKSPACE.bazel，两者都存在时，使用 WORKSPACE.bazel。</li>
</ul>
</li>
<li>WROKSPACE 文件可以是空的，也可以包含对<a target="_blank" rel="noopener" href="https://bazel.build/docs/external">外部的依赖</a>。</li>
</ul>
<h4 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h4><p>代码组织在 repositories 中。</p>
<ul>
<li><p>包含 WORKSPACE 文件的目录是 main repository <strong>的根，称作 “@”。</strong></p>
</li>
<li><p>其他（外部） repositories 由 WORKSPACE 文件中的 workspace rules 定义。</p>
<ul>
<li>外部 repositories 通常包含自己的 WORKSPACE 文件，而 Bazel 会忽略这些文件。</li>
<li>In particular, repositories depended upon transitively are not added automatically.</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://bazel.build/rules/lib/repo">Repository Rules</a></p>
</li>
</ul>
<h3 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h3><p>Repository 中主要的代码组织单元是 package。package 包含相关文件的集合，以及这些文件如何产出输出的说明。</p>
<ul>
<li><p>包含 BUILD/BUILD.bazel 文件的目录是一个 package。</p>
</li>
<li><p>一个 package 中包含这个目录/子目录下的所有文件，subpackage 除外，这样就没有文件/目录会成为两个不同 package 的成员 。</p>
<ul>
<li>包含 BUILD 文件的子目录称作 subpackage。</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://bazel.build/reference/be/functions#package_group">package groups</a> 是 packages 的集合，其目的是限制特定 rules 的可访问性。</p>
<ul>
<li>package groups 由 <code>package_group </code> 函数定义，包含三个属性：<ol>
<li>此 group 中包含的 packages 列表；</li>
<li>packages 的名字；</li>
<li>其包含的其他 package groups。</li>
</ol>
</li>
<li>引用 package group 的方式是：<ol>
<li>通过 rules 的 <code>visibility</code> 属性；</li>
<li><code>package</code> 函数的 <code>default_visibility</code> 属性 。</li>
</ol>
</li>
<li><strong>不生成或者消费文件。</strong></li>
</ul>
<h3 id="Targets"><a href="#Targets" class="headerlink" title="Targets"></a>Targets</h3><p>Package 是 targets 的容器，targets 定义在 package 的 BUILD 文件中。大部分 targets 是 files 或者 rules。</p>
<ul>
<li><p>files 又可以分成两类：源文件（source files，包含在 repo 中），生成的文件（Generated files，由源文件通过特定的 rules 生成，不包含在 repo 中）。<del>targets 中定义了包括：files，rules 和 package groups。</del></p>
</li>
<li><p>Rule ：定义了一系列输入和输出之间的关系，包含了从输入得到输出的必要步骤。</p>
<ul>
<li>输入可以是 source file/generated file ，类型不重要，重要的是文件的内容。因此将复杂的源文件替换为 generated file 很方便，反之亦然。也可以避免一个文件修改导致所有编译链接关系的改变 。</li>
<li>一个的输入可能是另一个的输出，从而形成关系链，而输出只是 generated files。</li>
<li>一个 rule 的输入可能包含其他 rules：直觉上来说，比如 C++的 library rule A 以 library rule B 作为输入，那么编译期间，B 的头文件对 A 可用，链接期间，B 的符号对 A 可用，运行期间，B 的运行时数据对 A 可用。</li>
<li>rules 的不变性：一条 rule 生成的文件，只属于包含这条 rule 的 package。尽管一条 rule 的输入可能会来自其他 package，当前 rule 无法为其他 package 生成文件。</li>
</ul>
</li>
</ul>
<h2 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h2><p>所有的 targets 只会属于一个 package。target 的名字叫作 label。每个 label 唯一标识 target。 </p>
<ul>
<li>典型的 label：  <code>@myrepo//my/app/main:app_binary </code><ul>
<li><code>@myrepo//</code>：<strong>repository 名</strong>。</li>
<li>当 label 被所在的 repository 中使用，repo 的名字可以使用缩写 <code>//</code>。因此，在 <code>@myrepo</code> 中，label 常写为 <code>//my/app/main:app_binary</code> 。</li>
</ul>
</li>
<li><code>my/app/main</code>： 从 repository 的根到 package 的相对路径，是 un-qualified 的 <strong>package 名</strong>。<ul>
<li>repository 名 +  un-qualified package 名 组成 <strong>fully-qualified 的 package 名</strong>： <code>@myrepo//my/app/main </code></li>
<li> 当 label 被所在 package 中引用， package 名（以及冒号）可以被省略。上述 label 可以写为 ：</li>
<li><code>app_binary</code> </li>
<li><code>:app_binary</code></li>
<li>不成文规定。有冒号的用在 rule 中，<em>无冒号的用在 file 中</em>，但也无所谓啦。</li>
</ul>
</li>
<li><code>app_binary </code>： un-qualified target 名<ul>
<li>当和 target 名和 package 路径的最后一个目录一致时，可以省略，即 label 表示为：<ol>
<li><code>//my/app/lib</code></li>
<li> <code>//my/app/lib:lib</code></li>
</ol>
</li>
</ul>
</li>
<li>file target 的名字：对于 package 子目录中的 file target，其名称为相对于所在 package root（包含 BUILD 文件的目录） 的路径。<ul>
<li>file target 的名字为：<code>//my/app/main:testdata/input.txt</code> ，文件位于 repo 的子目录 <code>my/app/main/testdata</code>  下。</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li><p><code>//my/app</code> 不是 package 名。</p>
<ul>
<li>labels 总是以 repo 的标识（//）开头，但是 package 名不是。</li>
<li><code>my/app</code> 才是包含 <code>//my/app/lib</code> (a.k.a.<code> //my/app/lib:lib</code>）的 package。</li>
<li>错误说法：<code>//my/app</code> 指向一个 package ，或者是指向 package 中的所有 target。</li>
<li>正确说法：<code>//my/app</code>  等价于 <code>//my/app:app</code> ，即命名了在当前 repo 中，<code>my/app</code> package 下的 app target。</li>
</ul>
</li>
<li><p><strong>相对的 labels 不能用来指向其他 package 中的 targets，这种情况下必须指定 repo 和 package。</strong></p>
<ul>
<li>比如有 package <code>my/app</code> 和 package <code>my/app/testdata</code>，后者包含了文件<code> testdepot.zip</code>，那么在<code> //my/app:BUILD</code> 中引用 后者时：<ul>
<li>正确做法是：<code>//my/app/testdata:testdepot.zip</code> ；</li>
<li>而不是 <code>testdata/testdepot.zip</code>  # Wrong: testdata is a different package。</li>
<li>如果是同一个 package，应该可以用相对 label 吧？</li>
</ul>
</li>
</ul>
</li>
<li><p><em>以 <code>@//</code> 开头的 labels 是引用 main repo，从外部 repo 引用时也可以用这种形式。</em></p>
<ul>
<li><code>@//a/b/c</code>  和 <code>//a/b/c</code> 从外部 repo 引用时是不同的：<ul>
<li>前者引用 main repo；</li>
<li>后者由外部 repo 自己寻找 //a/b/c。</li>
</ul>
</li>
<li> 当在 main repo 中写 rule 引用 main repo 的 target，且将会被外部 repo 引用时，就有关系了。?</li>
</ul>
</li>
</ul>
<p>更多引用 target 的方法见<a target="_blank" rel="noopener" href="https://bazel.build/docs/build#specifying-build-targets">详情</a>。</p>
<h3 id="label-的命名规范"><a href="#label-的命名规范" class="headerlink" title="label 的命名规范"></a>label 的命名规范</h3><h4 id="Target-names-—-package-name-target-name"><a href="#Target-names-—-package-name-target-name" class="headerlink" title="Target names —  package-name:target-name"></a>Target names —  package-name:target-name</h4><ul>
<li><code>target-name</code> 是 package 内 target 的名字。可包含大小写和数字，以及标点符号： <code>!%-@^_&quot;#$&amp;&#39;()*-+,;&lt;=&gt;?[]&#123;|&#125;~/.</code>。</li>
<li>rule 的名字是 <code>BUILD</code> 文件中 rule 声明时的 <code>name</code> 属性。</li>
<li> file 的名字是相对于 package 的路径，必须是正常的形式：</li>
<li>不可以以 <code>/</code> 开头或者结尾，错误示例：<code>/foo</code>，<code>foo/</code>。</li>
<li>不可用包含<code> //</code>，错误示例：<code>//foo</code>。</li>
<li>不可以有相对路径引用：错误示例：<code>..</code> 或者 <code>./</code>。<ul>
<li>不可用 <code>..</code> 引用其他 package 的 files，可以用 <code>//package-name:filename</code>。</li>
</ul>
</li>
<li> file target 中 可以使用<code> /</code>，但是在 rule 的名字中不要使用<code>/</code>：</li>
<li>尽管没有 package <code>//foo/bar/wiz</code>，<code>//foo/bar/wiz</code> 也表示 <code>//foo/bar/wiz:wiz</code>。</li>
<li>尽管  <code>bar/wiz</code> target 存在，<code>//foo/bar/wiz</code> 也无法表示为 <code>//foo:bar/wiz</code>。</li>
<li>但是对于一些场合必须，也是允许的。比如特定 rules 的名字，必须和源文件名一致，而这些文件存在于 package 的子目录中。</li>
</ul>
<h4 id="Package-names-—-package-name-target-name"><a href="#Package-names-—-package-name-target-name" class="headerlink" title="Package names — //package-name:target-name"></a>Package names — //package-name:target-name</h4><ul>
<li>package 的名字是包含 BUILD 文件的目录，相对于 main repository 的目录名。如 <code>my/app</code>。</li>
<li>package 名可包含大小写和数字，以及标点符号 <code>/, -, ., @,_</code>。不可以以 <code>/</code> 开始或者结束，也不要包含 <code>//</code>。</li>
<li>Bazel 支持在 workspace 的根 package 下声明 target，如<code>//:foo</code>，但是尽量让这个 package 不为空，这样每个 package 都有可描述的名字。</li>
</ul>
<h3 id="Rule"><a href="#Rule" class="headerlink" title="Rule"></a>Rule</h3><ul>
<li><p>rules 声明了输入和输出间的关系，以及构造输出的步骤。</p>
</li>
<li><p>rules 有很多类型（称作 <em>rule class</em>），可产生<strong>编译好的的二进制可执行文件，库，测试用的可执行文件</strong>以及<a target="_blank" rel="noopener" href="https://bazel.build/reference/be/overview">其他支持的输出</a>。</p>
</li>
<li><p>BUILD 文件通过调用 rules 声明 targets。</p>
</li>
</ul>
<p>rule 的名字（即 name 属性）必须是合法的 target 名字。</p>
<ul>
<li>每条 rule 的调用都有 name 属性（其值必须是合法的 targe name），声明了package 中的一个 target。<ul>
<li>有时候，rule 的名字比较随意，and more interesting are the names of the files generated by the rule, and this is true of genrules. For more information, see <a target="_blank" rel="noopener" href="https://bazel.build/reference/be/general#genrule">General Rules: genrule</a>.</li>
<li>有时候，rule 的名字比较重要，比如 <code>*_binary</code> and <code>*_test</code> rules，rule 的名字决定了构建输出的可执行文件的名字。</li>
</ul>
</li>
<li>每条 rule 都有多个属性，从<a target="_blank" rel="noopener" href="https://bazel.build/reference/be/overview">构建百科全书</a>可以看到一些 rule 和对应的属性。<ul>
<li>每个属性有name 和 type，可看作属性是从键（名称）到可选类型值的字典。</li>
<li>type 的可选类型包括 integer，label，list of label，string，list of string，output label，list of output label。</li>
<li><code>src</code> 属性的 type 是  “list of labels”，每个 label 是当前 rule 的输入。</li>
</ul>
</li>
</ul>
<pre><code class="python">cc_binary(
    name = &quot;my_app&quot;,
    srcs = [&quot;my_app.cc&quot;],
    deps = [
        &quot;//absl/base&quot;,
        &quot;//absl/strings&quot;,
    ],
)
</code></pre>
<p>target 组成的有向无环图称作  <em>target graph</em> or <em>build dependency graph</em>，是 <a target="_blank" rel="noopener" href="https://bazel.build/docs/query-how-to">Bazel Query tool</a> 执行的领域。</p>
<h2 id="BUILD文件"><a href="#BUILD文件" class="headerlink" title="BUILD文件"></a>BUILD文件</h2><p>build文件就是真正定义编译规则的文件了，每个目录下都有一个，每个源文件都要在BUILD中定义它的编译规则。</p>
<p><code>BUILD</code> files are evaluated using an imperative language, <a href="https://github.com/bazelbuild/starlark/">Starlark</a>。文件中的 rules 被解释为顺序的 statements。</p>
<ul>
<li>一般来说， 变量的声明要在使用之前，顺序很重要，但是 BUILD 文件中只包含构建 rules 的声明，所以顺序不是很重要。只需要保证用到的 rules 被声明过了。</li>
<li>为了鼓励代码和数据的分离，BUILD 文件中： 不允许有函数的定义，<code>for</code> statements，或者 <code>if</code> statements（但是 list comprehensions and <code>if</code> expressions  是可以的），不支持 <code>*args</code> and <code>**kwargs</code> 参数，参数必须明确支持。</li>
<li>可以在 <code>.bzl</code> 文件中定义函数。 </li>
</ul>
<p>Starlark 中的程序不可以执行任意的 I/O，因此输入都是定的，使得构建都是可再现的，即 <a target="_blank" rel="noopener" href="https://bazel.build/concepts/hermeticity">Hermeticity</a>。</p>
<h3 id="Loading-an-extension"><a href="#Loading-an-extension" class="headerlink" title="Loading an extension"></a>Loading an extension</h3><p>Bazel extensions 是以 <code>.bzl</code> 结尾的文件，可使用 <code>load</code> statement 从 extension 导入符号。</p>
<p><code>.bzl</code> 文件中以<code>_</code> 开头的符号不会被导出，也不会被其他文件加载。文件可见性不会影响加载：因此不需要使用 <code>exports_files</code> 让 <code>.bzl</code> 文件可见。？？</p>
<pre><code class="python">load(&quot;//foo/bar:file.bzl&quot;, &quot;some_library&quot;)
</code></pre>
<ul>
<li>从 <code>//foo/bar:file.bzl</code> 加载代码，并把 <code>some_library</code> 符号加入环境。</li>
<li>此方式可用来加载 新的 rules，函数，或常量（string，list等）</li>
<li>可以在 <code>load</code> 中新增其他的参数，导入更多的符号。参数必须是字符串常量，不可以是变量。</li>
<li><code>load</code> statement 必须在顶层，不可以在函数体内。</li>
<li><code>load</code> 的第一个参数是标识 <code>.bzl</code> 的 label，如果是相对的 label，则解析为包含当前 <code>.bzl</code> 文件所在的 package（不是目录） ，load statements 中的相对 label 需要有前导 <code>:</code> 。</li>
</ul>
<pre><code class="python">load(&quot;//foo/bar:file.bzl&quot;, library_alias = &quot;some_library&quot;)
</code></pre>
<ul>
<li>load 支持别名，因此可以给导入的符号赋不同的名字。</li>
</ul>
<pre><code class="python">load(&quot;:my_rules.bzl&quot;, &quot;some_rule&quot;, nice_alias = &quot;some_other_rule&quot;)
</code></pre>
<ul>
<li>可以在一个 load statement 中定义多个别名。</li>
</ul>
<h3 id="构建规则的类型"><a href="#构建规则的类型" class="headerlink" title="构建规则的类型"></a>构建规则的类型</h3><p>The majority of build rules come in families, grouped together by language. </p>
<ul>
<li><code>*_binary</code> rules构建给定语言的可执行程序。如 label <code>//my:program</code> 的结果存放在    <code>$(BINDIR)/my/program</code>。<ul>
<li>有的语言，会将 rule 的 data 属性下的文件（以及依赖rule的这种文件），放到 runfiles 目录，便于部署到生产。</li>
</ul>
</li>
<li><code>*_test</code> rules 是 <code>*_binary</code> rule 的特化，用于自动化测试。<ul>
<li>和 二进制文件一样，tests 也有 runfiles 树，其中只包含测试运行时必要的文件。比如 <code>cc_test(name=&#39;x&#39;, data=[&#39;//foo:bar&#39;])</code> may open and read <code>$TEST_SRCDIR/workspace/foo/bar</code> during execution. （每种语言都有自己的函数去获得<code>$TEST_SRCDIR</code> 的值，但是都等同于直接使用环境变量）</li>
</ul>
</li>
<li>*_library rules 声明了每个模块的构建规则，可以依赖其他 libraries，binaries 和 tests 可以依赖 libraries。</li>
</ul>
<p><em>在 cc_binary 中定义可执行程序的编译规则，在cc_library中定义库的编译规则（即.o文件），在trpc_proto_library中定义pb文件的编译规则。</em></p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>如果 A 在构建或者执行时，需要 B，那么 target A 依赖 target B。这种 依赖关系构成 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a>，称作 <strong>依赖图</strong>。</p>
<p>直接依赖：在依赖图中一跳可到达。</p>
<p>可传递依赖：依赖图中多跳到达。</p>
<p>构建时，存在两种依赖图：实际（ actual ）依赖，声明（declared）依赖。</p>
<h3 id="实际依赖和声明依赖"><a href="#实际依赖和声明依赖" class="headerlink" title="实际依赖和声明依赖"></a>实际依赖和声明依赖</h3><p>target X 实际依赖 target Y，当且仅当为了 X  编译成功， Y 必须存在，且是最新的。<strong>在代码中实际用了的。</strong></p>
<p>“built” 代表：generated, processed,compiled, linked, archived, compressed, executed等在构建过程中经常发生的任务。</p>
<p>target X 声明依赖 target Y，当且仅当 X 所在的  package 中，有一条  X 到 Y 的依赖边。<strong>在rule 规则中写了的。</strong></p>
<p><em>为了正确编译，实际依赖的图 A 必须是声明依赖图 D 的子图 。也就是说，A 中直接相连的节点 x–&gt; y. 在 D 中也必须直接相连，称作  D 是 A 的 overapproximation。overapproximation不要太过度，否则冗余的声明依赖会使得编译很慢，二进制文件很大。</em></p>
<blockquote>
<p>For correct builds, the graph of actual dependencies <em>A</em> must be a subgraph of the graph of declared dependencies <em>D</em>. That is, every pair of directly-connected nodes <code>x --&gt; y</code> in <em>A</em> must also be directly connected in <em>D</em>. It can be said that <em>D</em> is an <em>overapproximation</em> of <em>A</em>.</p>
<p><strong>Important:</strong> <em>D</em> should not be too much of an overapproximation of <em>A</em> because redundant declared dependencies can make builds slower and binaries larger.</p>
</blockquote>
<p><strong>写 BUILD 文件时，每条 rule 都必须显示声明所有实际的直接依赖。不要试图列出所有的非直接依赖。</strong></p>
<p>这是一条很重要的规则，否则构建可能会依赖之前的一些操作，或者会依赖到一些传递声明的 target，导致未知错误。虽然 bazel 会做检查并报告错误，但是有时候并不全面。</p>
<p>传递依赖带来的常见问题：一个文件中的代码可能会使用非直接依赖中提供的代码，非直接依赖不会写在 BUILD 文件中，因此无法追踪这些文件的修改，比如文件的依赖，a 声明依赖b，b 声明依赖 c，a 中实际依赖 b，实际依赖 c，那么当 b 中没有实际依赖 c 时，会影响到 a 的 构建。</p>
<h3 id="依赖的类型"><a href="#依赖的类型" class="headerlink" title="依赖的类型"></a>依赖的类型</h3><p>大部分构建 rule 在声明不同的依赖时，有都<a target="_blank" rel="noopener" href="https://bazel.build/reference/be/common-definitions">通用的属性</a>，以及 <a target="_blank" rel="noopener" href="https://bazel.build/reference/be">rule 特定的依赖</a>，例如 <code>compiler</code> / <code>resources</code>。</p>
<ul>
<li>通用属性<ul>
<li><code>src</code></li>
<li><code>deps</code></li>
<li><code>data</code>：有的构建 target 运行时需要数据文件，数据文件不是源文件，所以不会影响 target 如何被构建。比如 单元测试需要比对函数的输出和文件的内容，构建单元测试 target 时不需要数据文件，但是运行时需要。The same applies to tools that are launched during execution.<ul>
<li>构建系统在单独的目录运行测试，只有列举在 data 中的文件时可用的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>These files are available using the relative path <code>path/to/data/file</code>. In tests, you can refer to these files by joining the paths of the test’s source directory and the workspace-relative path, for example, <code>$&#123;TEST_SRCDIR&#125;/workspace/path/to/data/file</code>.</p>
<h3 id="使用-labels-引用目录"><a href="#使用-labels-引用目录" class="headerlink" title="使用 labels 引用目录"></a>使用 labels 引用目录</h3><ul>
<li><code>data</code> labels 引用目录，最好不要以/. 或者 / 结尾的方式。不推荐示例：<ul>
<li> <code>data = [&quot;//data/regression:unittest/.&quot;]</code></li>
<li><code>data = [&quot;testdata/.&quot;]</code></li>
<li><code>data = [&quot;testdata/&quot;]</code></li>
</ul>
</li>
</ul>
<p>这种直接写目录的方式看起来很方便，直接能用目录下的所有文件，但是不要这样用：</p>
<ul>
<li>为了确保正确的增量构建，以及测试的重新执行，构建系统必须要知道所有的输入文件。</li>
<li>对于直接包含整个目录的方式，编译系统只检查目录有没有变化（是否有增删文件），不会探测对单个文件的内部修改。</li>
<li>因此，不要直接把目录作为编译系统的输入，应该将目录内的文件列举出来，明确说明。或者用 <code>glob()</code> 函数，如 <code>data = glob([&quot;testdata/**&quot;])</code>，用 <code>** </code>强制 glob 函数递归。</li>
</ul>
<p>当一些场景必须使用目录 labels（即以目录结尾），而其名称不符合 label 语法，那么遍历文件，或者使用 glob 函数会导致非法 label 错误，则必须使用目录 label。此时，对于父 package，不可以用相对的 <code>../</code> 路径，应该使用绝对路径如<code>//data/regression:unittest/</code></p>
<p>注意：<strong>directory label</strong> 只对 data 依赖有效。</p>
<p>当外部 rule，比如 test ，需要使用多个文件时，需要显示声明对所有文件的依赖，可以在 BUILD 文件中用 <code>filegroup</code> 将文件打包在一起。即可在test 中引用 label <code>my_data</code>。</p>
<pre><code class="python">filegroup(
        name = &#39;my_data&#39;,
        srcs = glob([&#39;my_unittest_data/*&#39;])
)
</code></pre>
<p><del>Bazel 中 funciton 的BUILD 百科<br>Rules<br>推荐的 rules ：<a target="_blank" rel="noopener" href="https://docs.bazel.build/versions/main/rules.html#recommended-rules">https://docs.bazel.build/versions/main/rules.html#recommended-rules</a><br>Bazel binary 中配备的 native rule 不需要用 load 声明，native rules 对于 BUILD 文件是全局可用的，可在 .bzl 文件的 native 模块找到。</del></p>
<h2 id="Visibility"><a href="#Visibility" class="headerlink" title="Visibility"></a>Visibility</h2><p>package and subpackages 的信息，详见<a target="_blank" rel="noopener" href="https://bazel.build/concepts/build-ref">概念和术语</a>。</p>
<p>Visibility 控制了当前的 target 是否可以被其他 package 中的 target 依赖。从而区分 library API 以及实现细节。关闭可见性检查： <code>--check_visibility=false</code>。</p>
<h3 id="Visibility-specifications"><a href="#Visibility-specifications" class="headerlink" title="Visibility specifications"></a>Visibility specifications</h3><p>rule target 的 <code>visibility</code> 属性中包含多个 labels，表示此 target 对这些 labes 可见。同一个 package 中的 target 是互相可见的。</p>
<p>labels 的形式：</p>
<ul>
<li><code>&quot;//visibility:public&quot;</code>：任何人都可以使用此 target。</li>
<li><code>&quot;//visibility:private&quot;</code>：只有此 package 可以使用此 target。</li>
<li><code>&quot;//foo/bar:__pkg__&quot;</code>：<code>//foo/bar</code>（不包含其 subpackage） 下定义的 targets 可以使用此 target。<code>__pkg__</code> 是 package 中所有 targets 的特殊句法。</li>
<li><code>&quot;//foo/bar:__subpackages__&quot;</code>：<code>//foo/bar</code>下定义的（包括直接或间接 package 的）所有 targets，可以使用此 target。</li>
<li><code>&quot;//foo/bar:my_package_group&quot;</code>：<a target="_blank" rel="noopener" href="https://bazel.build/reference/be/functions#package_group">package group</a> 中的所有 package 可访问。</li>
</ul>
<p>example</p>
<pre><code class="python">//some/package

cc_library (
  name = &quot;mytarget&quot;,
  src = [&quot;xx&quot;,],
  visibiliry = [
    &quot;:__subpackages__&quot;,
    &quot;//tests:__pkg__&quot;
  ]
)

# mytarget 可以被 //some/package/... 下的所有 target 以及 //tests/BUILD 中定义的 target 使用，但是不能被 //tests/integration/BUILD 中的 target 使用。
</code></pre>
<p><code>package_group</code>  targets 本身没有 visibility 属性，总是 publicly visible。</p>
<p>Visibility cannot be set to specific non-package_group targets. That triggers a “Label does not refer to a package group” or “Cycle in dependency graph” error.</p>
<h3 id="Visibility-of-a-rule-target-generated-file-target"><a href="#Visibility-of-a-rule-target-generated-file-target" class="headerlink" title="Visibility of a rule target/generated file target"></a>Visibility of a rule target/generated file target</h3><p>rule target 中没有设置 visibility 属性，则可见性由BUILD 文件中的 package statement 设定，key 是  <a target="_blank" rel="noopener" href="https://bazel.build/reference/be/functions#package.default_visibility"><code>default_visibility</code></a> 。 没有声明 default_visibility 时，默认是 <code>//visibility:private</code>。</p>
<p>config_setting 可见性默认不强制生效。</p>
<p><code>--incompatible_enforce_config_setting_visibility</code> and <code>--incompatible_config_setting_private_default_visibility</code> provide migration logic for converging with other rules.</p>
<ul>
<li><p>If <code>--incompatible_enforce_config_setting_visibility=false</code>, every <code>config_setting</code> is unconditionally visible to all targets.</p>
</li>
<li><p>Else if <code>--incompatible_config_setting_private_default_visibility=false</code>, any <code>config_setting</code> that doesn’t explicitly set visibility is <code>//visibility:public</code> (ignoring package <a target="_blank" rel="noopener" href="https://bazel.build/reference/be/functions#package.default_visibility"><code>default_visibility</code></a>).</p>
</li>
<li><p>Else if <code>--incompatible_config_setting_private_default_visibility=true</code>, <code>config_setting</code> uses the same visibility logic as all other rules.</p>
</li>
</ul>
<p>Best practice is to treat all like other rules: explicitly set <code>visibility</code> on any <code>config_setting</code> used anywhere outside its package.</p>
<p>最佳实践：</p>
<ul>
<li>将  <code>config_setting</code> targets 和其他 rules 一样对待：为每个用到 <code>config_setting</code> 的package，显示设置  <code>visibility</code> 。</li>
</ul>
<h3 id="Visibility-of-a-source-file-target"><a href="#Visibility-of-a-source-file-target" class="headerlink" title="Visibility of a source file target"></a>Visibility of a source file target</h3><p>默认情况下，源文件 targets 只在同一个 package 中可见，如果其他 package 也想访问此源文件，使用 <a target="_blank" rel="noopener" href="https://bazel.build/reference/be/functions#exports_files"><code>exports_files</code></a>。使用此方法时，如果设置了 visibility 属性，则应用；否则文件就是 public 的， <code>default_visibility</code> 设置被忽略。</p>
<p>如果可以，推荐将文件包裹成 library 或者其他类型的 rule，而不是直接用源文件。</p>
<p>example：</p>
<p>File <code>//frobber/data/BUILD</code>：</p>
<pre><code class="python">exports_files([&quot;readme.txt&quot;])
</code></pre>
<p>File <code>//frobber/bin/BUILD</code>：</p>
<pre><code class="python">cc_binary(
  name = &quot;my-program&quot;,
  data = [&quot;//frobber/data::readme.txt&quot;],
)
</code></pre>
<p>If the flag <a href="https://github.com/bazelbuild/bazel/issues/10225"><code>--incompatible_no_implicit_file_export</code></a> is not set, a legacy behavior applies instead.</p>
<p>With the legacy behavior, files used by at least one rule target in the package are implicitly exported using the <code>default_visibility</code> specification. See the <a href="https://github.com/bazelbuild/proposals/blob/master/designs/2019-10-24-file-visibility.md#example-and-description-of-the-problem">design proposal</a> for more details.</p>
<h3 id="Visibility-of-bzl-files"><a href="#Visibility-of-bzl-files" class="headerlink" title="Visibility of bzl files"></a>Visibility of bzl files</h3><p>load statement 暂时不应用 visibility，因此可以在 workspace 的任意地方加载 bzl 文件。</p>
<p>However, users may choose to run the Buildifier linter. The <a href="https://github.com/bazelbuild/buildtools/blob/master/WARNINGS.md#bzl-visibility">bzl-visibility</a> check provides a warning if users <code>load</code> from beneath a subdirectory named <code>internal</code> or <code>private</code>.</p>
<h3 id="Visibility-of-implicit-dependencies"><a href="#Visibility-of-implicit-dependencies" class="headerlink" title="Visibility of implicit dependencies"></a>Visibility of implicit dependencies</h3><p>有的 rules 有隐式依赖。如 c++ 的 rule 可能隐式依赖 c++ 编译器。当前的隐式依赖和一般依赖的处理方式一致，需要对 rule 的所有实例可见，通过 using <a href="https://github.com/bazelbuild/proposals/blob/master/designs/2019-10-15-tool-visibility.md"><code>--incompatible_visibility_private_attributes_at_definition</code></a>. 修改此行为。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul>
<li>避免将 default visibility 设置为 public</li>
<li>使用  <code>package_group</code> 在多个 targets 中共享 vidibility 声明。当多个 BUILD 中的 targets 需要暴露给同一个 package 的集合时，此方法很有用。</li>
<li>当 deprecating 一个 target 时，使用更细粒度的可见性说明，只将 visibillity 限制给当前的用户，避免新的依赖。</li>
</ul>
<h2 id="Platforms"><a href="#Platforms" class="headerlink" title="Platforms"></a>Platforms</h2><h2 id="Hermeticity"><a href="#Hermeticity" class="headerlink" title="Hermeticity"></a>Hermeticity</h2><h2 id="cc-libraryxxxx"><a href="#cc-libraryxxxx" class="headerlink" title="cc_libraryxxxx"></a>cc_libraryxxxx</h2><p>头文件的包含检查。=》只适用于直接包含。<br>● 在编译中用到的头文件，必须在cc_* rule 的 hdrs 或者 srcs 中被声明。=》强制<br>● 对于 cc_library rules，hdrs 中的头文件，组成了这个 library 的公共接口<br>    ○ 此 library 的 hdrs 和 srcs 中的文件可直接包含 hrds 中的头文件<br>    ○ 其他 library 的 deps 如果依赖此 library，其 srcs 和 hdrs 也能包含此 library 的hdrs中的头文件<br>● srcs 中的头文件只能被此 library 的 hdrs 和 srcs 中的文件包含。<br>● 将文件放在 srcs 或者 hdrs，需要考虑，你是否希望此 library 的用户可以直接包含这个头文件，类似编程语言中的 public 和 private。<br>cc_binary 和 cc_test rule 没有对外的接口，因此没有 hdrs 属性，直接放在 srcs 中就行。<br>对.cc文件的编译，可以递归地包含在递归的 deps 必报中的所有 cc_library 中的 hdrs 和 srcs 中的文件。</p>
<h1 id="Output-Directory-Layout-xxx"><a href="#Output-Directory-Layout-xxx" class="headerlink" title="Output Directory Layout xxx"></a>Output Directory Layout xxx</h1><p><a target="_blank" rel="noopener" href="https://bazel.build/docs/output_directories">https://bazel.build/docs/output_directories</a><br>条件<br>当前布局<br>● Bazel 必须在包含 WORKSPACE 的目录 or 其子目录中被调用<br>● 输出根目录（outputRoot）默认为：<br>    ○ linux：~/.cache/bazel<br>    ○ macos：/private/var/tmp<br>    ○ Windows：defaults to %HOME%, %USERPROFILE%<br>    ○ 如果设置了环境变量 $TEST_TMPDIR ，对 bazel 做测试，则覆盖默认<br>● 用户构建状态存在于outputUserRoot：outputRoot/<em>bazel</em>$USER，其中包含：<br>    ○ install/md5(Bazel installation manifest)：installBase<br>    ○ 如果 bazel 在 workspace 目录（或者符号链接）/home/user/src/my-project，outputBase 是目录名的 MD5 hash。<br>        ■ 可以使用 –output_base 覆盖原有的 output base 目录<br>        ■ 可以使用 –output_user_root 启动选项覆盖默认的 install base 和 output base目录<br>● bazel-<workspace-name>，bazel-out，bazel-testlogs，bazel-bin 在 workspace 目录，都是一些符号链接，指向 output 目录中 target-specific 的目录。这些文件只为用户方便使用，Bazel 不使用。 </p>
<p>布局图</p>
<p>bazel clean<br>● bazel clean 在 outputPath 和 action_cache 目录上执行 ，并移除 workspace 符号链接。–expunge 清空整个 outputBase。</p>
<h4 id="Wrokspace-Rules。xxxx"><a href="#Wrokspace-Rules。xxxx" class="headerlink" title="Wrokspace Rules。xxxx"></a><a target="_blank" rel="noopener" href="https://bazel.build/reference/be/workspace">Wrokspace Rules</a>。xxxx</h4><p>当你使用bazel build xxxx命令进行编译时，bazel 会以 WORKSPACE 文件所在目录作为根目录（寻找输入和BUILD文件）进行编译，并存储编译结果。<br>WORKAPCE 文件里定义了bazel项目的一些基本信息，和项目需要的外部依赖（比如当前项目依赖外部项目中的目标，或者从网上下载项目）<br>● 主项目的BUILD文件可以使用 WORKSPACE 中的名字，依赖外部 target<br>● WORKSPACE 文件中的语法和BUILD类似，但是还允许其他的规则<br>● repository rules（workspace rules）<br>    ○ 内置规则：<a target="_blank" rel="noopener" href="https://docs.bazel.build/versions/main/be/workspace.html">https://docs.bazel.build/versions/main/be/workspace.html</a><br>        ■ local_repository<br>        ■ new_local_repository<br>    ○ starlark 中内嵌的 repository 规则（git or http）：<a target="_blank" rel="noopener" href="https://docs.bazel.build/versions/main/repo/index.html">https://docs.bazel.build/versions/main/repo/index.html</a><br>    ○ 用户自定义 repository 规则：<a target="_blank" rel="noopener" href="https://docs.bazel.build/versions/main/skylark/repository_rules.html">https://docs.bazel.build/versions/main/skylark/repository_rules.html</a><br>外部依赖定义方式<br>详细见：<a target="_blank" rel="noopener" href="https://docs.bazel.build/versions/main/external.html">https://docs.bazel.build/versions/main/external.html</a><br>建议 http_archive &gt; git_repository &gt; new_git_repository<br>依赖其他 Bazel 项目<br>可以使用 local_repository，git_repository, http_archive，分别代表：从本地文件系统软连接，引用 git 仓库，从网上下载。<br>● WORKSPACE 中写法：<br>local_repository(<br>    name = “coworkers_project”,<br>    path = “/path/to/coworkers-project”,<br>)</p>
<p>● BUILD 中写法：@coworkers_project//foo:bar 。外部项目的命名必须是合法的workspace名字，即用 xx_xx，而不是 xx-xx。<br>依赖其他非 Bazel 项目<br>new_local_repository，new_git_repository， http_archive<br>依赖外部包<br>比如maven项目</p>
<h2 id="认识-bazelrc文件-xxxx"><a href="#认识-bazelrc文件-xxxx" class="headerlink" title="认识.bazelrc文件 xxxx"></a>认识.bazelrc文件 xxxx</h2><p>bazel在编译时可以指定编译选项，包括gcc的选项以及 bazel 自身的选项。否则，每次使用bazel build xxxx命令进行编译时，你都需要指定编译选项，比如c++17。</p>
<h1 id="编写-BUILD-文件"><a href="#编写-BUILD-文件" class="headerlink" title="编写 BUILD 文件"></a>编写 BUILD 文件</h1><h2 id="BUILD-文件的风格"><a href="#BUILD-文件的风格" class="headerlink" title="BUILD 文件的风格"></a>BUILD 文件的风格</h2><p>使用 <a href="https://github.com/bazelbuild/buildifier">Buildifier</a> 格式化 BUILD 文件。</p>
<ul>
<li><p>文件的结构：</p>
<ul>
<li><p>描述/注释</p>
<ul>
<li>单独的注释下面用空行隔开</li>
<li>某个元素的注释紧挨着</li>
</ul>
</li>
<li><p>load</p>
</li>
<li><p>package</p>
</li>
<li><p>对 rules/macros 的调用</p>
</li>
</ul>
</li>
<li><p>引用当前package的 targets：</p>
<ul>
<li><p>使用相对于package 的路径，不要用<code>..</code> </p>
</li>
<li><p>生成的文件，引用时以 <code>:</code> 开头，标识其不是源文件</p>
</li>
<li><p>源文件不要以 <code>:</code> 开头</p>
</li>
<li><p>rules 需要以<code>:</code>  开头</p>
<pre><code class="python">cc_library(
    name = &quot;lib&quot;,
    srcs = [&quot;x.cc&quot;],
    hdrs = [&quot;:gen_header&quot;],
)

genrule(
    name = &quot;gen_header&quot;,
    srcs = [],
    outs = [&quot;x.h&quot;],
    cmd = &quot;echo &#39;int x();&#39; &gt; $@&quot;,
)
</code></pre>
</li>
</ul>
</li>
<li><p>target 命名</p>
<ul>
<li>命名需要有描述性<ul>
<li>如果 target 包含源文件，target name 需要和 源文件名一致。</li>
<li>与 package 同名的 target 在最后一层目录，其名字需要具有描述性，如果描述和target不一致，不要用同名 target。</li>
<li>当使用 eponymous target 时，建议用 短名字：(<code>//x</code> instead of <code>//x:x</code>)。</li>
<li>如果在同一个 package 中，建议用局部引用： (<code>:x</code> instead of <code>//x</code>)。</li>
<li>不要使用保留的关键字。如 all，<code>__pkg__</code>等。</li>
</ul>
</li>
<li>google 的推荐命名做法</li>
</ul>
</li>
<li><p>visibility</p>
<ul>
<li>尽量使用准确的可见性，只有对外暴露的才使用 public。</li>
</ul>
</li>
<li><p>dependencies</p>
<ul>
<li>尽量限制为直接依赖。代码中有的依赖中也写。</li>
<li>本 package 的依赖优先写，不要用绝对 package 名。</li>
<li>将通用的依赖放在一个变量中。</li>
</ul>
</li>
<li><p>Globs</p>
<ul>
<li>使用 <code>[]</code> 标识没有 targets，不要使用 glob 去匹配 nothing。</li>
<li>不要用递归的 globs 匹配源文件，如 <code>glob([&quot;**/*.java&quot;])</code>)。</li>
<li>建议每个文件夹下都放一个 BUILD 文件，生成依赖图。</li>
<li>非递归的 globs 是可接受的。</li>
</ul>
</li>
<li><p>其他惯例</p>
<ul>
<li>使用大写和下划线声明常量（如  <code>GLOBAL_CONSTANT</code>），使用小写和下划线声明变量（如  <code>my_variable</code>）。</li>
<li>labels 不要切分，便于替换等操作。</li>
<li>name 属性的名字需要是 常量字符串。</li>
<li>设置布尔值属性时，使用 true/false 而不是 0/1。</li>
</ul>
</li>
</ul>
<h2 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h2><ul>
<li><p>当一条内容会被多次使用，可以在当前 BUILD 文件中定义变量（全局常量一般用大写字母），如 <code>COPTS = [&quot;-DVERSION=5&quot;]</code> 。</p>
</li>
<li><p>在多个 BUILD 文件间共享变量，需要放在 .bzl 文件中。</p>
<ul>
<li>.bzl 文件中的定义（变量和函数）可以用在 BUILD 文件中。</li>
</ul>
<p>In <code>path/to/variables.bzl</code>, write:</p>
<pre><code class="python">COPTS = [&quot;-DVERSION=5&quot;]
</code></pre>
<p>Then, you can update your <code>BUILD</code> files to access the variable:</p>
<pre><code class="python">load(&quot;//path/to:variables.bzl&quot;, &quot;COPTS&quot;)

cc_library(
  name = &quot;foo&quot;,
  copts = COPTS,
  srcs = [&quot;foo.cc&quot;],
)
</code></pre>
</li>
</ul>
<h2 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h2><p>bazel 可以依赖其他项目的 targets，其他项目的依赖叫做外部依赖（<em>external dependencies</em>）。</p>
<p><code>WORKSPACE/WORKSPACE.bazel</code> 文件描述了 bazel 如何获取其他项目的源文件，称作 <em>repository rules</em> /<em>workspace rules</em></p>
<ul>
<li>其他项目也包含了多个 BUILD 文件描述自己的 targets。</li>
<li>mian 项目中的 BUILD 文件可以使用 WORKSPACE 中定义的名字，来引用外部的 targets。</li>
</ul>
<p>Bazel comes with a few <a target="_blank" rel="noopener" href="https://bazel.build/reference/be/workspace">built-in repository rules</a> and a set of <a target="_blank" rel="noopener" href="https://bazel.build/rules/lib/repo">embedded Starlark repository rules</a>. Users can also write <a target="_blank" rel="noopener" href="https://bazel.build/rules/repository_rules">custom repository rules</a> to get more complex behavior.</p>
<h3 id="bazel-支持的外部依赖类型"><a href="#bazel-支持的外部依赖类型" class="headerlink" title="bazel 支持的外部依赖类型"></a>bazel 支持的外部依赖类型</h3><ol>
<li>Depending on other Bazel projects<ul>
<li>可以用 <a target="_blank" rel="noopener" href="https://bazel.build/reference/be/workspace#local_repository"><code>local_repository</code></a>, <a target="_blank" rel="noopener" href="https://bazel.build/rules/lib/repo/git#git_repository"><code>git_repository</code></a> or <a target="_blank" rel="noopener" href="https://bazel.build/rules/lib/repo/http#http_archive"><code>http_archive</code></a> ，从本地文件系统软链，或者引用 git repository，或者下载。</li>
</ul>
</li>
<li>Depending on non-Bazel projects<ul>
<li>为此项目的依赖写 BUILD 文件。build_file </li>
</ul>
</li>
<li>Depending on external packages<ul>
<li>Maven artifacts and repositories</li>
</ul>
</li>
</ol>
<ul>
<li><p>获取依赖：</p>
<ul>
<li><p>一般通过 <code>bazel build</code></p>
</li>
<li><p>要为一些 targets 预拉取，使用 <code>bazel fetch</code></p>
</li>
<li><p>无条件拉取所有依赖，使用 <code>bazel sync</code></p>
</li>
<li><p>As fetched repositories are <a target="_blank" rel="noopener" href="https://bazel.build/docs/external#layout">stored in the output base</a>, fetching happens per workspace</p>
</li>
</ul>
</li>
<li><p>Shadowing dependencies</p>
<ul>
<li>尽可能在自己的项目中只依赖一种版本</li>
<li>xxx</li>
</ul>
</li>
<li><p>通过命令行覆写 repositories</p>
<ul>
<li>设置 <a target="_blank" rel="noopener" href="https://bazel.build/reference/command-line-reference#flag--override_repository"><code>--override_repository</code></a> flag. 使用此flag，只改变外部 repository 的内容，而不改变源码。</li>
<li>to override <code>@foo</code> to the local directory <code>/path/to/local/foo</code>, pass the <code>--override_repository=foo=/path/to/local/foo</code> flag。</li>
<li>用途<ul>
<li>debugging，不去拉远端，而改本地，让调试更方便。</li>
<li>Vendoring，没法发起网络调用的环境下，使用本地 repository。</li>
</ul>
</li>
</ul>
</li>
<li><p>Transitive dependencies</p>
<ul>
<li>Bazel only reads dependencies listed in your <code>WORKSPACE</code> file. If your project (<code>A</code>) depends on another project (<code>B</code>) which lists a dependency on a third project (<code>C</code>) in its <code>WORKSPACE</code> file, you’ll have to add both <code>B</code> and <code>C</code> to your project’s <code>WORKSPACE</code> file. This requirement can balloon the <code>WORKSPACE</code> file size, but limits the chances of having one library include <code>C</code> at version 1.0 and another include <code>C</code> at 2.0.</li>
</ul>
</li>
<li><p>缓存外部依赖</p>
<ul>
<li>Bazel 默认只会对修改的部分重新下载。如果强制重新下载，使用  <code>bazel sync</code>。</li>
</ul>
</li>
<li><p>布局</p>
<ul>
<li>外部依赖下载到 external 文件夹。</li>
<li><code>bazel clean</code> 只清除了软链，而 <code>bazel clean --expunge</code> 清除了所有外部 artifacts。</li>
</ul>
</li>
<li><p>线下构建</p>
<ul>
<li>xxx</li>
</ul>
</li>
</ul>
<h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul>
<li><p>A repository rule should generally be responsible for:</p>
<ul>
<li><p>Detecting system settings and writing them to files.</p>
</li>
<li><p>Finding resources elsewhere on the system.</p>
</li>
<li><p>Downloading resources from URLs.</p>
</li>
<li><p>Generating or symlinking BUILD files into the external repository directory.</p>
</li>
</ul>
</li>
<li><p>尽量避免使用 <code>repository_ctx.execute</code> </p>
<ul>
<li>当使用非bazel 化的 c++ library，优先推荐使用 <code>repository_ctx.download()</code> ，之后写 BUILD 文件构建它，而不是运行   <code>ctx.execute([&quot;make&quot;])</code>。</li>
</ul>
</li>
<li><p>Prefer <a target="_blank" rel="noopener" href="https://bazel.build/rules/lib/repo/http#http_archive"><code>http_archive</code></a> to <code>git_repository</code> and <code>new_git_repository</code>：</p>
<ul>
<li>Git repository 依赖于系统中的 git，而 HTTP 下载器是集成在 bazel 中的，没有系统依赖。</li>
<li><code>http_archive</code> 支持 <code>urls</code> 列表作为 mirrors, 而  <code>git_repository</code> 只支持单个的 <code>remote</code>。</li>
</ul>
</li>
</ul>
<h2 id="通过-Bzlmod-管理依赖-new-xxx"><a href="#通过-Bzlmod-管理依赖-new-xxx" class="headerlink" title="通过 Bzlmod 管理依赖 new xxx"></a>通过 Bzlmod 管理依赖 new xxx</h2><h1 id="运行-bazel"><a href="#运行-bazel" class="headerlink" title="运行 bazel"></a>运行 bazel</h1><h2 id="用-bazel-构建"><a href="#用-bazel-构建" class="headerlink" title="用 bazel 构建"></a>用 bazel 构建</h2><h3 id="可用的-bazel-命令"><a href="#可用的-bazel-命令" class="headerlink" title="可用的 bazel 命令"></a>可用的 bazel 命令</h3><ul>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/user-manual#analyze-profile"><code>analyze-profile</code></a>: Analyzes build profile data.</li>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/user-manual#aquery"><code>aquery</code></a>: Executes a query on the <a target="_blank" rel="noopener" href="https://bazel.build/docs/build#analysis">post-analysis</a> action graph.</li>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/build#bazel-build"><code>build</code></a>: 构建特定目标</li>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/user-manual#canonicalize-flags"><code>canonicalize-flags</code></a>: Canonicalize Bazel flags.</li>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/user-manual#clean"><code>clean</code></a>: 移除输出文件，并停止 server</li>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/cquery"><code>cquery</code></a>: Executes a <a target="_blank" rel="noopener" href="https://bazel.build/docs/build#analysis">post-analysis</a> dependency graph query.</li>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/user-manual#dump"><code>dump</code></a>: Dumps the internal state of the Bazel server process.</li>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/user-manual#help"><code>help</code></a>: 打印命令的 help 信息，或者索引</li>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/user-manual#info"><code>info</code></a>: 打印 bazel server 的运行时信息</li>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/build#fetching-external-dependencies"><code>fetch</code></a>: 拉取 target 的所有外部依赖</li>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/user-manual#mobile-install"><code>mobile-install</code></a>: 在 mobile 设备上安装apps</li>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/query-how-to"><code>query</code></a>: 执行依赖图的查询</li>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/user-manual#running-executables"><code>run</code></a>: 运行特定 target</li>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/user-manual#shutdown"><code>shutdown</code></a>: 停止 bazel server</li>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/user-manual#running-tests"><code>test</code></a>: 构建和运行特定的 test target</li>
<li><a target="_blank" rel="noopener" href="https://bazel.build/docs/user-manual#version"><code>version</code></a>: 打印 bazel 的 version 信息</li>
</ul>
<h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><ul>
<li><code>bazel help command</code>: 打印 command 的 help 和 options</li>
<li><code>bazel help</code><a target="_blank" rel="noopener" href="https://bazel.build/docs/user-manual#startup-options"><code>startup_options</code></a>: Options for the JVM hosting Bazel.</li>
<li><code>bazel help</code><a target="_blank" rel="noopener" href="https://bazel.build/docs/build#specifying-build-targets"><code>target-syntax</code></a>: 解释特定 target 的句法</li>
<li><code>bazel help info-keys</code>: info 命令中使用的 keys</li>
</ul>
<p>command：bazel tool 执行的许多函数。<code>bazel build</code> 和 <code>bazel test</code> 用的比较多。</p>
<h3 id="构建单个-target"><a href="#构建单个-target" class="headerlink" title="构建单个 target"></a>构建单个 target</h3><p>用 label 标识要构建的 target。</p>
<ul>
<li>loads</li>
<li>analyzes</li>
<li>execute</li>
</ul>
<h3 id="构建多个-target"><a href="#构建多个-target" class="headerlink" title="构建多个 target"></a>构建多个 target</h3><p>bazel 允许多种方法，去声明要构建的 target，叫做 target patterns（Target patterns are a generalization of the label syntax for <em>sets</em> of targets, using wildcards. 单个targe也是一种通配 target 的特例），用于 <code>build</code>, <code>test</code>,   <code>query</code> commands。</p>
<ul>
<li>foo/… 表示 所有 package 的通配符</li>
<li>:all 表示某个 package 中所有的 targets</li>
<li>:* 是 :all 的超集，包含了 file 和 rule</li>
</ul>
<table>
<thead>
<tr>
<th><code>//foo/bar:wiz</code></th>
<th>Just the single target <code>//foo/bar:wiz</code>.</th>
</tr>
</thead>
<tbody><tr>
<td><code>//foo/bar</code></td>
<td>Equivalent to <code>//foo/bar:bar</code>.</td>
</tr>
<tr>
<td><code>//foo/bar:all</code></td>
<td><strong>All rule targets</strong> in the package <code>foo/bar</code>.</td>
</tr>
<tr>
<td><code>//foo/...</code></td>
<td><strong>All rule targets</strong> in <strong>all packages</strong> beneath the directory <code>foo</code>.</td>
</tr>
<tr>
<td><code>//foo/...:all</code></td>
<td><strong>All rule targets</strong> in <strong>all packages</strong> beneath the directory <code>foo</code>.</td>
</tr>
<tr>
<td><code>//foo/...:*</code></td>
<td><strong>All targets (rules and files)</strong> in <strong>all packages</strong> beneath the directory <code>foo</code>.</td>
</tr>
<tr>
<td><code>//foo/...:all-targets</code></td>
<td><strong>All targets (rules and files)</strong> in <strong>all packages</strong> beneath the directory <code>foo</code>.</td>
</tr>
<tr>
<td><code>//...</code></td>
<td><strong>All targets</strong> in packages <strong>in the workspace</strong>. This does not include targets from <a target="_blank" rel="noopener" href="https://bazel.build/docs/external">external repositories</a>.</td>
</tr>
<tr>
<td><code>//:all</code></td>
<td><strong>All targets</strong> in the <strong>top-level package</strong>, if there is a <code>BUILD</code> file at the root of the workspace.</td>
</tr>
</tbody></table>
<p>不以 // 开头的 target pattern，以相对于 working 目录的方式解析，下述例子假设有一个 working 目录：foo:</p>
<table>
<thead>
<tr>
<th><code>:foo</code></th>
<th>Equivalent to <code>//foo:foo</code>.</th>
</tr>
</thead>
<tbody><tr>
<td><code>bar:wiz</code></td>
<td>Equivalent to <code>//foo/bar:wiz</code>.</td>
</tr>
<tr>
<td><code>bar/wiz</code></td>
<td>Equivalent to:<code>//foo/bar/wiz:wiz</code> if <code>foo/bar/wiz</code> is a package<code>//foo/bar:wiz</code> if <code>foo/bar</code> is a package<code>//foo:bar/wiz</code> otherwise</td>
</tr>
<tr>
<td><code>bar:all</code></td>
<td>Equivalent to <code>//foo/bar:all</code>.</td>
</tr>
<tr>
<td><code>:all</code></td>
<td>Equivalent to <code>//foo:all</code>.</td>
</tr>
<tr>
<td><code>...:all</code></td>
<td>Equivalent to <code>//foo/...:all</code>.</td>
</tr>
<tr>
<td><code>...</code></td>
<td>Equivalent to <code>//foo/...:all</code>.</td>
</tr>
<tr>
<td><code>bar/...:all</code></td>
<td>Equivalent to <code>//foo/bar/...:all</code>.</td>
</tr>
</tbody></table>
<ul>
<li><p>bazel 允许 target 部分使用 / 而不是只有 :，在 bash finelname expansion 中很方便。</p>
<ul>
<li>例如 ：<code>foo/bar/wiz</code> is equivalent to <code>//foo/bar:wiz</code> (if there is a package <code>foo/bar</code>) or to <code>//foo:bar/wiz</code> (if there is a package <code>foo</code>).</li>
</ul>
</li>
<li><p>bazel 支持一次命令中有多个 target pattern</p>
<ul>
<li><code>bazel build foo/... bar/...</code>：构建 foo 目录和 bar 目录下的所有 target。</li>
<li><code>bazel build -- foo/... -foo/bar/...</code>：构建 foo 目录下 除了 foo/bar 下的所有 targets<ul>
<li><code>--</code> 是必要的，防止后续以 <code>-</code> 开头的参数，被解释为额外的 options </li>
<li> 这种方式并不能真正保证 /foo/bar 的 targets 不被构建，因为其target可能被其他部分依赖了，作为依赖被构建了</li>
</ul>
</li>
</ul>
</li>
<li><p>target 中带有  <code>tags = [&quot;manual&quot;]</code>  的 target，在执行 build / test 的命令时（query 命令不做此过滤），不会被包含在 target pattern（…, :*, :all 等） 中。必须明确指定。</p>
</li>
</ul>
<h3 id="拉取外部依赖"><a href="#拉取外部依赖" class="headerlink" title="拉取外部依赖"></a>拉取外部依赖</h3><p>默认情况下，bazel 在构建时下载和链接外部依赖。但我们有例外时 ：</p>
<ul>
<li><p>想知道何时加入了新的外部依赖</p>
</li>
<li><p>无网前，提前拉取依赖</p>
</li>
</ul>
<p>可以指定 <code>--fetch=false</code> flag 防止自动拉取。</p>
<ul>
<li>对于本地文件系统中文件的使用，不管这个 flag 是否设置，都会去拉取。</li>
<li>当关闭此 flag，但是构建过程中又需要外部的依赖，构建则会失败。</li>
<li>当需要运行 bazel fetch 时，此 flag 需要开启。<ul>
<li>fetch 发生在第一次构建前</li>
<li>加入新的外部依赖后</li>
</ul>
</li>
<li>拉取好外部依赖后， WORKSPACE 文件不修改时，fetch 不必再运行。</li>
<li><code>bazel fetch //foo:bar //bar:baz</code> 拉取这俩 target  需要的外部依赖。</li>
<li><code>bazel fetch //...</code> 拉取 workspace 需要的所有外部依赖。</li>
</ul>
<h4 id="repository-cache"><a href="#repository-cache" class="headerlink" title="repository cache"></a>repository cache</h4><p>bazel 试图避免多次拉取同一个文件，将所有下载的文件缓存在 <code>~/.cache/bazel/_bazel_$USER/cache/repos/v1/</code>. （此位置可以通过  <code>--repository_cache</code> option 修改 ），供所有 workspaces 和 installed versions 共享。</p>
<ul>
<li>如果下载请求的文件有 sha256，而 cache 中有文件有相同的 sha256，则可以直接使用，不仅安全，且避免非必要下载。</li>
<li>每次命中缓存，cache 中的文件的修改时间都被更新，最后一次使用 cache 目录中文件的时间很容易确定。for example to manually clean up the cache. The cache is never cleaned up automatically, as it might contain a copy of a file that is no longer available upstream.</li>
</ul>
<h4 id="Distribution-files-directories"><a href="#Distribution-files-directories" class="headerlink" title="Distribution files directories"></a>Distribution files directories</h4><p>和 repository cache 类似，用于避免重复下载。两者的主要差别是distribution directory  需要人工准备。</p>
<p>bazel 在搜索 repository cache之前，先在 分布式目录中搜寻。</p>
<p>使用  <a target="_blank" rel="noopener" href="https://bazel.build/reference/command-line-reference#flag--distdir"><code>--distdir=/path/to-directory</code></a> option，可以指定额外的目录去寻找文件，指定目录下的文件都可用（可能使得目录很大）。如果 WORKSPACE 文件中指定了sha256，那么只有匹配的文件会被用。</p>
<h4 id="隔离环境中运行-bazel"><a href="#隔离环境中运行-bazel" class="headerlink" title="隔离环境中运行 bazel"></a>隔离环境中运行 bazel</h4><p>为了保证 bazel 二进制的尺寸较小，Bazel 的隐式依赖在首次运行时，通过网络连接拉取。这些隐式的依赖包含的 toolchains 和 rules 可能并不是对所有人都是有必要的。但在隔离环境中会有问题，尽管可能在</p>
<ul>
<li><p>可以在有网的情况下，准备一个包含这些依赖的 distribution directory，通过线下的方式传输到隔离环境中。</p>
</li>
<li><p>对于每个新的 Bazel 二进制，都需要准备这样的目录，因为每个 release 的隐式依赖，可能会不同。</p>
</li>
<li><p>构建依赖，需要拉取 bazel 的仓库代码，并构建 @additional_distfiles//:archives.tar target，将生成的产物，解压到新的目录中。</p>
<ul>
<li><code>tar xvf bazel-bin/external/additional_distfiles/archives.tar -C &quot;$NEW_DIRECTORY&quot; --strip-components=3</code></li>
</ul>
</li>
<li><p>最后，在隔离环境中使用 bazel 时，<code>--distdir</code> flag 指向目录，或者在 .bazelrc 里面新增一条 <code>build --distdir=path/to/directory</code></p>
</li>
</ul>
<h3 id="Build-configurations-and-cross-compilation"><a href="#Build-configurations-and-cross-compilation" class="headerlink" title="Build configurations and cross-compilation"></a>Build configurations and cross-compilation</h3><h2 id="commands-和-options"><a href="#commands-和-options" class="headerlink" title="commands 和 options"></a>commands 和 options</h2><p>–copts 等</p>
<h2 id="编写-bazelrc-文件"><a href="#编写-bazelrc-文件" class="headerlink" title="编写 bazelrc 文件"></a>编写 bazelrc 文件</h2><h2 id="通过脚本调用-Bazel"><a href="#通过脚本调用-Bazel" class="headerlink" title="通过脚本调用 Bazel"></a>通过脚本调用 Bazel</h2><h2 id="客户端和服务端架构"><a href="#客户端和服务端架构" class="headerlink" title="客户端和服务端架构"></a>客户端和服务端架构</h2><p>Bazel 系统是 long-lived server 进程。相比 batch-oriented  （A technique that uses a single program loading to process many individual jobs, tasks, or requests for service.） 实现，可以做诸多优化，如缓存 BUILD 文件，依赖图等，从而加速增量的构建，允许不同的命令共享相同的 packages 缓存，使得 queries 也很快。</p>
<ul>
<li>当运行 bazel 时，启动了一个 client。</li>
<li>client 基于output base（默认是 base workspace 目录和 uderid）寻找 server。base workspace 和 urserid 的不同使得并发执行成为可能，因为会启动不同的server。<ul>
<li>如果同一个用户在多个 workspace 中构建，则有多个 Bazel server 进程。</li>
<li>多个用户可以在同一个 workstation 并行构建，因为基于不同的 userids，output base 不同。</li>
<li>如果client 找不到运行中的 server 实例，则新建一个。</li>
<li>server 进程空闲一段时间（默认 3h）后会停止。可以通过  startup option <code>--max_idle_secs</code>) 修改这一选项。<ul>
<li>不要同时留下太多空闲的 server，可以在执行完成后显示地关闭，或者设置小一点的过期时间。</li>
</ul>
</li>
</ul>
</li>
<li>使用 ps x/ ps -e f，Bazel server 进程的名字是 bazel(dirname)。<ul>
<li>dirname 是包含 workspace 目录根的目录。</li>
<li>如果用 ps 的其他选项，server 进程名可能只显示 java。</li>
<li>可以使用 shutdown 命令停止进程：<ul>
<li>停止前会先检查任务是否完成</li>
<li>一般没什么用，但是在脚本中很有用，当知道某个构建在特定的workspace 不会再发生。</li>
<li>接受  <code>--iff_heap_size_greater_than _n_</code>  option，需要输入一个整形的参数（MB）则根据已用内存量设定关闭。</li>
</ul>
</li>
<li>运行 <code>bazel</code> 时，client 首先检查 server 是否是适当的版本；<ul>
<li>停止旧的 server，启动新 server。</li>
<li>确保使用长时间运行的 server 进程，不会影响正确的版本。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="配置构建"><a href="#配置构建" class="headerlink" title="配置构建"></a>配置构建</h1><h2 id="可配置的属性"><a href="#可配置的属性" class="headerlink" title="可配置的属性"></a>可配置的属性</h2><h2 id="与-c-规则集成"><a href="#与-c-规则集成" class="headerlink" title="与 c++ 规则集成"></a>与 c++ 规则集成</h2><h2 id="Toolchain-Resolution-Implementation-Details？no-need"><a href="#Toolchain-Resolution-Implementation-Details？no-need" class="headerlink" title="Toolchain Resolution Implementation Details？no need"></a>Toolchain Resolution Implementation Details？no need</h2><h2 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h2><p>使用 Starlark （domain-specific language：DSL）声明编译目标</p>
<p>编译目标：具体说明了编译的 输入和依赖，编译规则，以及编译规则的可配置选项</p>
<p>编译规则：具体说明了Bazel 使用的编译工具（如编译器和链接方法及对应的配置）</p>
<p>Starlark</p>
<p>语法和python3类似，支持 None，bool，dict，function，int，list，string，文件为.bzl 后缀。</p>
<p>偏好不变性，只有 lists 和 dicts 是可变数据结构，但是对可变数据的修改只对当前上下文下创建的对象有效。</p>
<p>因为Bazel 编译是并行执行，当前文件定义的 list 一旦脱离当前环境，比如被其他文件饮用，则无法再编辑修改。</p>
<h3 id="BUILD-和-bzl-文件的区别"><a href="#BUILD-和-bzl-文件的区别" class="headerlink" title="BUILD 和 .bzl 文件的区别"></a>BUILD 和 .bzl 文件的区别</h3><p>BUILD 文件通过调用规则注册目标；.bal 文件提供了常量，规则，宏和函数的定义。</p>
<p>原生函数（native functions）和规则（native rules）在 BUILD 文件中是全局符号；而.bal 文件需要通过 native 模块加载这些函数和规则。</p>
<p>BUILD 文件中的限制：1）不可声明函数；2）不可使用*args和**kwarg参数。</p>
<p>BUILD 文件</p>
<p>大部分 BUILD 文件中只包含编译 rule 的声明，所以顺序是无关的。</p>
<p>BUILD 中不能包含函数的定义（为了将 code 和 data 分离，但是list comprehension 和 if 表达式是可以的）。函数可以在 .bzl 文件中声明；不允许有 *args 和 **kwargs 参数，需要显示列出所有的参数。</p>
<p>Starlark 的程序不可以执行任意的IO，因此对 BUILD 文件的解释不受外界影响（只依赖已知的输入，因此输出是可复制的）。</p>
<p>load</p>
<p>Bazel 的扩展是以 .bzl 结尾的文件。通过 load 声明从扩展中导入符号。<br>load(“//foo/bar:file.bzl”, “some_library”) ：加载 foo/bar/file.bzl 并将符号 some_library 添加到环境中。这样可以使用新的 rule，function，或者常量（如 string，list 等）。<br>● load 必须在最外层，不可以写在 function 内。<br>● load 的第一个参数表示 .bzl 文件，如果是一个相对的 label，则根据包含当前 bzl 文件的 package 来解析，而不是目录，且此 label 用前置 ：来表示。<br>● load 支持别名，可以给导入的符号分配不同的名字。load(“//foo/bar:file.bzl”, library_alias = “some_library”)<br>● 可以在 load 中同时定义别名和符号：load(“:my_rules.bzl”, “some_rule”, nice_alias = “some_other_rule”) </p>
<p>.bzl 文件中，对于_开头的符号不会被导入，并且不能从其他文件中加载，目前，可见性不影响加载。</p>
<p>编译 rule 的类型<br>● *_binary：编译可执行程序<br>● *_test：可依赖其他 libraries。<br>● *_library：指定单独编译的模块。可以依赖其他 libraries，binaries。</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 peiqi66@163.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>




    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'e4ca5dce21ab7d76162a',
            clientSecret: 'c4abdc319f5a4eeaa72e2ffecfa8a99fc48f0c8f',
            repo: 'haiki.github.io',
            owner: 'haiki',
            admin: ['haiki'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>







    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2021 haiki
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("http://www.xiaoxintuku.com/uploads/allimg/150603/1F32110a-0.jpg");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
