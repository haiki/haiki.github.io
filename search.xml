<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cmake</title>
      <link href="/2023/03/12/cmake/"/>
      <url>/2023/03/12/cmake/</url>
      
        <content type="html"><![CDATA[<p>想要根据项目定制 CmakeLists.txt，<strong>首先需要理解 cmake 是什么，用来做什么？</strong></p><p>根据参考文档：<a href="https://cmake.org/cmake/help/cmake2.4docs.html">比较老的官方文档</a>， <a href="https://cmake.org/cmake/help/book/mastering-cmake/chapter/Getting%20Started.html">Mastering CMake</a>，cmake practice：</p><p><strong>Cmake 是跨平台的 build system</strong>。开发者在项目的每层 source tree 目录中包含平台无关的配置文件 CMakeList.txt，用来定义编译流程，并根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件。</p><p>那么，<strong>makefile 是什么？用来做什么？</strong><br>makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作(因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令)</p><p>makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><p>那么，<strong>make 又是什么？</strong></p><blockquote><p>make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。<br>《引自 <a href="https://blog.csdn.net/haoel/article/details/2886">https://blog.csdn.net/haoel/article/details/2886</a>》</p></blockquote><blockquote><p>makefile文件由configure脚本运行生成，这就是为什么编译时configure必须首先运行的原因。《引自 <a href="https://blog.csdn.net/qq_21950671/article/details/94456864">https://blog.csdn.net/qq_21950671/article/details/94456864</a>》</p></blockquote><p>那么，<strong>cmake 和 makefile 之间的关系是什么？</strong></p><p>由上文可知，CMake 是跨平台编译工具，需要编写 CMakeLists.txt 文件。用 cmake 命令可将 CMakeLists.txt 文件转化为 make 所需要的 Makefiles 文件。用 make 命令调用g++来编译源码，生成可执行程序或共享库。</p><p>那么，<strong>编译又是什么？为什么要编译？</strong></p><p>程序中一切皆变量，CPU 访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，各种名称都会被替换成地址，而编译和链接过程的一项重要任务就是找到这些名称所对应的地址。</p><p>具体地，将源代码（.c/.cpp文件）编译成可执行文件，一般需要预处理、编译、汇编、链接四个步骤，每个步骤会分别调用预处理器、编译器、汇编器、链接器来完成。</p><p><img src="https://s2.loli.net/2023/03/12/b5X2RJIyHQBdNjc.png" alt="截屏2023-03-12 21.41.44.png"></p><p>在Linux环境下，如果你安装了GCC编译器（gcc 与 g++ 分别是 gnu 的 c &amp; c++ 编译器），你会看到在程序的安装目录下面会有各种二进制可执行文件：</p><ul><li>cpp：预处理器；</li><li>ccl：编译器；</li><li>as：汇编器；</li><li>ld：链接器；</li><li>ar：静态库制作工具</li></ul><p>对应地，gcc/g++ 在执行编译工作的时候，总共需要4步：</p><ul><li>预处理,生成 .i 的文件</li><li>将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs？]</li><li>汇编代码经汇编器变为目标代码(机器代码)，生成 .o 的文件[汇编器as]</li><li>链接目标代码, 生成可执行程序 [链接器ld]</li></ul><p>程序在编译过程中会分别使用这些工具，完成程序编译的每个流程。为了简化程序编译流程，GCC编译器一般会提供一个gcc命令。gcc 一次编译一个源代码文件，make 一次可编译多个源代码文件。</p><p><strong>最后，再回归cmake，cmake 怎么写，怎么用？</strong></p><ul><li>cmake 使用方法：<br>cmake 可执行文件是 CMake 命令行的接口，可在命令行中用 -D 选项配置项目；-i 选项允许用户以交互的方式配置。<br>cmake [options] <path-to-source><br>cmake [options] <path-to-existing-build></li></ul><p><img src="https://s2.loli.net/2023/03/12/qbKAyuTLVz5rn6d.png" alt="截屏2023-03-12 21.46.17.png"></p><p>——————————————————————————————————<br>reference：</p><ul><li><a href="https://www.hahack.com/codes/cmake/">https://www.hahack.com/codes/cmake/</a></li></ul><p>tutorial：<br>makefile</p><ul><li><a href="https://www.zhaixue.cc/makefile/makefile-rule.html">https://www.zhaixue.cc/makefile/makefile-rule.html</a></li></ul><p>cmake</p><ul><li><a href="https://cmake.org/cmake/help/book/mastering-cmake/chapter/Getting%20Started.html">https://cmake.org/cmake/help/book/mastering-cmake/chapter/Getting%20Started.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/2023/01/15/mysql/"/>
      <url>/2023/01/15/mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="了解-SQL"><a href="#了解-SQL" class="headerlink" title="了解 SQL"></a>了解 SQL</h2><h3 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h3><p>数据库</p><p>表</p><p>模式</p><p>列 和 数据类型</p><p>行</p><p>主键</p><h3 id="什么是-SQL"><a href="#什么是-SQL" class="headerlink" title="什么是 SQL"></a>什么是 SQL</h3><h2 id="MySQL-简介"><a href="#MySQL-简介" class="headerlink" title="MySQL 简介"></a>MySQL 简介</h2><p>MySQL是一种DBMS，即它是一种数据库软件。</p><h3 id="MySQL-工具"><a href="#MySQL-工具" class="headerlink" title="MySQL 工具"></a>MySQL 工具</h3><p>为了指定用户登录名ben，应该使用<code>mysql -u ben</code>。为了给出用户名、主机名、端口和口令，应该使用<code>mysql -u ben -p -h myserver -P 9999</code>。</p><p>命令输入在<code>mysql&gt;</code>之后;<br> 命令用<code>;</code>或<code>\g</code>结束，换句话说，仅按Enter不执行命令;</p><p> 输入<code>help</code>或<code>\h</code>获得帮助，也可以输入更多的文本获得特定命令的帮助(如，输入<code>help select</code>获得使用SELECT语句的帮助);</p><p> 输入<code>quit</code>或<code>exi</code>t退出命令行实用程序。</p><h2 id="使用-MySQL"><a href="#使用-MySQL" class="headerlink" title="使用 MySQL"></a>使用 MySQL</h2><p>关键字(key word) 作为MySQL语言组成部分的一个保留字。绝不要用关键字命名一个表或列。附录E列出了MySQL的关键字。</p><p>必须先使用USE打开数据库，才能读取其中的数据。 <code>USE customers;</code></p><p><code>SHOW DATABASES;</code>返回可用数据库的一个列表。</p><p><code>SHOW TABLES;</code> 返回当前选择的数据库内可用表的列表。</p><p><code>SHOW COLUMNS FROM customers;</code> 它对每个字段返回一行，行中包含字段名、数据 类型、是否允许NULL、键信息、默认值以及其他信息(如字段cust_id，auto_increment)。也可以用 <code>DESCRIBE customers</code>。</p><p>所支持的其他SHOW语句还有:</p><ul><li><code>SHOW STATUS;</code> 用于显示广泛的服务器状态信息;</li><li><code>SHOW CREATE DATABASE;</code> 和 <code>SHOW CREATE TABLE;</code> 分别用来显示创建特定数据库或表的MySQL语句;</li><li><code>SHOW GRANTS;</code> 用来显示授予用户(所有用户或特定用户)的安全权限;</li><li><code>SHOW ERRORS;</code> 和 <code>SHOW WARNINGS</code> 用来显示服务器错误或警告消息。</li></ul><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><p>INSERT是用来插入(或添加)行到数据库表的。插入可 以用几种方式使用:<br> 插入完整的行;</p><p>CREATE TABLE customers<br>(<br>  cust_id      int       NOT NULL AUTO_INCREMENT,<br>  cust_name    char(50)  NOT NULL ,<br>  cust_address char(50)  NULL ,<br>  cust_city    char(50)  NULL ,<br>  cust_state   char(5)   NULL ,<br>  cust_zip     char(10)  NULL ,<br>  cust_country char(50)  NULL ,<br>  cust_contact char(50)  NULL ,<br>  cust_email   char(255) NULL ,<br>  PRIMARY KEY (cust_id)<br>) ENGINE=InnoDB;</p><p>没有输出 INSERT语句一般不会产生输出。<br>对每个列必须提供一个值。如果某个列没有值,应该使用NULL值（假定表允许对该列指定空值）。第一列是个由MySQL自动增量。你不想给出一个值(这是MySQL的工作)，又不能省略此列(如前所述，必须给出每个列)，所以指定一个NULL值(它被 MySQL忽略，MySQL在这里插入下一个可用的cust_id值)。</p><pre><code class="sql">INSERT INTO CustomersVALUES(NULL,&#39;qipei&#39;,&#39;nanshan street&#39;,&#39;shenzhen&#39;,&#39;guangdong&#39;,&#39;10010&#39;,&#39;CN&#39;,NULL,NULL);</code></pre><p> 插入行的一部分<br>因为提供了列名，VALUES必须以其指定的次序匹配指定的列名，不 一定按各个列出现在实际表中的次序。</p><p>省略的列必须满足以下某个条件。<br> 该列定义为允许NULL值(无值或空值)。<br> 在表定义中给出默认值。这表示如果不给出值，将使用默认值。<br>如果对表中不允许NULL值且没有默认值的列不给出值，则 MySQL将产生一条错误消息，并且相应的行插入不成功。</p><pre><code class="sql">INSERT INTO Customers(cust_name,cust_contact,cust_email)VALUES(    &#39;peiqi&#39;,    &#39;1881157&#39;,    &#39;peiqi66@111.com&#39;);</code></pre><p><code>INSERT LOW_PRIORITY INTO</code> 指示MySQL 降低INSERT语句的优先级.</p><p> 插入多行;<br>// 如果是在cmd输入，第一条insert输入完就会执行了；因此要用脚本一次性执行？</p><pre><code class="sql">INSERT INTO customers(cust_name,cust_contact,cust_email) VALUES (    &#39;peiqi&#39;,    &#39;1881157&#39;,    &#39;peiqi66@111.com&#39;);INSERT INTO customers(cust_name,cust_city,cust_email) VALUES (    &#39;haiki&#39;,    &#39;shenzhen&#39;,    &#39;qipei@qq.com&#39;);</code></pre><p>只要每条INSERT语句中的列名(和次序)相同，可以如下组合各语句:单条INSERT语句有多组值，每组值用一对圆括号括起来， 用逗号分隔。</p><pre><code class="sql">INSERT INTO customers(cust_name,cust_contact,cust_email) VALUES (    &#39;peiqi&#39;,    &#39;1881157&#39;,    &#39;peiqi66@111.com&#39;),(    &#39;haiki&#39;,    &#39;12227894&#39;,    &#39;qipei@qq.com&#39;);</code></pre><p> 插入某些查询的结果。</p><p>INSERT SELECT，顾名思义，它是由一条INSERT语句和一条SELECT 语句组成的，将一条SELECT语句的结果插入表中。</p><p>在填充custnew时，不应该使用已经在customers 中使用过的cust_id值(如果主键值重复，后续的INSERT操作 将会失败)或仅省略这列值让MySQL在导入数据的过程中产 生新值。</p><p>这条语句将插入多少行有赖于custnew表中有多少行。</p><pre><code class="sql">INSERT INTO customers(cust_name,cust_contact,cust_email)SELECT cust_id,cust_contact,cust_emailFROM custnew;</code></pre><h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><p>为了更新(修改)表中的数据，可使用UPDATE语句。可采用两种方 式使用UPDATE(不要省略WHERE子句):</p><p> 更新表中特定行;</p><pre><code class="sql">UPDATE customers SET cust_email = &#39;haiki123@qq.com&#39;,cust_contact = &#39;12345&#39;WHERE cust_id = 2;</code></pre><p>在UPDATE语句中使用子查询。TODO?</p><pre><code class="sql">UPDATE customersSELECT cust_idcust_contact,cust_emailFROM customersWHERE cust_id = 2;</code></pre><p>如果用UPDATE语句更新多行，并且在更新这些<br>行中的一行或多行时出一个现错误，则整个UPDATE操作被取消 (错误发生前更新的所有行被恢复到它们原来的值)。为即使是发<br>生错误，也继续进行更新，可使用IGNORE关键字，如下所示: <code>UPDATE IGNORE customers...</code></p><p>为了删除某个列的值，可设置它为NULL(假如表定义允许NULL值)。</p><pre><code class="sql">UPDATE customersSET cust_contact = NULLWHERE cust_id = 3;</code></pre><p> 更新表中所有行。<br>不使用 WHERE 字句。</p><p>可以限制和控制UPDATE语句的使用，更多内 容请参见第28章。 TODO</p><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>为了从一个表中删除(去掉)数据，使用<code>DELETE</code>语句。可以两种方 式使用<code>DELETE</code>:<br> 从表中删除特定的行;</p><pre><code class="sql">DELETE FROM customersWHERE cust_id = 2;</code></pre><p><code>DELETE</code>不需要列名或通配符。<code>DELETE</code>删除整行而不是删除列。为了删除指定的列，请使用<code>UPDATE</code>语句。</p><p>  从表中删除所有行。<br> 不要省略<code>WHERE</code>子句。<br> <code>DELETE</code>与安全 可以限制和控制<code>DELETE</code>语句的使用，更多内 容请参见第28章。</p><p>删除表的内容而不是表 <code>DELETE</code>语句从表中删除行，甚至是删除表中所有行。但是，<code>DELETE</code>不删除表本身。</p><p>更快的删除：<br>可使用 <code>TRUNCATE TABLE</code> 语句(TODO)，它完成相同的工作，但速度更 快(TRUNCATE实际是删除原来的表并重新创建一个表，而不 是逐行删除表中的数据)。</p><p>下面是许多SQL程序员使用UPDATE或DELETE时所遵循的习惯。<br> 除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE 子句的UPDATE或DELETE语句。<br> <strong>保证每个表都有主键</strong>(如果忘记这个内容，请参阅第15章)，尽可能 像WHERE子句那样使用它(可以指定各主键、多个值或值的范围)。<br> 在对UPDATE或DELETE语句使用WHERE子句前，<strong>应该先用SELECT进行测试，保证它过滤的是正确的记录，</strong>以防编写的WHERE子句不<br>正确。<br> <strong>使用强制实施引用完整性的数据库</strong>(关于这个内容，请参阅第15<br>章)，这样MySQL将不允许删除具有与其他表相关联的数据的行。</p><h2 id="MANAGE-TABLE"><a href="#MANAGE-TABLE" class="headerlink" title="MANAGE TABLE"></a>MANAGE TABLE</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>为了用程序创建表，可使用SQL的CREATE TABLE语句。必须给出下列信息:</p><p> 新表的名字，在关键字CREATE TABLE之后给出; </p><p> 表列的名字和定义，用逗号分隔。</p><pre><code class="sql">CREATE TABLE customer (    cust_id int NOT NULL AUTO_INCREMENT,    cust_name char(50) NOT NULL,    cust_contact char(50) NULL,    cust_email char(50) NULL,    PRIMARY KEY (cust_id)) ENGINE=InnoDB;</code></pre><p>如果你仅想在一个表不存在时创建它，应该在表名后给出 <code>IF NOT EXISTS</code>。这样做不检查已有表的模式是否与你打算创建的表模式相匹配。它只是查看表名是否存在，并且仅在表名不 存在时创建它。</p><p>表中的列在创建时就要指定是否允许 NULL，只有两种选择。<br>理解<code>NULL</code>：不要把<code>NULL</code>值与空串相混淆。<code>NULL</code>值是没有值， 它不是空串。如果指定<code>&#39;&#39;</code>(两个单引号，其间没有字符)，这 在<code>NOT NULL</code>列中是允许的。空串是一个有效的值，它不是无值。<code>NULL</code>值用关键字<code>NULL</code>而不是空串指定。</p><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><p>主键值必须唯一。即，表中的每个行必须具有唯一的主 键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则 这些列的组合值必须唯一。</p><p><code>PRIMARY KEY(order_num, order_item)</code></p><p>主键为其值唯一标识表中每个行的列。<strong>主键中只能使用不允许NULL值的列。</strong>允许NULL值的 列不能作为唯一标识。</p><p><strong>每个表只允许一个AUTO_INCREMENT列，而且它必须被索引(如，通过使它成为主键)。</strong></p><p>如何在使用AUTO_INCREMENT列时获得这个值呢?可使 用last_insert_id()函数获得这个值，如下所示:<code>SELECT last_insert_id()</code><br>此语句返回最后一个AUTO_INCREMENT值，然后可以将它用于 后续的MySQL语句。</p><p>如果在插入行时没有给出值，MySQL允许指定此时使用的默认值。默认值用<code>CREATE TABLE</code>语句的列定义中的<code>DEFAULT</code>关键字指定 <code>age int NOT NULL DEFAULT 18</code>。</p><p>不允许函数与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量。</p><p>使用默认值而不是NULL值 许多数据库开发人员使用默认值而不是NULL列，特别是对用于计算或数据分组的列更是如此。</p><h4 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h4><p>MySQL有一个具体管理和处理数据的内部引擎。 在你使用 <code>CREATE TABLE</code>语句时，该引擎具体创建表，而在你使用<code>SELECT</code> 语句或进行其他数据库处理时，该引擎在内部处理你的请求。</p><p>MySql 具有多种引擎，它们具有各自不同的功能和特性，为不同的任务选择正确的引擎能获得良好的功能和灵活性。</p><p>以下是几个需要知道的引擎:（所支持引擎的完整列表(及它们之间的不同)，请 参阅<a href="http://dev.mysql.com/doc/refman/5.0/en/storage_engines.html%EF%BC%89">http://dev.mysql.com/doc/refman/5.0/en/storage_engines.html）</a><br>InnoDB 是一个可靠的事务处理引擎(参见第26章)，它不支持全文本搜索;<br> MEMORY在功能等同于MyISAM，但由于数据存储在内存(不是磁盘) 中，速度很快(特别适合于临时表);<br> MyISAM是一个性能极高的引擎，它支持全文本搜索(参见第18章)， 但不支持事务处理。</p><p>外键不能跨引擎 混用引擎类型有一个大缺陷。外键(用于强制实施引用完整性，如第1章所述)不能跨引擎，即使用一个引擎的表不能引用具有使用不同引擎的表的外键。</p><h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3><p>为了使用<code>ALTER TABLE</code>更改表结构，必须给出下面的信息:<br> 在<code>ALTER TABLE</code>之后给出要更改的表名(该表必须存在，否则将 出错);<br> 所做更改的列表。</p><p>添加列必须明确其数据类型。</p><pre><code class="sql">ALTER TABLE customersADD cust_age int;</code></pre><p>删除刚刚添加的列，可以这样做:</p><pre><code class="sql">ALTER TABLE customersDROP COLUMN cust_age;</code></pre><p>ALTER TABLE的一种常见用途是定义外键。</p><pre><code class="sql">ALTER TABLE ordersitemADD CONSTRAINT fk_orderitems_ordersFOREIGN KEY (order_num) REFERENCES orders (order_num);</code></pre><p>为了 对单个表进行多个更改，可以使用单条ALTER TABLE语句，每个更改用逗 号分隔。</p><p>小心使用ALTER TABLE 使用ALTER TABLE要极为小心，应该 在进行改动前做一个完整的备份(模式和数据的备份)。数据 库表的更改不能撤销，如果增加了不需要的列，可能不能删 除它们。类似地，如果删除了不应该删除的列，可能会丢失 该列中的所有数据。</p><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><pre><code class="sql">DROP TABLE customers;</code></pre><p>删除表没有确认， 也不能撤销，执行这条语句将永久删除该表。</p><h4 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h4><p>RENAME TABLE所做的仅是重命名一个表。</p><pre><code class="sql">RENAME TABLE Customers TO customers;</code></pre><p>对多个表重命名：</p><pre><code class="sql">RENAME TABLE Customers TO customers,orderitems TO orderItems;</code></pre><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><ol><li>为什么一个完整的sql语句要以分号结束？</li><li>空格会有什么影响？<ul><li>MySQL语句中忽略空格。 语句可以在一个长行上输入，也可以分成许多行。</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go语言圣经学习笔记</title>
      <link href="/2022/08/12/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/12/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>Go学习</strong></p><p>具体参见：<a href="https://yar999.gitbooks.io/gopl-zh/content/ch0/ch0-01.html"><strong>go语言圣经</strong></a></p><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h1><h2 id="0-1-Go语言项目"><a href="#0-1-Go语言项目" class="headerlink" title="0.1 Go语言项目"></a>0.1 Go语言项目</h2><ul><li>Go项目包括编程语言本身，附带了相关的工具和标准库，简洁编程哲学。Go语言的这些地方都做的还不错：<ul><li>拥有自动垃圾回收、一个包系统、函数作为一等公民、词法作用域、系统调用接口、只读的UTF8字符串等</li></ul></li><li>Go语言本身只有很少的特性，也不太可能添加太多的特性：<ul><li>它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。</li></ul></li><li>语言本身是成熟和稳定的，而且承诺保证向后兼容：<ul><li>用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码。</li><li>Go语言有足够的类型系统以避免动态语言中那些粗心的类型错误，不需要像C++或Haskell程序员那样纠结于具体类型的安全属性。</li></ul></li><li>Go语言鼓励当代计算机系统设计的原则，特别是局部的重要性：<ul><li>内置数据类型和大多数的标准库数据结构都经过精心设计而避免显式的初始化或隐式的构造函数</li><li>Go语言的聚合类型（结构体和数组）可以直接操作它们的元素，只需要更少的存储空间、更少的内存分配，而且指针操作比其他间接操作的语言也更有效率</li></ul></li><li>Go语言提供了基于CSP的并发特性支持</li><li>Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的</li><li>Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。</li><li>Go语言源代码本身就包含了构建规范。</li></ul><h1 id="1-Go入门"><a href="#1-Go入门" class="headerlink" title="1 Go入门"></a>1 Go入门</h1><h2 id="1-1-Hello，World"><a href="#1-1-Hello，World" class="headerlink" title="1.1 Hello，World"></a>1.1 Hello，World</h2><ul><li><p>Go是一门<strong>编译型语言</strong>，Go语言的工具链将源代码及其依赖转换成计算机的机器指令。</p></li><li><p>Go语言原生支持Unicode，它可以处理全世界任何语言的文本。</p></li><li><p>Go语言的代码通过<strong>包</strong>（package）组织。</p><ul><li>包类似于其它语言里的库（libraries）或者模块（modules）</li><li>一个包由位于单个目录下的一个或多个.go源代码文件组成，目录定义包的作用。</li><li>Go的标准库提供了100多个包，以支持常见功能，如输入、输出、排序以及文本处理。<a href="https://golang.org/pkg/">go packages-ch</a>，<a href="https://studygolang.com/pkgdoc">go语言中文网-go提供的包</a>。</li></ul></li><li><p>每个源文件都以一条package声明语句开始，<strong>表示该文件属于哪个包</strong>。</p><ul><li>import声明必须跟在文件的package声明之后，<strong>告诉编译器，源文件需要哪些包</strong>。</li><li>必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。</li></ul></li><li><p>存储在源文件里的程序语句，函数、变量、常量、类型的声明语句（分别由关键字func, var, const, type定义）。</p><pre><code>package mainimport &quot;fmt&quot;func main() &#123;    fmt.Println(&quot;Hello, 世界&quot;)&#125;</code></pre><ul><li>main包比较特殊。<strong>它定义了一个独立可执行的程序，而不是一个库。</strong></li><li>在 main包 里的 main函数 也很特殊，<strong>它是整个程序执行时的入口</strong>。main函数一般调用其它包里的函数完成很多工作, 比如fmt.Println。</li><li>一个函数的声明由func关键字、函数名、参数列表、返回值列表以及包含在大括号里的函数体组成。</li><li>Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号, 因此换行符添加的位置会影响Go代码的正确解析。<ul><li>函数的左括号{必须和func函数声明在同一行上, 且位于末尾，不能独占一行。</li><li>表达式x + y中，可在+后换行，不能在+前换行。</li></ul></li></ul></li><li><p>对于大多数用户来说，下载、编译包、运行测试用例、查看Go语言的文档等等常用功能都可以用go的工具完成。10.7节详细介绍这些知识。</p><ul><li>go build helloworld.go 生成一个名为helloworld的可执行的二进制文件，之后你可以随时运行(./helloworld)它，不需任何处理。</li><li>go run helloworld.go 编译一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件</li><li>Go语言在代码格式上采取了很强硬的态度：gofmt工具把代码格式化为标准格式，go工具中的fmt子命令会对指定包, 或默认为当前目录中所有go源文件应用gofmt命令。</li><li>goimports，可以根据代码需要, 自动地添加或删除import声明（这个工具不包含在分发包里，需要自己安装）。</li><li>执行 go get gopl.io/ch1/helloworld 命令，就会从网上获取代码，并放到对应目录中（需要先安装Git或Hg之类的版本管理工具，并将对应的命令添加到PATH环境变量中。</li></ul></li></ul><h2 id="1-2-命令行参数"><a href="#1-2-命令行参数" class="headerlink" title="1.2 命令行参数"></a>1.2 命令行参数</h2><p><strong>读写文件&amp;文本格式化</strong></p><ul><li><p>“计算”的定义：处理输入，产生输出。程序获取输入数据：</p><ul><li> 一些程序生成自己的数据</li><li> 通常情况下，<strong>输入来自于程序外部：文件、网络连接、其它程序的输出、敲键盘的用户、命令行参数或其它类似输入源</strong></li></ul></li><li><p>os包以跨平台的方式，提供了一些与操作系统交互的函数和变量。</p><ul><li>程序的命令行参数可从os包的Args变量获取；os包外部使用os.Args访问该变量。？</li><li>os.Args变量是一个字符串（string）的切片（slice）<ul><li>s[m:n]形式的切片表达式，产生从第m个元素到第n-1个元素的切片，左闭右开</li></ul></li><li>os.Args的第一个元素，os.Args[0], 是命令本身的名字；其它的元素则是程序启动时传给它的参数</li><li>元素一般包含在 os.Args[1:len(os.Args)] 切片中。如果省略切片表达式的m或n，会默认传入0或len(s)，因此前面的切片可以简写成os.Args[1:]</li></ul></li><li><p>自增语句i++给i加1，和i += 1（赋值运算符：*=/+=/-=等）以及i = i + 1都是等价的。**++和–都只能放在变量名后面**，因此–/++i是非法的。</p><ul><li>自增和自减是语句，而不是表达式，因此x = i++之类的表达式是错误的。</li></ul></li></ul><p><strong>For循环</strong></p><ul><li><p>Go语言只有for循环这一种循环语句。</p><ul><li><p>for循环三个部分不需括号包围。大括号强制要求, 左大括号必须和for语句在同一行。</p></li><li><p>initialization 语句是可选的，在循环开始前执行。如果存在，必须是一条简单语句（simple statement），即：短变量声明、自增语句、赋值语句或函数调用。</p></li><li><p>condition是一个布尔表达式（boolean expression），其值在每次循环迭代开始时计算。如果为true则执行循环体语句。</p></li><li><p>post语句在循环体执行结束后执行，之后再次对conditon求值。condition值为false时，循环结束。</p><pre><code>//1. 完整形式for initialization; condition; post &#123;    // zero or more statements    //for i := 1; i &lt; len(os.Args); i++&#125;//2. a traditional &quot;while&quot; loopfor condition &#123;&#125;//3. a traditional infinite loopfor &#123;//break或return语句终止循环&#125;//4. 在某种数据类型的区间（range）上遍历，如字符串或切片for _, arg := range os.Args[1:] &#123;    //每次循环迭代，range产生一对值：索引以及在该索引处的元素值    //Go语言不允许使用无用的局部变量（local variables），因为这会导致编译错误。    //空标识符（blank identifier），即_（也就是下划线）。空标识符可用于任何语法需要变量名但程序逻辑不需要的时候。&#125;</code></pre></li></ul></li></ul><p><strong>变量声明</strong></p><ul><li><p>声明一个变量有好几种方式，下面这些都等价：</p><pre><code>s := &quot;&quot; //短变量声明，最简洁，但只能用在函数内部，而不能用于包变量var s string  //依赖于字符串的默认初始化零值机制，被初始化为&quot;&quot;var s = &quot;&quot;  //用得很少，除非同时声明多个变量？var s string = &quot;&quot;  //显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了？</code></pre><ul><li>实践中一般使用前两种形式中的某个，初始值重要的话就显式地指定变量的类型，否则使用隐式初始化？</li></ul></li><li><p>如果连接涉及的数据量很大，str1 += str2 这种方式代价高昂。一种简单且高效的解决方案是使用strings包的Join函数：<br><code>fmt.Println(strings.Join(os.Args[1:], &quot; &quot;))</code>。</p></li><li><p>如果不关心输出格式，只想看看输出值，或许只是为了调试，可以用Println为我们格式化输出：<code>fmt.Println(os.Args[1:])</code> </p><ul><li>输出结果跟strings.Join得到的结果很像，只是被放到了一对方括号里。切片都会被打印成这种格式</li></ul></li></ul><p><strong>从标准输入中读取数据</strong></p><p><strong>if语句</strong></p><ul><li>正如for循环一样，if语句条件两边也不加括号，但是主体部分需要加。if语句的else部分是可选的，在if的条件为false时执行。</li></ul><p><strong>map数据类型</strong></p><ul><li>内置函数make创建空map<ul><li>键可以是任意类型，只要其值能用==运算符比较，最常见的例子是字符串；</li><li>值则可以是任意类型；</li><li>某个新键的初值会初始化；</li><li>每次迭代得到两个结果，键和其在map中对应的值；</li><li>map的迭代顺序并不确定，从实践来看，该顺序随机，每次运行都会变化。这种设计是有意为之的，因为能防止程序依赖特定遍历顺序，而这是无法保证的。</li><li>map作为参数传递给某函数时，该函数接收这个引用的一份拷贝（copy，或译为副本），被调用函数对map底层数据结构的任何修改，调用者函数都可以通过持有的map引用看到。</li></ul></li></ul><p>• bufio包</p><p>￮ Scanner类型</p><p>▪ Scanner.Text()</p><p>• fmt.Printf函数对一些表达式产生格式化输出</p><p>￮ 该函数的首个参数是个格式字符串，指定后续参数被如何格式化</p><p>￮ 各个参数的格式取决于“转换字符”（conversion character），形式为百分号后跟一个字母。<a href="https://studygolang.com/pkgdoc">package fmt</a></p><p>￮ 不可见字符的<strong>转义字符（<strong><strong>escap sequences</strong></strong>）**</strong>:\n,\t**<strong>等</strong></p><p>￮ 默认情况下，Printf不会换行。按照惯例，以字母f结尾的格式化函数，如log.Printf和fmt.Errorf，都采用fmt.Printf的格式化准则。而以ln结尾的格式化函数，则遵循Println的方式，以跟%v差不多的方式格式化参数，并在最后添加一个换行符。（译注：后缀f指fomart，ln指line。）</p><p><strong>从一系列具名文件中读取数据。</strong></p><p>• 使用os.Open打开各个具名文件，并操作它们。</p><p>￮ 返回两个值。第一个值是被打开的文件(*os.File），其后被Scanner读取。第二个值是内置error类型的值。如果err等于内置值nil，那么文件被成功打开。</p><p><strong>输入数据读到内存中，一次分割为多行</strong></p><p>• ReadFile函数（来自于io/ioutil包），其读取指定文件的全部内容，此函数需要文件名作为参数，因此只读指定文件，不读标准输入。</p><p>• ReadFile函数返回一个字节切片（byte slice），必须把它转换为string，才能用strings.Split分割。</p><p>• strings.Split函数把字符串分割成子串的切片。（Split的作用与前文提到的strings.Join相反。）</p><p>□ <strong>创建图像</strong></p><p>package image</p><p><strong>const****声明，</strong></p><p>• 常量是指在程序编译后运行时始终都不会变化的值</p><p>• 目前常量声明的值必须是一个数字值、字符串或者一个固定的boolean值。</p><p><strong>struct****结构体类型，</strong></p><p><strong>复合声明</strong></p><h2 id="1-2-程序结构"><a href="#1-2-程序结构" class="headerlink" title="1.2 程序结构"></a>1.2 程序结构</h2><p>Go语言程序的</p><p>• 基本元素结构、</p><p>• 变量、</p><p>• 新类型定义、</p><p>• 包和文件、</p><p>• 作用域</p><p>变量保存<strong>值</strong>，简单的加法和减法运算被组合成较复杂的<strong>表达式</strong>。基础类型被聚合为数组或结构体等更复杂的数据结构。然后使用if和for之类的控制语句来组织和控制表达式的执行流程。然后多个语句被组织到一个个函数中，以便代码的隔离和复用。函数以源文件和包的方式被组织。</p><p><strong>命名</strong></p><p>Go语言中的<strong>函数名、变量名、常量名、类型名、语句标号和包名</strong>等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的。长度无限制。</p><p>• 关键字 25 个</p><p>\1. break   default    func   interface  select</p><p>\2. case    defer     go    map     struct</p><p>\3. chan    else     goto   package   switch</p><p>\4. const   fallthrough  if    range    type</p><p>\5. continue  for      import  return   var</p><p>• 预定义的名字：主要对应内建的常量、类型和函数。</p><p>￮ 这些内部预先定义的名字并不是关键字，你可以再定义，重新使用它们。</p><p>￮ 以将new名字重新定义为别的类型。即作为一种变量名，那么函数内部是无法使用被重定义的内置函数。</p><p>\1. 内建常量: true false iota nil</p><p>\2.  </p><p>\3. 内建类型: int int8 int16 int32 int64</p><p>\4.      uint uint8 uint16 uint32 uint64 uintptr</p><p>\5.      float32 float64 complex128 complex64</p><p>\6.      bool byte rune string error</p><p>\7.  </p><p>\8. 内建函数: make len cap new append copy close delete</p><p>\9.      complex real imag</p><p>\10.      panic recover</p><p>• 如果一个名字是在函数内部定义，那么它的就只在函数内部有效。</p><p>• 如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。</p><p>• <strong>名字的开头字母的大小写决定了名字在包外的可见性。</strong></p><p>￮ 如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。</p><p>￮ 包本身的名字一般总是用小写字母。</p><p>• Go语言程序员推荐使用 <strong>驼峰式</strong> 命名，当名字有几个单词组成的时优先使用大小写分隔，而不是优先用下划线分隔。</p><p>• 像ASCII和HTML这样的缩略词则避免使用大小写混合的写法</p><p><strong>声明</strong></p><p>声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：<strong>var<strong><strong>、</strong></strong>const<strong><strong>、</strong></strong>type<strong><strong>和</strong></strong>func****，分别对应变量、常量、类型和函数实体对象的声明。</strong></p><p><strong>包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问。</strong>相比之下，局部声明的名字就只能在函数内部很小的范围被访问。</p><p><strong>变量</strong></p><p>var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：</p><p>\1. var 变量名字 类型 = 表达式</p><p>• <strong>“<strong><strong>类型</strong></strong>”</strong>或<strong>“=</strong> <strong>表达式****”</strong>两个部分可以省略其中的一个。</p><p>￮ 如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。</p><p>￮ 如果初始化表达式被省略，那么将用零值初始化该变量。</p><p>▪  数值类型变量对应的零值是0，</p><p>▪ 布尔类型变量对应的零值是false，</p><p>▪ 字符串类型对应的零值是空字符串，</p><p>▪ 接口或引用类型（包括slice、map、chan和函数）变量对应的零值是nil。</p><p>▪ 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。</p><p>￮ 零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在<strong>Go****语言中不存在未初始化的变量</strong>。</p><p>￮ Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态。</p><p>• 可以在一个声明语句中<strong>同时声明一组变量</strong>，或<strong>用一组初始化表达式声明并初始化一组变量</strong>。</p><p>￮ 如果省略每个变量的类型，类型由初始化表达式推导</p><p>￮ 一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化</p><p>• <strong>包级别声明的变量会在<strong><strong>main</strong></strong>入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化</strong>。</p><p><strong>简短变量声明</strong></p><p><strong>函数内部</strong>，有一种称为简短变量声明语句的形式可用于<strong>声明和初始化局部变量</strong>。它以<strong>“****名字</strong> <strong>:=</strong> <strong>表达式****”</strong> 形式声明变量，变量的类型根据表达式来自动推导。</p><p>• 简短变量声明被广泛用于大部分的局部变量的声明和初始化。也可以用来声明和初始化一组变量：i, j := 0, 1</p><p>￮ “:=”是一个变量声明语句，而“=‘是一个变量赋值操作</p><p>￮ 区分：元组的多重赋值：i, j = j, i // 交换 i 和 j 的值</p><p>• var形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</p><p>• 简短变量声明语句中必须至少要声明一个新的变量</p><p>• 简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量</p><p><strong>指针</strong></p><p>• 如果用“var x int”声明语句声明一个x变量，那么&amp;x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是<em>int，指针被称之为“指向int类型的指针”。</em>p表达式对应p指针指向的变量的值。</p><p>• 在Go语言中，返回函数中局部变量的地址也是安全的。在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。但是返回的地址应该都不一样。</p><p>• 每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名。【有点类似C++ 引用？】</p><p>￮ 不仅仅是指针会创建别名，很多其他引用类型也会创建别名，例如slice、map和chan，甚至结构体、数组和接口都会创建所引用变量的别名。</p><p>￮ 指针特别有价值的地方在于我们可以不用名字而访问一个变量，但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名（译注：这是Go语言的垃圾回收器所做的工作）</p><p><strong>new****函数</strong></p><p>表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后<strong>返回变量地址，返回的指针类型为</strong>*<strong>T</strong>。p := new(int)  // p, *int 类型, 指向匿名的 int 变量。</p><p><strong>变量的生命周期</strong></p><p>变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。</p><p>• 对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。</p><p>• 而相比之下，在局部变量的声明周期则是动态的：从每次<strong>创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收</strong>。</p><p>￮ 函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。</p><p>• Go语言的自动圾收集器是如何知道一个变量是何时可以被回收的呢？</p><p>￮ 基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。</p><p>￮ 因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。【所以意味着变量名不可以一样？】</p><p>￮ 编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，这个选择并不是由用var还是new声明变量的方式决定的。</p><p>▪ 变量的逃逸行为</p><p>• 虽然变量在函数内部定义，但函数退出后依然可以通过包一级的global变量找到，因此这个函数内的变量必须在堆上分配。</p><p>• 逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响</p><p>￮ 虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。</p><p>▪ 例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。</p><p> <strong>赋值</strong></p><p>使用赋值语句可以更新一个变量的值。</p><p>数值变量也可以支持++递增和–递减语句（译注：自增和自减是语句，而不是表达式，因此x = i++之类的表达式是错误的）</p><p><strong>元组赋值</strong></p><p>另一种形式的赋值语句，它允许同时更新多个变量的值。</p><p>在<strong>赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。</strong>这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助</p><p><strong>可赋值性</strong></p><p>赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句将隐式地将返回操作的值赋值给结果变量。</p><p>不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。即只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。</p><p>可赋值性的规则对于不同类型有着不同要求。基本的是：<strong>类型必须完全匹配，<strong><strong>nil</strong></strong>可以赋值给任何指针或引用类型的变量</strong>。常量（§3.6）则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。</p><p>对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的【即类型匹配】，反之依然。</p><p>□ <strong>类型</strong></p><p><strong>包和文件</strong></p><p>• Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。</p><p>• 通常一个包所在目录路径的后缀是包的导入路径；例如包gopl.io/ch1/helloworld对应的目录路径是$GOPATH/src/gopl.io/ch1/helloworld。</p><p>￮ 每个包都是有一个全局唯一的导入路径。</p><p>￮ 当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。</p><p>￮ 如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理。</p><p>▪ 我们可以使用golang.org/x/tools/cmd/goimports导入工具，它可以根据需要自动添加或删除导入的包；</p><p>▪ 类似的还有gofmt工具，可以用来格式化Go源文件。</p><p>• 每个包都对应一个独立的名字空间。</p><p>• 包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。</p><p>￮ 在Go语言中，一个简单的规则是：<strong>如果一个名字是大写字母开头的，那么该名字是导出的</strong>（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导的）。</p><p>• 包级别的名字，例如在一个文件声明的类型和常量，在同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。包级别的常量名都是以大写字母开头，它们可以像tempconv.AbsoluteZeroC这样被外部代码访问</p><p>• 在每个源文件的包声明前仅跟着的注释是包注释（§10.7.4）。通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释（译注：如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。如果包注释很大，通常会放到一个独立的doc.go文件中。</p><p>□ <strong>包的初始化</strong></p><p>• 包的初始化<strong>首先是解决包级变量的依赖顺序，然后安照包级变量声明出现的顺序依次初始化</strong></p><p>• 如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。</p><p>• 包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，用一个特殊的<strong>init****初始化函数</strong>来简化初始化工作。</p><p>￮ 每个文件都可以包含多个init初始化函数。</p><p>￮ init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。</p><p>￮ 在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。</p><p>• 每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。</p><p>• 初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依然的包都已经完成初始化工作了。</p><p><strong>作用域</strong></p><p>声明语句的作用域是指源代码中可以有效使用这个名字的范围。</p><p>• 不要将作用域和生命周期混为一谈。</p><p>￮ 声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。</p><p>￮ 一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。</p><p>• 语法块：花括弧所包含的一系列语句</p><p>• 声明语句对应的词法域决定了作用域范围的大小。</p><p>￮ 对于内置的类型、函数和常量，比如int、len和true等是在<strong>全局作用域</strong>的，因此可以在整个程序中直接使用。</p><p>￮ 任何在在函数外部（也就是<strong>包级语法域</strong>）声明的名字可以在同一个包的任何源文件中访问的。</p><p>￮ 对于导入的包，例如tempconv导入的fmt包，则是对应<strong>源文件级的作用域</strong>，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。</p><p>￮ 还有许多声明语句，比如tempconv.CToF函数中的变量c，则是<strong>局部作用域</strong>的，它只能在函数内部（甚至只能是局部的某些部分）访问。</p><p>￮ 控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是<strong>函数级的作用域。</strong></p><p>• 当编译器遇到一个名字引用时，如果它看起来像一个声明，它首先从最内层的词法域向全局的作用域查找。</p><p>￮ 如果查找失败，则报告“未声明的名字”这样的错误。</p><p>￮ 如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。在这种情况下，<strong>内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问。</strong></p><p>￮ </p><p>\3. <strong>基础数据类型</strong></p><p>数字、布尔值、字符串和常量，并演示了如何显示和处理Unicode字符</p><p>Go语言将数据类型分为四类：<strong>基础类型、复合类型、引用类型和接口类型</strong>。</p><p>本章介绍基础类型，包括：数字、字符串和布尔型。</p><p>• 两个相同类型的值可以用==和!=进行比较。此外，整数、浮点数和字符串可以根据比较结果排序。许多其它类型的值可能是不可比较的，因此也就可能是不可排序的。</p><p>Go语言的数值类型包括几种不同大小的整形数、浮点数和复数。每种数值类型都决定了对应的大小范围和是否支持正负符号。</p><p><strong>整型</strong></p><p><strong>数字</strong></p><p>• i<strong>nt8<strong><strong>、</strong></strong>int16<strong><strong>、</strong></strong>int32<strong><strong>和</strong></strong>int64</strong>四种截然不同大小的有符号整形数类型</p><p>• <strong>uint8<strong><strong>、</strong></strong>uint16<strong><strong>、</strong></strong>uint32<strong><strong>和</strong></strong>uint64</strong>四种无符号整形数类型</p><p>• 一般对应特定CPU平台机器字大小的<strong>有符号和无符号整数<strong><strong>int</strong></strong>和****uint</strong>；32或64位</p><p>￮ <strong>Unicode<strong><strong>字符</strong></strong>rune<strong><strong>类型是和</strong></strong>int32****等价的类型</strong>，通常用于表示一个Unicode码点。这两个名称可以互换使用。</p><p>￮ <strong>byte<strong><strong>也是</strong></strong>uint8****类型的等价类型</strong>，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。</p><p>• <strong>无符号的整数类型<strong><strong>uintptr</strong></strong>，没有指定具体的<strong><strong>bit</strong></strong>大小但是足以容纳指针。</strong>uintptr类型只有在底层编程是才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。</p><p>• int、uint和uintptr是不同类型的兄弟类型。其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然</p><p>• <strong>有符号整数采用<strong><strong>2</strong></strong>的补码形式表示</strong>，也就是最高bit位用作表示符号位，一个n-bit的有符号数的值域是从-2^{n-1}−2<em>n</em>−1到2^{n-1}-12<em>n</em>−1−1。<strong>无符号整数的所有<strong><strong>bit</strong></strong>位都用于表示非负数</strong>，值域是0到2^n-12<em>n</em>−1。</p><p>￮ 例如，int8类型整数的值域是从-128到127，而uint8类型整数的值域是从0到255</p><p><strong>运算符</strong></p><p>Go语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照先级递减的顺序的排列：</p><p>\1. *   /   %   &lt;&lt;    &gt;&gt;   &amp;    &amp;^</p><p>\2. +   -   |   ^</p><p>\3. ==   !=   &lt;   &lt;=    &gt;   &gt;=</p><p>\4. &amp;&amp;</p><p>\5. ||</p><p>• 二元运算符有<strong>五种优先级。在同一个优先级，使用左优先结合规则，</strong>但是使用括号可以明确优先顺序，使用括号也可以用于提升优先级。</p><p>• 算术运算符+、-、<em>和/可以适用与于整数、浮点数和复数，但是<strong>取模运算符</strong></em>*%**<strong>仅用于整数间的运算。</strong></p><p>￮ 对于不同编程语言，%取模运算的行为可能并不相同。<strong>在<strong><strong>Go</strong></strong>语言中，**</strong>%**<strong>取模运算符的符号和被取模数的符号总是一致的</strong>，因此-5%3和-5%-3结果都是-2。</p><p>￮ 除法运算符/的行为则依赖于操作数是否为全为整数，比如5.0/4.0的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。</p><p>• 位操作运算符^作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反；也就是说，它返回一个每个bit位都取反的数。位操作运算符&amp;^用于按位置零（AND NOT）：功能同a&amp;(^b)相同</p><p>￮ 如果右侧是0，则左侧数保持不变</p><p>￮ 如果右侧是1，则左侧数一定清零</p><p>• 在x&lt;&lt;n和x&gt;&gt;n移位运算中，决定了移位操作bit数部分必须是无符号数；被操作的x数可以是有符号或无符号数。算术上，一个x&lt;&lt;n左移运算等价于乘以2^n，一个x&gt;&gt;n右移运算等价于除以2^n。</p><p>￮ 左移运算用零填充右边空缺的bit位，无符号数的右移运算也是用0填充左边空缺的bit位，但是有符号数的右移运算会用符号位的值填充左边空缺的bit位。因为这个原因，最好用无符号运算，这样你可以将整数完全当作一个bit位模式处理。</p><p>• 尽管Go语言提供了无符号数和运算，即使数值本身不可能出现负数我们还是倾向于使用有符号的int类型。</p><p>￮ 无符号数往往只有在位运算或其它特殊的运算场景才会使用，就像bit集合、分析二进制文件格式或者是哈希和加密操作等。它们通常并不用于仅仅是表达非负数量的场合。</p><p>• 对于每种类型T，如果转换允许的话，*<em>类型转换操作</em><em>*<em>T(x)<strong><strong>将</strong></strong>x</em>*</em><em>转换为</em><em><strong>T</strong></em>*类型**。许多整形数之间的相互转换并不会改变数值；它们只是告诉编译器如何解释这个值。但是对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度。</p><p><strong>fmt****的两个使用技巧</strong></p><p>￮ 通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，</p><p>￮ 但是%之后的[1]副词告诉Printf函数再次使用第一个操作数。</p><p>￮ 第二，%后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。</p><p>a. o := 0666</p><p>b. fmt.Printf(“%d %[1]o %#[1]o\n”, o) // “438 666 0666”</p><p>c. x := int64(0xdeadbeef)</p><p>d. fmt.Printf(“%d %[1]x %#[1]x %#[1]X\n”, x)</p><p>e. // Output:</p><p>f. // 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF</p><p><strong>字符面值</strong></p><p>• 通过一对单引号直接包含对应字符。字符使用%c参数打印，或者是用%q参数打印带单引号的字符</p><p><strong>浮点数</strong></p><p>Go语言提供了两种精度的浮点数，float32和float64。</p><p>• 这些浮点数类型的取值范围可以从很微小到很巨大。</p><p>￮ 浮点数的范围极限值可以在math包找到。常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；对应的math.MaxFloat64常量大约是1.8e308。</p><p>￮ 它们分别能表示的最小值近似为1.4e-45和4.9e-324。</p><p>• 通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）</p><p>• math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1).</p><p>\1. var z float64</p><p>\2. fmt.Println(z, -z, 1/z, -1/z, z/z) // “0 -0 +Inf -Inf NaN”</p><p>• 函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的</p><p><strong>复数</strong></p><p><strong>布尔型</strong></p><p>• 布尔值可以和&amp;&amp;（AND）和||（OR）操作符结合，并且可能会有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不在被求值。</p><p>• &amp;&amp;的优先级比||高</p><p>• 布尔值并不会隐式转换为数字值0或1，反之亦然</p><p>￮ 可以包装 btoi 和 itob 的函数</p><p><strong>字符串</strong></p><p>• 一个字符串是一个不可改变的字节序列。</p><p>￮ 字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，我们可以将一个字符串追加到另一个字符串，给一个字符串变量分配一个新字符串值。</p><p>￮ 因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的。</p><p>￮ 不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。</p><p>￮ 字符串切片操作代价也是低廉的。</p><p>• <strong>内置的<strong><strong>len</strong></strong>函数可以返回一个字符串中的字节数目（不是<strong><strong>rune</strong></strong>字符数目：<strong><strong>unicode</strong></strong>字符）</strong>，索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i&lt; len(s)条件约束。</p><p>• <strong>第<strong><strong>i</strong></strong>个字节并不一定是字符串的第<strong><strong>i</strong></strong>个字符</strong>，因为对于非ASCII字符的UTF8编码会要两个或多个字节。比如 “hello,世界”得到的字节数是12，而rune长度是8，因为世界两个字各占3个字节，但是是一个rune字符。</p><p>• 子字符串操作*<em>s[i:j]<strong><strong>，基于原始的</strong></strong>s</em><em><strong>字符串的第</strong></em><em>i</em><em><strong>个字节开始到第</strong></em><em>j</em><em><strong>个字节（并不包含</strong></em><em>j</em>*<strong>本身）生成一个新字符串</strong>。生成的新字符串将包含j-i个字节。</p><p>￮ 不管i还是j都可能被忽略，当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置。</p><p><strong>字符串面值</strong></p><p><strong>原生字符串面值</strong></p><p>一个原生的字符串面值形式是…，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行（译注：在原生字符串面值内部是无法直接写字符的，可以用八进制或十六进制转义或+”```”链接字符串常量完成）。【原生的则不用转转义】</p><p>原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。</p><p>□ <strong>Unicode</strong></p><p>（ <a href="http://unicode.org/">http://unicode.org</a> ），它收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符，还有很多神秘的符号，每个符号都分配一个唯一的Unicode码点，Unicode码点对应Go语言中的rune【<strong>神秘的或有魔力的符号；</strong>】整数类型。【unicode是一种编码表示的方式】</p><p><strong>UTF8</strong></p><p>• 是一个将Unicode码点编码为<strong>字节序列的变长编码</strong>。是unicode中不同字符的编码存储方式。</p><p>• 对于UTF8编码后文本的处理和原始的字节处理逻辑是一样的。但是对应很多其它编码则并不是这样的。</p><p>Go语言的源文件采用UTF8编码，并且Go语言处理UTF8编码的文本也很出色。<strong>unicode****包</strong>提供了诸多处理rune字符相关功能的函数（比如区分字母和数组，或者是字母的大写和小写转换等），<strong>unicode/utf8****包</strong>则提供了用于rune字符序列的UTF8编码和解码的功能。</p><p><strong>字符串和<strong><strong>Byte</strong></strong>切片</strong></p><p>标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。</p><p>• strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。</p><p>• bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效，稍后我们将展示。</p><p>• strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</p><p>• unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串</p><p>• path和path/filepath包提供了关于文件路径名更一般的函数操作。</p><p>一个字符串是包含的只读字节数组，一旦创建，是不可变的。相比之下，一个字节slice的元素则可以自由地修改。</p><p>字符串和字节slice之间可以相互转换：</p><p>\1. s := “abc”</p><p>\2. b := []byte(s)</p><p>\3. s2 := string(b)</p><p>• 一个[]byte(s)转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量b被修改的情况下，原始的s字符串也不会改变。将一个字节slice转到字符串的string(b)操作则是构造一个字符串拷贝，以确保s2字符串是只读的。</p><p><strong>字符串和数字的转换</strong></p><p>• 将一个整数转为字符串，</p><p>￮ 一种方法是用fmt.Sprintf返回一个格式化的字符串；</p><p>￮ 另一个方法是用strconv.Itoa(“整数到ASCII”)：</p><p>strconv的FormatInt和FormatUint函数可以用不同的进制来格式化数字。fmt.Printf函数的%b、%d、%o和%x等参数提供功能往往比strconv包的Format函数方便很多，特别是在需要包含附加额外信息的时候</p><p>\1. fmt.Println(strconv.FormatInt(int64(x), 2)) // “1111011”</p><p>• 将一个字符串解析为整数，</p><p>￮ 可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数</p><p>有时候也会使用<strong>fmt.Scanf****来解析输入的字符串和数字，特别是当字符串和数字混合在一行的时候，它可以灵活处理不完整或不规则的输入</strong>。</p><p><strong>常量</strong></p><p>• 常量表达式的值在编译期计算，而不是在运行期。</p><p>￮ 这样可以减少运行时的工作，也方便其他编译优化。</p><p>￮ 当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。</p><p>• 每种常量的潜在类型都是基础类型：boolean、string或数字。</p><p>• 常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：len、cap、real、imag、complex和unsafe.Sizeof</p><p>• 如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。</p><p>\1. const (</p><p>\2.   a = 1</p><p>\3.   b</p><p>\4.   c = 2</p><p>\5.   d</p><p>\6. )</p><p>\7. fmt.Println(a, b, c, d) // “1 1 2 2”</p><p> <strong>iota</strong> <strong>常量生成器</strong></p><p>常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。</p><p>\1. const (</p><p>\2.   _ = 1 &lt;&lt; (10 * iota)</p><p>\3.   KiB // 1024</p><p>\4.   MiB // 1048576</p><p>\5.   GiB // 1073741824</p><p>\6.   TiB // 1099511627776       (exceeds 1 &lt;&lt; 32)</p><p>\7.   PiB // 1125899906842624</p><p>\8.   EiB // 1152921504606846976</p><p>\9.   ZiB // 1180591620717411303424  (exceeds 1 &lt;&lt; 64)</p><p>\10.   YiB // 1208925819614629174706176</p><p>\11. )</p><p><strong>无类型常量</strong></p><p>• 这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p><p>• 通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。</p><p>• 只有常量可以是无类型的。使用时会被隐式转换为对应的类型，如果转换合法的话。</p><p>• 注意默认类型是规则的：无类型的整数常量默认转换为int，对应不确定的内存大小，但是浮点数和复数常量则默认转换为float64和complex128。</p><p>\4. <strong>复合数据类型</strong></p><p>• 数组和结构体是聚合类型；它们的值由许多元素或成员字段的值组成。</p><p>￮ 数组是由同构的元素组成——每个数组元素都是完全相同的类型</p><p>￮ 结构体则是由异构的元素组成的。</p><p>￮ 数组和结构体都是有固定内存大小的数据结构。</p><p>￮ 相比之下，slice和map则是动态的数据结构，它们将根据需要动态增长。</p><p><strong>简单的数组</strong></p><p>• 在数组字面值中，如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算。</p><p>• <strong>数组的长度是数组类型的一个组成部分，因此</strong><strong>[3]int**<strong>和</strong></strong>[4]int**<strong>是两种不同的数组类型。</strong>数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</p><p>• Go 中数组的传递并不是直接根据数组名传指针，只有显示传递指针时才是。</p><p>￮ 虽然通过指针来传递数组参数是高效的，而且也允许在函数内部修改数组的值，但是数组依然是僵化的类型，因为数组的类型包含了僵化的长度信息。上面的zero函数并不能接收指向[16]byte类型数组的指针，而且也没有任何添加或删除数组元素的方法。</p><p>￮ 除了像SHA256这类需要处理特定大小数组的特例外，数组依然很少用作函数参数；相反，我们一般使用slice来替代数组。</p><p><strong>切片（<strong><strong>slice</strong></strong>）</strong></p><p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。</p><p>• 数组和slice之间有着紧密的联系。</p><p>￮ 一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。</p><p>￮ 一个slice由三个部分构成：指针、长度和容量。</p><p>▪ 指针指向第一个slice元素对应的底层数组元素的地址，要注意的是<strong>slice****的第一个元素并不一定就是数组的第一个元素</strong>。</p><p>• 因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名。</p><p>▪ 长度对应slice中元素的数目；长度不能超过容量，<strong>容量一般是从<strong><strong>slice</strong></strong>的开始位置到底层数据的结尾位置</strong>。</p><p>▪ 内置的len和cap函数分别返回slice的长度和容量。</p><p>▪ 多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。</p><p>￮ slice的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定，或者的两种风格的混合语法初始化。</p><p>• 和数组不同的是，<strong>slice****之间不能比较</strong>，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较。</p><p>￮ 第一个原因，一个slice的元素是间接引用的，一个slice甚至可以包含自身。</p><p>￮ 第二个原因，因为slice的元素是间接引用的，一个固定值的slice在不同的时间可能包含不同的元素，因为底层数组的元素可能会被修改。</p><p>￮ slice和数组不同的相等测试行为会让人困惑。因此，安全的做法是直接禁止slice之间的比较操作。</p><p>• slice唯一合法的比较操作是和nil比较，例如：</p><p>\1. if summer == nil { /* … */ }</p><p>• 一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，例如[]int{}或make([]int, 3)[3:]</p><p>￮ 如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断。</p><p>￮ 除了和nil相等比较外，一个nil值的slice的行为和其它任意0长度的slice一样</p><p>\1. var s []int  // len(s) == 0, s == nil</p><p>\2. s = nil    // len(s) == 0, s == nil</p><p>\3. s = []int(nil) // len(s) == 0, s == nil</p><p>\4. s = []int{}  // len(s) == 0, s != nil</p><p><strong>make****函数</strong></p><p>创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。</p><p>\1. make([]T, len)</p><p>\2. make([]T, len, cap) // same as make([]T, cap)[:len]</p><p>在底层，make创建了一个匿名的数组变量，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。在第一种语句中，slice是整个数组的view。在第二个语句中，slice只引用了底层数组的前len个元素，但是容量将包含整个的数组。额外的元素是留给未来的增长用的。</p><p><strong>append****函数</strong></p><p>内置的append函数用于向slice追加元素。</p><p>• 要正确地使用slice，需要记住尽管底层数组的元素是间接访问的，但是slice对应结构体本身的指针、长度和容量部分是直接访问的。要更新这些信息需要像上面例子那样一个显式的赋值操作。从这个角度看，slice并不是一个纯粹的引用类型，它实际上是一个类似下面结构体的聚合类型：</p><p>\1. type IntSlice struct {</p><p>\2.   ptr   *int</p><p>\3.   len, cap int</p><p>\4. }</p><p>内置的append函数则可以追加多个元素，甚至追加一个slice。</p><p>\1. var x []int</p><p>\2. x = append(x, 1)</p><p>\3. x = append(x, 2, 3)</p><p>\4. x = append(x, 4, 5, 6)</p><p>\5. x = append(x, x…) // append the slice x</p><p>\6. fmt.Println(x)   // “[1 2 3 4 5 6 1 2 3 4 5 6]”</p><p><strong>字典（<strong><strong>map</strong></strong>）</strong></p><p>一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。</p><p>• 创建map：在向map存数据前必须先创建map</p><p>￮ 内置的make函数可以创建一个map: ages := make(map[string]int)</p><p>￮ 另一种创建空的map的表达式是map[string]int{}</p><p>• 使用内置的delete函数可以删除元素：delete(ages, “alice”) </p><p>\1. if age, ok := ages[“bob”]; !ok { /* … */ }</p><p>在这种场景下，map的下标语法将产生两个值；第二个是一个布尔值，用于报告元素是否真的存在。布尔变量一般命名为ok，特别适合马上用于if条件判断部分。</p><p>• 和slice一样，map之间也不能进行相等比较；唯一的例外是和nil进行比较。要判断两个map是否包含相同的key和value，我们必须通过一个循环实现。</p><p>• Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能。为</p><p><strong>结构体</strong></p><p>• 结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。</p><p>• 结构体成员的输入顺序也有重要的意义。</p><p>• 如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。</p><p>• 一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适应于数组。）但是S类型的结构体可以包含*S指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。</p><p>• 结构体类型的零值是每个成员都对是零值。通常会将零值作为最合理的默认值。例如，对于bytes.Buffer类型，结构体初始值就是一个随时可用的空缓存，还有在第9章将会讲到的sync.Mutex的零值也是有效的未锁定状态。</p><p><strong>结构体面值</strong></p><p>\1. type Point struct{ X, Y int }</p><p>\2.  </p><p>\3. p := Point{1, 2}</p><p>\1. 要求以结构体成员定义的顺序为每个结构体成员指定一个面值。它要求写代码和读代码的人要记住结构体的每个成员的类型和顺序，不过结构体成员有细微的调整就可能导致上述代码不能编译。</p><p>\1. anim := gif.GIF{LoopCount: nframes}</p><p>\2. 第二种写法，以成员名字和相应的值来初始化，可以包含部分或全部的成员.在这种形式的结构体面值写法中，如果成员被忽略的话将默认用零值。因为，提供了成员的名字，所有成员出现的顺序并不重要。</p><p>两种不同形式的写法不能混合使用。而且，你不能企图在外部包中用第一种顺序赋值的技巧来偷偷地初始化结构体中未导出的成员.</p><p>• 结构体可以作为函数的参数和返回值。</p><p>￮ 如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回</p><p><strong>结构体比较</strong></p><p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用==或!=运算符进行比较。相等比较运算符==将比较两个结构体的每个成员。<strong>可比较的结构体类型和其他可比较的类型一样，可以用于<strong><strong>map</strong></strong>的<strong><strong>key</strong></strong>类型。</strong></p><p><strong>结构体嵌入和匿名成员</strong></p><p>• Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。<strong>匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针</strong>。</p><p>￮ 得意于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径</p><p>￮ 不幸的是，结构体字面值并没有简短表示匿名成员的语法</p><p>￮ 不能同时包含两个类型相同的匿名成员，这会导致名字冲突</p><p><strong>JSON</strong></p><p>JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。XML（§7.14）、ASN.1和Google的Protocol Buffers都是类似的协议，并且有各自的特色。</p><p>• 将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）</p><p>￮ 在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术，我们将在12.6节讨论）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。</p><p>• 编码的逆操作是解码，对应将JSON数据解码为Go语言的数据结构，Go语言中一般叫unmarshaling，通过json.Unmarshal函数完成。</p><p>\1. data, err := json.Marshal(movies)</p><p>\2. data, err := json.MarshalIndent(movies, “”, “  “)</p><p>\3. err := json.Unmarshal(data, &amp;titles)</p><p>\4. </p><p>□ <strong>xml</strong>**</p><p>**</p><p>\5. <strong>函数</strong></p><p><strong>函数声明</strong></p><p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。</p><p>\1. func name(parameter-list) (result-list) {</p><p>\2.   body</p><p>\3. }</p><p>函数的类型被称为函数的标识符。形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。</p><p>你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符。</p><p>□ <strong>递归</strong></p><p>大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与相反,<strong>Go**<strong>语言使用可变栈，栈的大小按需增加</strong></strong>(<strong><strong>初始时很小</strong></strong>)<strong><strong>。这使得我们使用递归时不必考虑溢出和安全问题。</strong></strong>var stack []string stack = append(stack,s)**</p><p><strong>多返回值</strong></p><p>虽然Go的垃圾回收机制会回收不被使用的内存，但是这不包括操作系统层面的资源，比如打开的文件、网络连接。因此我们必须显式的释放这些资源。</p><p>如果一个函数中所有的返回值都有显示的变量名，那么该函数的return语句可以省略操作数。这称之为<strong>bare return</strong>。</p><p><strong>错误</strong></p><p>在Go的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分，程序运行失败仅被认为是几个预期的结果之一。</p><p>• 对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。</p><p>￮ 如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok。</p><p>￮ 通常，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。</p><p>▪ 内置的error是接口类型。</p><p>▪ error类型可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。对于non-nil的error类型,我们可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。</p><p>￮ 通常，当函数返回non-nil的error时，其他的返回值是未定义的(undefined),这些未定义的返回值应该被忽略。然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。</p><p>• 在Go中，<strong>函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（<strong><strong>exception</strong></strong>）</strong>，这使得Go有别于那些将函数运行失败看作是异常的语言。</p><p>￮ 虽然Go有各种异常机制，但这些机制仅被使用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误。</p><p><strong>错误处理策略</strong></p><p>fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回。我们使用该函数前缀添加额外的上下文信息到原始错误信息。当错误最终由main函数处理时，错误信息应提供清晰的从原因到后果的因果链。</p><p>fmt.Fprintf函数，用 os.Exit(1) 退出</p><p>调用log.Fatalf可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。</p><p>• 当一次函数调用返回错误时，调用者有应该选择何时的方式处理错误。根据情况的不同，有很多处理方式：</p><p>￮ 传播错误。这意味着函数中某个子程序的失败，会变成该函数的失败。</p><p>￮ 如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。</p><p>￮ 如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。</p><p>￮ 有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。我们可以通过log包提供函数：log.Printf</p><p>▪ 或者标准错误流输出错误信息：fmt.Fprintf(os.Stderr,..)</p><p>▪ log包中的所有函数会为没有换行符的字符串增加换行符。</p><p>￮ 我们可以直接忽略掉错误。</p><p>在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。</p><p><strong>文件结尾错误（<strong><strong>EOF</strong></strong>）</strong></p><p>因为文件结束这种错误不需要更多的描述，所以io.EOF有固定的错误信息——“EOF”。对于其他错误，我们可能需要在错误信息中描述错误的类型和数量，这使得我们不能像io.EOF一样采用固定的错误信息。</p><p><strong>函数值</strong></p><p>在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。</p><p>• 函数类型的零值是nil。调用值为nil的函数值会引起panic错误</p><p>• 函数值可以与nil比较</p><p>• 但是函数值之间是不可比较的，也不能用函数值作为map的key。</p><p>• 函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为。</p><p><strong>Go<strong><strong>使用闭包（</strong></strong>closures<strong><strong>）技术实现函数值，</strong></strong>Go****程序员也把函数值叫做闭包。</strong></p><p><strong>匿名函数</strong></p><p>拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，区别在于<strong>func<strong><strong>关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数（</strong></strong>anonymous function****）。</strong>函数字面量允许我们在使用函数时，再定义它。通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量</p><p><strong>警告：捕获迭代变量</strong></p><p><strong>可变参数</strong></p><p>参数数量可变的函数称为为可变参数函数。典型的例子就是fmt.Printf和类似函数。Printf首先接收一个的必备参数，之后接收任意个数的后续参数。</p><p>在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“…”，这表示该函数会接收任意数量的该类型参数：func sum(vals…int) int</p><p>虽然在可变参数函数内部，…int 型参数的行为看起来很像切片类型，但实际上，可变参数函数和以切片作为参数的函数是不同的。</p><p><strong>Deferred****函数</strong></p><p>你只需要在<strong>调用普通函数或方法前加上关键字<strong><strong>defer</strong></strong>，就完成了<strong><strong>defer</strong></strong>所需要的语法</strong>。</p><p>• 当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。</p><p>• <strong>你可以在一个函数中执行多条<strong><strong>defer</strong></strong>语句，它们的执行顺序与声明顺序相反</strong>。</p><p>• defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。</p><p>• 调试复杂程序时，<strong>defer****机制也常被用于记录何时进入和退出函数</strong>。</p><p>• defer语句中的函数会在return语句更新返回值变量后再执行，又因为在函数中定义的匿名函数可以访问该函数包括返回值变量在内的所有变量，所以，对匿名函数采用defer机制，可以使其观察函数的返回值。</p><p><strong>Panic****异常</strong></p><p>Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。</p><p>一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine（可以先理解成线程，在第8章会详细介绍）中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。panic value通常是某种错误信息。对于每个goroutine，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。</p><p>不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用panic。</p><p>错误处理和异常？？到底啥区别</p><p>□ <strong>Recover****捕获异常</strong></p><p><strong>方法</strong></p><p>OOP编程的两个关键点，封装和组合。</p><p><strong>方法声明</strong></p><p>• 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。</p><p>• 能够给任意类型定义方法这一点上，Go和很多其它的面向对象的语言不太一样。因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。方法可以被声明到任意类型，只要不是一个指针或者一个interface。</p><p>• 对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名</p><p><strong>基于指针对象的方法</strong></p><p>在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。</p><p>在每一个合法的方法调用表达式中，也就是下面三种情况里的任意一种情况都是可以的：</p><p>• 不论是接收器的实际参数和其接收器的形式参数相同，比如两者都是类型T或者都是类型*T</p><p>• 接收器形参是类型T，但接收器实参是类型*T，这种情况下编译器会隐式地为我们取变量的地址</p><p>• 接收器形参是类型*T，实参是类型T。编译器会隐式地为我们解引用，取到指针指向的实际变量</p><p>作者这里说的比较绕，其实有两点：</p><p>\1. 不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。</p><p>\2. 在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的内部，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C艹的人这里应该很快能明白。</p><p><strong>Nil****也是一个合法的接收器类型</strong></p><p><strong>封装</strong></p><p>一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，同时也是面向对象编程最关键的一个方面。</p><p>Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。</p><p>• 如果我们想要封装一个对象，我们必须将其定义为一个struct。</p><p>￮ 这种基于名字的手段使得在语言中最小的封装单元是package，而不是像其它语言一样的类型。一个struct类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。</p><p>• 封装提供了三方面的优点。</p><p>￮ 首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可。</p><p>￮ 第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。</p><p>￮ 封装的第三个优点也是最重要的优点，是阻止了外部调用方对对象内部的值任意地进行修改。</p><p><strong>接口</strong></p><p><a href="https://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">How to use interfaces in Go</a></p><p>接口指：1）方法的集合，2）类型</p><p>\1. 集合指interface定义一系列的函数（行为），在具体的类型中实现。比如animal接口，里面有speak（）函数，那么在方法内用不同的类型实现，比如定义结构体Dog（其实是一种类/对象），然后定义Dog 的（函数前面的接收器）Speak（）实现。</p><p>\2. interface{}类型，表明没有任何方法。所有的烈性都能满足一个空的接口。接口值在是实现中占 2 个字，一个word 指向方法表，表明值的底层类型。另一个指向值实际的数据。</p><p>指针接收器 or 值接收器</p><p><strong>接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会展示出它们自己的方法。</strong>也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。</p><p><strong>接口类型</strong></p><p>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。</p><p><strong>实现接口的条件</strong></p><p>• 一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。</p><p>• interface{}被称为空接口类型是不可或缺的。因为空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。</p><p>\8. <strong>Goroutines<strong><strong>和</strong></strong>Channels</strong></p><p>当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。</p><p>在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。</p><p>• goroutine中断</p><p>￮ 主函数返回时，所有的goroutine都会被直接打断，程序退出。除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行，。</p><p>￮ 一种方式来实现这个目的，通过goroutine之间的通信来让一个goroutine请求其它的goroutine，并被请求的goroutine自行结束执行。</p><p><strong>示例</strong><strong>:</strong> <strong>并发的<strong><strong>Clock</strong></strong>服务</strong></p><p><strong>Channels</strong></p><p>如果说goroutine是Go语音程序的并发体的话，那么<strong>channels****它们之间的通信机制</strong>。</p><p>• 一个channels是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。</p><p>• 每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为chan int。</p><p>• 使用内置的make函数，我们可以创建一个channel.</p><p>￮ 使用 make(chan val-type) 创建一个新的通道。通道类型就是他们需要传递值的类型。</p><p>• 一个channel有发送和接受两个主要操作，都是通信行为。</p><p>￮ 一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。</p><p>￮ 发送和接收两个操作都是用&lt;-运算符。</p><p>▪ 在发送语句中，&lt;-运算符分割channel和要发送的值。在接收语句中，&lt;-运算符写在channel对象之前。</p><p>￮ 一个不使用接收结果的接收操作也是合法的。</p><p>\1. ch &lt;- x // a send statement</p><p>\2. x = &lt;-ch // a receive expression in an assignment statement</p><p>\3. &lt;-ch   // a receive statement; result is discarded</p><p>使用内置的close函数就可以关闭一个channel：</p><p>\1. close(ch)</p><p>以最简单方式调用make函数创建的时一个无缓冲的channel，但是我们也可以指定第二个整形参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓冲的channel。</p><p>\1. ch = make(chan int)  // unbuffered channel</p><p>\2. ch = make(chan int, 0) // unbuffered channel</p><p>\3. ch = make(chan int, 3) // buffered channel with capacity 3</p><p><strong>不带缓存的****Channels</strong></p><p>• 一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。</p><p>• 反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。</p><p>基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为<strong>同步****Channels</strong>。当通过一个无缓存Channels发送数据时，接收者收到数据发生在唤醒发送者goroutine之前（译注：***happens before***，这是Go语言并发内存模型的一个关键术语！）。</p><p>• 并发编程时，当我们说x事件在y事件之前发生（<em>happens before</em>），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是<strong>要保证在此之前的事件都已经完成了，</strong>例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。</p><p>• 当我们说x事件既不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并发的。这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序。</p><p>并发程序指同时进行多个任务的程序。</p><p>• Go语言中的并发程序可以用两种手段来实现。</p><p>￮ 本章讲解goroutine和channel，其支持“顺序通信进程”(communicating sequential processes)或被简称为CSP。CSP是一种现代的并发编程模型，在这种编程模型中值会在不同的运行实例(goroutine)中传递。</p><p>￮ 第9章覆盖更为传统的并发模型：多线程共享内存</p><p>\6. <strong>函数</strong></p><p>￮ 错误处理、</p><p>￮ panic</p><p>￮ Recover</p><p>￮ defer语句</p><p>其余章节是Go语言特有的语言特性。方法、接口、并发、包、测试和反射等语言特性。</p><p>Go语言的面向对象机制与一般语言不同。它没有类层次结构，甚至可以说没有类；仅仅通过组合（而不是继承）简单的对象来构建复杂的对象。方法不仅可以定义在结构体上, 而且可以定义在任何用户自定义的类型上；并且具体类型和抽象类型（接口）之间的关系是隐式的，所以很多类型的设计者可能并不知道该类型到底实现了哪些接口。</p><p>\6. 方法</p><p>\7. 接口</p><p>\8. 基于顺序通信进程(CSP)概念的并发编程</p><p>a. 使用goroutines和channels处理并发编程</p><p>\9. 基于共享变量的并发编程</p><p>\10. 包机制和包的组织结构</p><p>a. 如何有效的利用Go自带的工具，使用单个命令完成编译、测试、基准测试、代码格式化、文档以及其他诸多任务。</p><p>\11. <strong>测试</strong></p><p>go test命令是一个按照一定的约定和组织的测试代码的驱动程序。在包目录内，所有以_test.go为后缀名的源文件并不是go build构建包的一部分，它们是go test测试的一部分。</p><p>go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p><p>• 在*_test.go文件中，有三种类型的函数</p><p>￮ 测试函数</p><p>▪ <strong>以<strong><strong>Test</strong></strong>为函数名前缀</strong>的函数，用于测试程序的一些逻辑行为是否正确；</p><p>▪ go test命令会调用这些测试函数并报告测试结果是PASS或FAIL。</p><p>￮ 基准测试函数</p><p>▪ <strong>以<strong><strong>Benchmark</strong></strong>为函数名前缀</strong>的函数，它们用于<strong>衡量一些函数的性能</strong>；</p><p>▪ go test命令会多次运行基准函数以计算一个平均的执行时间。</p><p>￮ 示例函数</p><p>▪ <strong>以<strong><strong>Example</strong></strong>为函数名前缀</strong>的函数，提供一个由编译器保证正确性的示例文档。</p><p><strong>测试函数</strong></p><p>• 测试函数的名字必须以Test开头，<strong>可选的后缀名必须以大写字母开头</strong></p><p>• 其中t参数用于报告测试失败和附加的日志信息</p><p>\1. import “testing”</p><p>\2. func TestName(t *testing.T) {</p><p>\3.   // …</p><p>\4. }</p><p>• go test命令如果没有参数指定包那么将默认采用当前目录对应的包（和go build命令一样）；</p><p>• 如果测试都通过，程序是不会退出的，但是如果有fail的，有了BUG报告，则会退出；</p><p>• 后面加参数-v可用于打印每个测试函数的名字和运行时间；</p><p>• 参数-run对应一个正则表达式，只有测试函数名被它正确匹配的测试函数才会被go test测试命令运行：</p><p><strong>基准测试</strong></p><p>**</p><p>**</p><p>a. Go语言的工具和标准库中集成了轻量级的测试功能，避免了强大但复杂的测试框架。</p><p>b. 测试库提供了一些基本构件，必要时可以用来构建复杂的测试构件</p><p>\12. 反射：一种程序在运行期间审视自己的能力</p><p>\13. 底层编程的细节</p><p>a. 在必要时，可以使用unsafe包绕过Go语言安全的类型系统</p><p><a href="https://tour.golang.org/"><strong>基于</strong> <strong>Playground</strong> <strong>构建的</strong> <strong>Go Tour</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bazel-backup</title>
      <link href="/2022/06/19/bazel-backup/"/>
      <url>/2022/06/19/bazel-backup/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>rpc</title>
      <link href="/2022/06/03/rpc/"/>
      <url>/2022/06/03/rpc/</url>
      
        <content type="html"><![CDATA[<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><ol><li>在.proto（protocol buffer）的文件中，描述数据交换的格式<br>a. developers.google.com/…</li><li>使用protoc编译.proto文件，生成对应偏好语言的代码文件（比如：这个例子中，调用protoc将会创建c++的代码），代码文件实际上是一组在.proto描述好的函数接口，包括函数名和返回值/返回自定义的数据结构（c++里的类）<br>a. 用protoc产生hello_world.pb.h/.cc, 将我们定义的协议转换成C++中的类。有可能你的环境中还没有安装，不过不要紧，在你执行了位于trpc-cpp项目(<a href="https://git.code.oa.com/trpc-cpp/trpc-cpp)%E4%B8%AD%E7%9A%84./build.sh">https://git.code.oa.com/trpc-cpp/trpc-cpp)中的./build.sh</a>, 对整个项目进行构建后，会生成protoc.<br>b. 不过在用户侧，我们并不会直接操作protoc, 而是借助trpc-cpp中trpc_proto_library, 帮助我们生成对应的文件。<br>c. 待生成的文件有两组:hello_world.pb.h/.cc，hello_world.trpc.pb.h/.cc。其中hello_world.proto中的message等在hello_world.pb.h/.cc中生成，service相关的交互接口在hello_world.trpc.pb.h/.cc中生成。</li><li>服务端实现了生成的代码文件的接口</li><li>客户端将调用为客户端生成的接口，就像调用本地一个函数一样</li><li>tRPC负责处理客户端和服务端之间的数据交换<br>参考：iwiki.woa.com/…</li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>bazel_usage</title>
      <link href="/2022/06/03/bazel-usage/"/>
      <url>/2022/06/03/bazel-usage/</url>
      
        <content type="html"><![CDATA[<p>官网入口：<del><a href="https://docs.bazel.build/versions/main/bazel-overview.html">https://docs.bazel.build/versions/main/bazel-overview.html</a></del> <a href="https://bazel.build/start">https://bazel.build/start</a></p><h1 id="初识-Bazel"><a href="#初识-Bazel" class="headerlink" title="初识 Bazel"></a>初识 Bazel</h1><h2 id="Bazel-是什么"><a href="#Bazel-是什么" class="headerlink" title="Bazel 是什么"></a>Bazel 是什么</h2><p>开源的<strong>编译和测试</strong>的工具（类似Make，Maven，Gradle）。</p><ul><li><p><strong>High-level build language</strong></p><ul><li>使用易读，抽象的编译语言，以高层次的语义描述项目构建属性。</li><li>在 libraries，binaries，scripts，date sets 的概念上运行，用户无需单独写规则调用编译器/链接器。</li></ul></li><li><p><strong>Bazel is fast and reliable</strong></p><ul><li>Bazel 缓存之前编译的结果，追踪修改的文件内容和构建命令，从而知道哪些内容需要重新构建，并只构建修改的内容和命令。想要加速构建，<strong>可设置高并行和增量的方式</strong>。</li></ul></li><li><p><strong>Bazel is multi-platform</strong></p><ul><li>可在多种平台（macos，windows，linux）运行。</li><li>支持为同个项目在多种平台（桌面，服务端，移动端）构建二进制文件和可部署的包。</li></ul></li><li><p><strong>Bazel scales.</strong></p><ul><li>支持多达100k+源文件的编译，支持多个代码库，可供多人（万+）使用。</li></ul></li><li><p><strong>Bazel is extensible</strong></p><ul><li>支持<a href="https://bazel.build/rules">多种语言</a>（C++，Go，Java等），且可以做延伸去支持其他语言或框架。</li></ul></li></ul><h2 id="如何用-Bazel"><a href="#如何用-Bazel" class="headerlink" title="如何用 Bazel"></a>如何用 Bazel</h2><ul><li><p>下载 Bazel</p><ul><li>推荐用 Bazelisk 在 Ubuntu，Windows，MacOs 安装 Bazel，官方团队维护。<ul><li>MacOs：brew install bazelisk。</li><li><a href="https://github.com/bazelbuild/bazelisk">bazelisk</a> 是用go写的bazel的wrapper，会自动选择当前工作目录适合的 Bazel 版本，从官方服务器下载，将所有的命令行参数透传给真正的Bazel二进制文件。所以可以像调用 bazel 一样调用 bazelisk。</li></ul></li></ul></li><li><p>新建项目的 <a href="https://bazel.build/concepts/build-ref#workspaces">WORKSPACE</a> </p><ul><li>工作目录，Bazel 寻找构建的输入和 BUILD 文件，并存储构建输出。</li></ul></li><li><p>写 BUILD 文件</p><ul><li>定义了需要构建以及如何构建的内容，可以使用<a href="https://bazel.build/rules/language">Starlark</a> 声明构建 target，<a href="https://github.com/bazelbuild/bazel/blob/master/examples/cpp/BUILD">example</a>。</li><li>构建 target 声明了构建需要的输入和依赖，构建它们需要的 rule，以及配置 rule 的 options。</li><li>构建 rule 声明了 Bazel 用来构建的工具，如编译器，链接器以及其配置，bazel 配备了多种构建 rule，可覆盖所支持平台上，所支持语言的大部分类型。</li></ul></li><li><p>通过<a href="https://bazel.build/reference/command-line-reference">命令行</a>运行 Bazel </p><ul><li>build 命令 <a href="https://docs.bazel.build/versions/main/guide.html#specifying-targets-to-build">https://docs.bazel.build/versions/main/guide.html#specifying-targets-to-build</a></li></ul></li></ul><p> <strong>除了编译，Bazel还可以执行<a href="https://bazel.build/reference/test-encyclopedia">测试</a>，并<a href="https://bazel.build/docs/query-how-to">查询</a> 构建链路，追踪代码中的依赖。</strong></p><h2 id="Bazel-构建流程"><a href="#Bazel-构建流程" class="headerlink" title="Bazel 构建流程"></a>Bazel 构建流程</h2><p>当执行构建/测试，Bazel 如下执行：</p><ul><li><strong>加载</strong>与目标相关的 BUILD 文件。</li><li><strong>分析</strong>输入，以及输入的<a href="https://bazel.build/concepts/dependencies">依赖</a>，应用特定的构建规则，生成<a href="https://bazel.build/rules/concepts#evaluation-model">行为图</a> 。<ul><li>行为图表示构建artifacts，artifacts 之间的关系，以及 Bazel 要执行的构建行为。</li><li>根据行为图，Bazel 可以<a href="https://bazel.build/docs/build#build-consistency">追踪</a>文件内容以及构建/测试行为的改变，曾经的构建结果，也可以<a href="https://bazel.build/docs/query-how-to">追踪代码的依赖</a>。</li></ul></li><li>在输入上<strong>执行</strong>构建行为，直到输出最后的构建产物。</li></ul><p>Bazel 会将之前的构建工作缓存，只构建/测试修改了的内容。为了确保正确性，可以通过 sandBoxing <a href="https://bazel.build/concepts/hermeticity#overview">Hermetically</a> 构建和测试，minimizing skew and maximizing <a href="https://bazel.build/docs/build#correct-incremental-rebuilds">reproducibility</a> 。</p><h1 id="Bazel-基础"><a href="#Bazel-基础" class="headerlink" title="Bazel 基础"></a>Bazel 基础</h1><p>Bazel 构建 workspace 中以目录树组织的源文件。workspace 中的源文件由嵌套层级的 packages 组织，每个 packag 是一个目录，包含相关的源文件和一个BUILD 文件。BUILD 文件定义了可以从源文件编译出的输出。</p><h2 id="Workspaces-Packages-targets"><a href="#Workspaces-Packages-targets" class="headerlink" title="Workspaces,Packages, targets"></a><a href="https://bazel.build/concepts/build-ref">Workspaces,Packages, targets</a></h2><h3 id="Workspace"><a href="#Workspace" class="headerlink" title="Workspace"></a>Workspace</h3><ul><li>Bazel 的构建基于工作区(workspace) 概念。每个使用 bazel 的项目，在根目录下都必须有一个 WORKSPACE 文件，WORKSPACE 文件所在的目录就是项目的根目录。<ul><li>如果<strong>当前 WORKSPACE 文件</strong>所在的<strong>子目录中包含 WORKSPACE 文件</strong>，Bazel 构建时会忽略子目录，子目录成为另一个 workspace 。</li><li>WORKSPACE  文件的别名是 WORKSPACE.bazel，两者都存在时，使用 WORKSPACE.bazel。</li></ul></li><li>WROKSPACE 文件可以是空的，也可以包含对<a href="https://bazel.build/docs/external">外部的依赖</a>。</li></ul><h4 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h4><p>代码组织在 repositories 中。</p><ul><li><p>包含 WORKSPACE 文件的目录是 main repository <strong>的根，称作 “@”。</strong></p></li><li><p>其他（外部） repositories 由 WORKSPACE 文件中的 workspace rules 定义。</p><ul><li>外部 repositories 通常包含自己的 WORKSPACE 文件，而 Bazel 会忽略这些文件。</li><li>In particular, repositories depended upon transitively are not added automatically.</li></ul></li><li><p><a href="https://bazel.build/rules/lib/repo">Repository Rules</a></p></li></ul><h3 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h3><p>Repository 中主要的代码组织单元是 package。package 包含相关文件的集合，以及这些文件如何产出输出的说明。</p><ul><li><p>包含 BUILD/BUILD.bazel 文件的目录是一个 package。</p></li><li><p>一个 package 中包含这个目录/子目录下的所有文件，subpackage 除外，这样就没有文件/目录会成为两个不同 package 的成员 。</p><ul><li>包含 BUILD 文件的子目录称作 subpackage。</li></ul></li></ul><p><a href="https://bazel.build/reference/be/functions#package_group">package groups</a> 是 packages 的集合，其目的是限制特定 rules 的可访问性。</p><ul><li>package groups 由 <code>package_group </code> 函数定义，包含三个属性：<ol><li>此 group 中包含的 packages 列表；</li><li>packages 的名字；</li><li>其包含的其他 package groups。</li></ol></li><li>引用 package group 的方式是：<ol><li>通过 rules 的 <code>visibility</code> 属性；</li><li><code>package</code> 函数的 <code>default_visibility</code> 属性 。</li></ol></li><li><strong>不生成或者消费文件。</strong></li></ul><h3 id="Targets"><a href="#Targets" class="headerlink" title="Targets"></a>Targets</h3><p>Package 是 targets 的容器，targets 定义在 package 的 BUILD 文件中。大部分 targets 是 files 或者 rules。</p><ul><li><p>files 又可以分成两类：源文件（source files，包含在 repo 中），生成的文件（Generated files，由源文件通过特定的 rules 生成，不包含在 repo 中）。<del>targets 中定义了包括：files，rules 和 package groups。</del></p></li><li><p>Rule ：定义了一系列输入和输出之间的关系，包含了从输入得到输出的必要步骤。</p><ul><li>输入可以是 source file/generated file ，类型不重要，重要的是文件的内容。因此将复杂的源文件替换为 generated file 很方便，反之亦然。也可以避免一个文件修改导致所有编译链接关系的改变 。</li><li>一个的输入可能是另一个的输出，从而形成关系链，而输出只是 generated files。</li><li>一个 rule 的输入可能包含其他 rules：直觉上来说，比如 C++的 library rule A 以 library rule B 作为输入，那么编译期间，B 的头文件对 A 可用，链接期间，B 的符号对 A 可用，运行期间，B 的运行时数据对 A 可用。</li><li>rules 的不变性：一条 rule 生成的文件，只属于包含这条 rule 的 package。尽管一条 rule 的输入可能会来自其他 package，当前 rule 无法为其他 package 生成文件。</li></ul></li></ul><h2 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h2><p>所有的 targets 只会属于一个 package。target 的名字叫作 label。每个 label 唯一标识 target。 </p><ul><li>典型的 label：  <code>@myrepo//my/app/main:app_binary </code><ul><li><code>@myrepo//</code>：<strong>repository 名</strong>。</li><li>当 label 被所在的 repository 中使用，repo 的名字可以使用缩写 <code>//</code>。因此，在 <code>@myrepo</code> 中，label 常写为 <code>//my/app/main:app_binary</code> 。</li></ul></li><li><code>my/app/main</code>： 从 repository 的根到 package 的相对路径，是 un-qualified 的 <strong>package 名</strong>。<ul><li>repository 名 +  un-qualified package 名 组成 <strong>fully-qualified 的 package 名</strong>： <code>@myrepo//my/app/main </code></li><li> 当 label 被所在 package 中引用， package 名（以及冒号）可以被省略。上述 label 可以写为 ：</li><li><code>app_binary</code> </li><li><code>:app_binary</code></li><li>不成文规定。有冒号的用在 rule 中，<em>无冒号的用在 file 中</em>，但也无所谓啦。</li></ul></li><li><code>app_binary </code>： un-qualified target 名<ul><li>当和 target 名和 package 路径的最后一个目录一致时，可以省略，即 label 表示为：<ol><li><code>//my/app/lib</code></li><li> <code>//my/app/lib:lib</code></li></ol></li></ul></li><li>file target 的名字：对于 package 子目录中的 file target，其名称为相对于所在 package root（包含 BUILD 文件的目录） 的路径。<ul><li>file target 的名字为：<code>//my/app/main:testdata/input.txt</code> ，文件位于 repo 的子目录 <code>my/app/main/testdata</code>  下。</li></ul></li></ul><p>注意：</p><ul><li><p><code>//my/app</code> 不是 package 名。</p><ul><li>labels 总是以 repo 的标识（//）开头，但是 package 名不是。</li><li><code>my/app</code> 才是包含 <code>//my/app/lib</code> (a.k.a.<code> //my/app/lib:lib</code>）的 package。</li><li>错误说法：<code>//my/app</code> 指向一个 package ，或者是指向 package 中的所有 target。</li><li>正确说法：<code>//my/app</code>  等价于 <code>//my/app:app</code> ，即命名了在当前 repo 中，<code>my/app</code> package 下的 app target。</li></ul></li><li><p><strong>相对的 labels 不能用来指向其他 package 中的 targets，这种情况下必须指定 repo 和 package。</strong></p><ul><li>比如有 package <code>my/app</code> 和 package <code>my/app/testdata</code>，后者包含了文件<code> testdepot.zip</code>，那么在<code> //my/app:BUILD</code> 中引用 后者时：<ul><li>正确做法是：<code>//my/app/testdata:testdepot.zip</code> ；</li><li>而不是 <code>testdata/testdepot.zip</code>  # Wrong: testdata is a different package。</li><li>如果是同一个 package，应该可以用相对 label 吧？</li></ul></li></ul></li><li><p><em>以 <code>@//</code> 开头的 labels 是引用 main repo，从外部 repo 引用时也可以用这种形式。</em></p><ul><li><code>@//a/b/c</code>  和 <code>//a/b/c</code> 从外部 repo 引用时是不同的：<ul><li>前者引用 main repo；</li><li>后者由外部 repo 自己寻找 //a/b/c。</li></ul></li><li> 当在 main repo 中写 rule 引用 main repo 的 target，且将会被外部 repo 引用时，就有关系了。?</li></ul></li></ul><p>更多引用 target 的方法见<a href="https://bazel.build/docs/build#specifying-build-targets">详情</a>。</p><h3 id="label-的命名规范"><a href="#label-的命名规范" class="headerlink" title="label 的命名规范"></a>label 的命名规范</h3><h4 id="Target-names-—-package-name-target-name"><a href="#Target-names-—-package-name-target-name" class="headerlink" title="Target names —  package-name:target-name"></a>Target names —  package-name:target-name</h4><ul><li><code>target-name</code> 是 package 内 target 的名字。可包含大小写和数字，以及标点符号： <code>!%-@^_&quot;#$&amp;&#39;()*-+,;&lt;=&gt;?[]&#123;|&#125;~/.</code>。</li><li>rule 的名字是 <code>BUILD</code> 文件中 rule 声明时的 <code>name</code> 属性。</li><li> file 的名字是相对于 package 的路径，必须是正常的形式：</li><li>不可以以 <code>/</code> 开头或者结尾，错误示例：<code>/foo</code>，<code>foo/</code>。</li><li>不可用包含<code> //</code>，错误示例：<code>//foo</code>。</li><li>不可以有相对路径引用：错误示例：<code>..</code> 或者 <code>./</code>。<ul><li>不可用 <code>..</code> 引用其他 package 的 files，可以用 <code>//package-name:filename</code>。</li></ul></li><li> file target 中 可以使用<code> /</code>，但是在 rule 的名字中不要使用<code>/</code>：</li><li>尽管没有 package <code>//foo/bar/wiz</code>，<code>//foo/bar/wiz</code> 也表示 <code>//foo/bar/wiz:wiz</code>。</li><li>尽管  <code>bar/wiz</code> target 存在，<code>//foo/bar/wiz</code> 也无法表示为 <code>//foo:bar/wiz</code>。</li><li>但是对于一些场合必须，也是允许的。比如特定 rules 的名字，必须和源文件名一致，而这些文件存在于 package 的子目录中。</li></ul><h4 id="Package-names-—-package-name-target-name"><a href="#Package-names-—-package-name-target-name" class="headerlink" title="Package names — //package-name:target-name"></a>Package names — //package-name:target-name</h4><ul><li>package 的名字是包含 BUILD 文件的目录，相对于 main repository 的目录名。如 <code>my/app</code>。</li><li>package 名可包含大小写和数字，以及标点符号 <code>/, -, ., @,_</code>。不可以以 <code>/</code> 开始或者结束，也不要包含 <code>//</code>。</li><li>Bazel 支持在 workspace 的根 package 下声明 target，如<code>//:foo</code>，但是尽量让这个 package 不为空，这样每个 package 都有可描述的名字。</li></ul><h3 id="Rule"><a href="#Rule" class="headerlink" title="Rule"></a>Rule</h3><ul><li><p>rules 声明了输入和输出间的关系，以及构造输出的步骤。</p></li><li><p>rules 有很多类型（称作 <em>rule class</em>），可产生<strong>编译好的的二进制可执行文件，库，测试用的可执行文件</strong>以及<a href="https://bazel.build/reference/be/overview">其他支持的输出</a>。</p></li><li><p>BUILD 文件通过调用 rules 声明 targets。</p></li></ul><p>rule 的名字（即 name 属性）必须是合法的 target 名字。</p><ul><li>每条 rule 的调用都有 name 属性（其值必须是合法的 targe name），声明了package 中的一个 target。<ul><li>有时候，rule 的名字比较随意，and more interesting are the names of the files generated by the rule, and this is true of genrules. For more information, see <a href="https://bazel.build/reference/be/general#genrule">General Rules: genrule</a>.</li><li>有时候，rule 的名字比较重要，比如 <code>*_binary</code> and <code>*_test</code> rules，rule 的名字决定了构建输出的可执行文件的名字。</li></ul></li><li>每条 rule 都有多个属性，从<a href="https://bazel.build/reference/be/overview">构建百科全书</a>可以看到一些 rule 和对应的属性。<ul><li>每个属性有name 和 type，可看作属性是从键（名称）到可选类型值的字典。</li><li>type 的可选类型包括 integer，label，list of label，string，list of string，output label，list of output label。</li><li><code>src</code> 属性的 type 是  “list of labels”，每个 label 是当前 rule 的输入。</li></ul></li></ul><pre><code class="python">cc_binary(    name = &quot;my_app&quot;,    srcs = [&quot;my_app.cc&quot;],    deps = [        &quot;//absl/base&quot;,        &quot;//absl/strings&quot;,    ],)</code></pre><p>target 组成的有向无环图称作  <em>target graph</em> or <em>build dependency graph</em>，是 <a href="https://bazel.build/docs/query-how-to">Bazel Query tool</a> 执行的领域。</p><h2 id="BUILD文件"><a href="#BUILD文件" class="headerlink" title="BUILD文件"></a>BUILD文件</h2><p>build文件就是真正定义编译规则的文件了，每个目录下都有一个，每个源文件都要在BUILD中定义它的编译规则。</p><p><code>BUILD</code> files are evaluated using an imperative language, <a href="https://github.com/bazelbuild/starlark/">Starlark</a>。文件中的 rules 被解释为顺序的 statements。</p><ul><li>一般来说， 变量的声明要在使用之前，顺序很重要，但是 BUILD 文件中只包含构建 rules 的声明，所以顺序不是很重要。只需要保证用到的 rules 被声明过了。</li><li>为了鼓励代码和数据的分离，BUILD 文件中： 不允许有函数的定义，<code>for</code> statements，或者 <code>if</code> statements（但是 list comprehensions and <code>if</code> expressions  是可以的），不支持 <code>*args</code> and <code>**kwargs</code> 参数，参数必须明确支持。</li><li>可以在 <code>.bzl</code> 文件中定义函数。 </li></ul><p>Starlark 中的程序不可以执行任意的 I/O，因此输入都是定的，使得构建都是可再现的，即 <a href="https://bazel.build/concepts/hermeticity">Hermeticity</a>。</p><h3 id="Loading-an-extension"><a href="#Loading-an-extension" class="headerlink" title="Loading an extension"></a>Loading an extension</h3><p>Bazel extensions 是以 <code>.bzl</code> 结尾的文件，可使用 <code>load</code> statement 从 extension 导入符号。</p><p><code>.bzl</code> 文件中以<code>_</code> 开头的符号不会被导出，也不会被其他文件加载。文件可见性不会影响加载：因此不需要使用 <code>exports_files</code> 让 <code>.bzl</code> 文件可见。？？</p><pre><code class="python">load(&quot;//foo/bar:file.bzl&quot;, &quot;some_library&quot;)</code></pre><ul><li>从 <code>//foo/bar:file.bzl</code> 加载代码，并把 <code>some_library</code> 符号加入环境。</li><li>此方式可用来加载 新的 rules，函数，或常量（string，list等）</li><li>可以在 <code>load</code> 中新增其他的参数，导入更多的符号。参数必须是字符串常量，不可以是变量。</li><li><code>load</code> statement 必须在顶层，不可以在函数体内。</li><li><code>load</code> 的第一个参数是标识 <code>.bzl</code> 的 label，如果是相对的 label，则解析为包含当前 <code>.bzl</code> 文件所在的 package（不是目录） ，load statements 中的相对 label 需要有前导 <code>:</code> 。</li></ul><pre><code class="python">load(&quot;//foo/bar:file.bzl&quot;, library_alias = &quot;some_library&quot;)</code></pre><ul><li>load 支持别名，因此可以给导入的符号赋不同的名字。</li></ul><pre><code class="python">load(&quot;:my_rules.bzl&quot;, &quot;some_rule&quot;, nice_alias = &quot;some_other_rule&quot;)</code></pre><ul><li>可以在一个 load statement 中定义多个别名。</li></ul><h3 id="构建规则的类型"><a href="#构建规则的类型" class="headerlink" title="构建规则的类型"></a>构建规则的类型</h3><p>The majority of build rules come in families, grouped together by language. </p><ul><li><code>*_binary</code> rules构建给定语言的可执行程序。如 label <code>//my:program</code> 的结果存放在    <code>$(BINDIR)/my/program</code>。<ul><li>有的语言，会将 rule 的 data 属性下的文件（以及依赖rule的这种文件），放到 runfiles 目录，便于部署到生产。</li></ul></li><li><code>*_test</code> rules 是 <code>*_binary</code> rule 的特化，用于自动化测试。<ul><li>和 二进制文件一样，tests 也有 runfiles 树，其中只包含测试运行时必要的文件。比如 <code>cc_test(name=&#39;x&#39;, data=[&#39;//foo:bar&#39;])</code> may open and read <code>$TEST_SRCDIR/workspace/foo/bar</code> during execution. （每种语言都有自己的函数去获得<code>$TEST_SRCDIR</code> 的值，但是都等同于直接使用环境变量）</li></ul></li><li>*_library rules 声明了每个模块的构建规则，可以依赖其他 libraries，binaries 和 tests 可以依赖 libraries。</li></ul><p><em>在 cc_binary 中定义可执行程序的编译规则，在cc_library中定义库的编译规则（即.o文件），在trpc_proto_library中定义pb文件的编译规则。</em></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>如果 A 在构建或者执行时，需要 B，那么 target A 依赖 target B。这种 依赖关系构成 <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a>，称作 <strong>依赖图</strong>。</p><p>直接依赖：在依赖图中一跳可到达。</p><p>可传递依赖：依赖图中多跳到达。</p><p>构建时，存在两种依赖图：实际（ actual ）依赖，声明（declared）依赖。</p><h3 id="实际依赖和声明依赖"><a href="#实际依赖和声明依赖" class="headerlink" title="实际依赖和声明依赖"></a>实际依赖和声明依赖</h3><p>target X 实际依赖 target Y，当且仅当为了 X  编译成功， Y 必须存在，且是最新的。<strong>在代码中实际用了的。</strong></p><p>“built” 代表：generated, processed,compiled, linked, archived, compressed, executed等在构建过程中经常发生的任务。</p><p>target X 声明依赖 target Y，当且仅当 X 所在的  package 中，有一条  X 到 Y 的依赖边。<strong>在rule 规则中写了的。</strong></p><p><em>为了正确编译，实际依赖的图 A 必须是声明依赖图 D 的子图 。也就是说，A 中直接相连的节点 x–&gt; y. 在 D 中也必须直接相连，称作  D 是 A 的 overapproximation。overapproximation不要太过度，否则冗余的声明依赖会使得编译很慢，二进制文件很大。</em></p><blockquote><p>For correct builds, the graph of actual dependencies <em>A</em> must be a subgraph of the graph of declared dependencies <em>D</em>. That is, every pair of directly-connected nodes <code>x --&gt; y</code> in <em>A</em> must also be directly connected in <em>D</em>. It can be said that <em>D</em> is an <em>overapproximation</em> of <em>A</em>.</p><p><strong>Important:</strong> <em>D</em> should not be too much of an overapproximation of <em>A</em> because redundant declared dependencies can make builds slower and binaries larger.</p></blockquote><p><strong>写 BUILD 文件时，每条 rule 都必须显示声明所有实际的直接依赖。不要试图列出所有的非直接依赖。</strong></p><p>这是一条很重要的规则，否则构建可能会依赖之前的一些操作，或者会依赖到一些传递声明的 target，导致未知错误。虽然 bazel 会做检查并报告错误，但是有时候并不全面。</p><p>传递依赖带来的常见问题：一个文件中的代码可能会使用非直接依赖中提供的代码，非直接依赖不会写在 BUILD 文件中，因此无法追踪这些文件的修改，比如文件的依赖，a 声明依赖b，b 声明依赖 c，a 中实际依赖 b，实际依赖 c，那么当 b 中没有实际依赖 c 时，会影响到 a 的 构建。</p><h3 id="依赖的类型"><a href="#依赖的类型" class="headerlink" title="依赖的类型"></a>依赖的类型</h3><p>大部分构建 rule 在声明不同的依赖时，有都<a href="https://bazel.build/reference/be/common-definitions">通用的属性</a>，以及 <a href="https://bazel.build/reference/be">rule 特定的依赖</a>，例如 <code>compiler</code> / <code>resources</code>。</p><ul><li>通用属性<ul><li><code>src</code></li><li><code>deps</code></li><li><code>data</code>：有的构建 target 运行时需要数据文件，数据文件不是源文件，所以不会影响 target 如何被构建。比如 单元测试需要比对函数的输出和文件的内容，构建单元测试 target 时不需要数据文件，但是运行时需要。The same applies to tools that are launched during execution.<ul><li>构建系统在单独的目录运行测试，只有列举在 data 中的文件时可用的。</li></ul></li></ul></li></ul><p>These files are available using the relative path <code>path/to/data/file</code>. In tests, you can refer to these files by joining the paths of the test’s source directory and the workspace-relative path, for example, <code>$&#123;TEST_SRCDIR&#125;/workspace/path/to/data/file</code>.</p><h3 id="使用-labels-引用目录"><a href="#使用-labels-引用目录" class="headerlink" title="使用 labels 引用目录"></a>使用 labels 引用目录</h3><ul><li><code>data</code> labels 引用目录，最好不要以/. 或者 / 结尾的方式。不推荐示例：<ul><li> <code>data = [&quot;//data/regression:unittest/.&quot;]</code></li><li><code>data = [&quot;testdata/.&quot;]</code></li><li><code>data = [&quot;testdata/&quot;]</code></li></ul></li></ul><p>这种直接写目录的方式看起来很方便，直接能用目录下的所有文件，但是不要这样用：</p><ul><li>为了确保正确的增量构建，以及测试的重新执行，构建系统必须要知道所有的输入文件。</li><li>对于直接包含整个目录的方式，编译系统只检查目录有没有变化（是否有增删文件），不会探测对单个文件的内部修改。</li><li>因此，不要直接把目录作为编译系统的输入，应该将目录内的文件列举出来，明确说明。或者用 <code>glob()</code> 函数，如 <code>data = glob([&quot;testdata/**&quot;])</code>，用 <code>** </code>强制 glob 函数递归。</li></ul><p>当一些场景必须使用目录 labels（即以目录结尾），而其名称不符合 label 语法，那么遍历文件，或者使用 glob 函数会导致非法 label 错误，则必须使用目录 label。此时，对于父 package，不可以用相对的 <code>../</code> 路径，应该使用绝对路径如<code>//data/regression:unittest/</code></p><p>注意：<strong>directory label</strong> 只对 data 依赖有效。</p><p>当外部 rule，比如 test ，需要使用多个文件时，需要显示声明对所有文件的依赖，可以在 BUILD 文件中用 <code>filegroup</code> 将文件打包在一起。即可在test 中引用 label <code>my_data</code>。</p><pre><code class="python">filegroup(        name = &#39;my_data&#39;,        srcs = glob([&#39;my_unittest_data/*&#39;]))</code></pre><p><del>Bazel 中 funciton 的BUILD 百科<br>Rules<br>推荐的 rules ：<a href="https://docs.bazel.build/versions/main/rules.html#recommended-rules">https://docs.bazel.build/versions/main/rules.html#recommended-rules</a><br>Bazel binary 中配备的 native rule 不需要用 load 声明，native rules 对于 BUILD 文件是全局可用的，可在 .bzl 文件的 native 模块找到。</del></p><h2 id="Visibility"><a href="#Visibility" class="headerlink" title="Visibility"></a>Visibility</h2><p>package and subpackages 的信息，详见<a href="https://bazel.build/concepts/build-ref">概念和术语</a>。</p><p>Visibility 控制了当前的 target 是否可以被其他 package 中的 target 依赖。从而区分 library API 以及实现细节。关闭可见性检查： <code>--check_visibility=false</code>。</p><h3 id="Visibility-specifications"><a href="#Visibility-specifications" class="headerlink" title="Visibility specifications"></a>Visibility specifications</h3><p>rule target 的 <code>visibility</code> 属性中包含多个 labels，表示此 target 对这些 labes 可见。同一个 package 中的 target 是互相可见的。</p><p>labels 的形式：</p><ul><li><code>&quot;//visibility:public&quot;</code>：任何人都可以使用此 target。</li><li><code>&quot;//visibility:private&quot;</code>：只有此 package 可以使用此 target。</li><li><code>&quot;//foo/bar:__pkg__&quot;</code>：<code>//foo/bar</code>（不包含其 subpackage） 下定义的 targets 可以使用此 target。<code>__pkg__</code> 是 package 中所有 targets 的特殊句法。</li><li><code>&quot;//foo/bar:__subpackages__&quot;</code>：<code>//foo/bar</code>下定义的（包括直接或间接 package 的）所有 targets，可以使用此 target。</li><li><code>&quot;//foo/bar:my_package_group&quot;</code>：<a href="https://bazel.build/reference/be/functions#package_group">package group</a> 中的所有 package 可访问。</li></ul><p>example</p><pre><code class="python">//some/packagecc_library (  name = &quot;mytarget&quot;,  src = [&quot;xx&quot;,],  visibiliry = [    &quot;:__subpackages__&quot;,    &quot;//tests:__pkg__&quot;  ])# mytarget 可以被 //some/package/... 下的所有 target 以及 //tests/BUILD 中定义的 target 使用，但是不能被 //tests/integration/BUILD 中的 target 使用。</code></pre><p><code>package_group</code>  targets 本身没有 visibility 属性，总是 publicly visible。</p><p>Visibility cannot be set to specific non-package_group targets. That triggers a “Label does not refer to a package group” or “Cycle in dependency graph” error.</p><h3 id="Visibility-of-a-rule-target-generated-file-target"><a href="#Visibility-of-a-rule-target-generated-file-target" class="headerlink" title="Visibility of a rule target/generated file target"></a>Visibility of a rule target/generated file target</h3><p>rule target 中没有设置 visibility 属性，则可见性由BUILD 文件中的 package statement 设定，key 是  <a href="https://bazel.build/reference/be/functions#package.default_visibility"><code>default_visibility</code></a> 。 没有声明 default_visibility 时，默认是 <code>//visibility:private</code>。</p><p>config_setting 可见性默认不强制生效。</p><p><code>--incompatible_enforce_config_setting_visibility</code> and <code>--incompatible_config_setting_private_default_visibility</code> provide migration logic for converging with other rules.</p><ul><li><p>If <code>--incompatible_enforce_config_setting_visibility=false</code>, every <code>config_setting</code> is unconditionally visible to all targets.</p></li><li><p>Else if <code>--incompatible_config_setting_private_default_visibility=false</code>, any <code>config_setting</code> that doesn’t explicitly set visibility is <code>//visibility:public</code> (ignoring package <a href="https://bazel.build/reference/be/functions#package.default_visibility"><code>default_visibility</code></a>).</p></li><li><p>Else if <code>--incompatible_config_setting_private_default_visibility=true</code>, <code>config_setting</code> uses the same visibility logic as all other rules.</p></li></ul><p>Best practice is to treat all like other rules: explicitly set <code>visibility</code> on any <code>config_setting</code> used anywhere outside its package.</p><p>最佳实践：</p><ul><li>将  <code>config_setting</code> targets 和其他 rules 一样对待：为每个用到 <code>config_setting</code> 的package，显示设置  <code>visibility</code> 。</li></ul><h3 id="Visibility-of-a-source-file-target"><a href="#Visibility-of-a-source-file-target" class="headerlink" title="Visibility of a source file target"></a>Visibility of a source file target</h3><p>默认情况下，源文件 targets 只在同一个 package 中可见，如果其他 package 也想访问此源文件，使用 <a href="https://bazel.build/reference/be/functions#exports_files"><code>exports_files</code></a>。使用此方法时，如果设置了 visibility 属性，则应用；否则文件就是 public 的， <code>default_visibility</code> 设置被忽略。</p><p>如果可以，推荐将文件包裹成 library 或者其他类型的 rule，而不是直接用源文件。</p><p>example：</p><p>File <code>//frobber/data/BUILD</code>：</p><pre><code class="python">exports_files([&quot;readme.txt&quot;])</code></pre><p>File <code>//frobber/bin/BUILD</code>：</p><pre><code class="python">cc_binary(  name = &quot;my-program&quot;,  data = [&quot;//frobber/data::readme.txt&quot;],)</code></pre><p>If the flag <a href="https://github.com/bazelbuild/bazel/issues/10225"><code>--incompatible_no_implicit_file_export</code></a> is not set, a legacy behavior applies instead.</p><p>With the legacy behavior, files used by at least one rule target in the package are implicitly exported using the <code>default_visibility</code> specification. See the <a href="https://github.com/bazelbuild/proposals/blob/master/designs/2019-10-24-file-visibility.md#example-and-description-of-the-problem">design proposal</a> for more details.</p><h3 id="Visibility-of-bzl-files"><a href="#Visibility-of-bzl-files" class="headerlink" title="Visibility of bzl files"></a>Visibility of bzl files</h3><p>load statement 暂时不应用 visibility，因此可以在 workspace 的任意地方加载 bzl 文件。</p><p>However, users may choose to run the Buildifier linter. The <a href="https://github.com/bazelbuild/buildtools/blob/master/WARNINGS.md#bzl-visibility">bzl-visibility</a> check provides a warning if users <code>load</code> from beneath a subdirectory named <code>internal</code> or <code>private</code>.</p><h3 id="Visibility-of-implicit-dependencies"><a href="#Visibility-of-implicit-dependencies" class="headerlink" title="Visibility of implicit dependencies"></a>Visibility of implicit dependencies</h3><p>有的 rules 有隐式依赖。如 c++ 的 rule 可能隐式依赖 c++ 编译器。当前的隐式依赖和一般依赖的处理方式一致，需要对 rule 的所有实例可见，通过 using <a href="https://github.com/bazelbuild/proposals/blob/master/designs/2019-10-15-tool-visibility.md"><code>--incompatible_visibility_private_attributes_at_definition</code></a>. 修改此行为。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>避免将 default visibility 设置为 public</li><li>使用  <code>package_group</code> 在多个 targets 中共享 vidibility 声明。当多个 BUILD 中的 targets 需要暴露给同一个 package 的集合时，此方法很有用。</li><li>当 deprecating 一个 target 时，使用更细粒度的可见性说明，只将 visibillity 限制给当前的用户，避免新的依赖。</li></ul><h2 id="Platforms"><a href="#Platforms" class="headerlink" title="Platforms"></a>Platforms</h2><h2 id="Hermeticity"><a href="#Hermeticity" class="headerlink" title="Hermeticity"></a>Hermeticity</h2><h2 id="cc-libraryxxxx"><a href="#cc-libraryxxxx" class="headerlink" title="cc_libraryxxxx"></a>cc_libraryxxxx</h2><p>头文件的包含检查。=》只适用于直接包含。<br>● 在编译中用到的头文件，必须在cc_* rule 的 hdrs 或者 srcs 中被声明。=》强制<br>● 对于 cc_library rules，hdrs 中的头文件，组成了这个 library 的公共接口<br>    ○ 此 library 的 hdrs 和 srcs 中的文件可直接包含 hrds 中的头文件<br>    ○ 其他 library 的 deps 如果依赖此 library，其 srcs 和 hdrs 也能包含此 library 的hdrs中的头文件<br>● srcs 中的头文件只能被此 library 的 hdrs 和 srcs 中的文件包含。<br>● 将文件放在 srcs 或者 hdrs，需要考虑，你是否希望此 library 的用户可以直接包含这个头文件，类似编程语言中的 public 和 private。<br>cc_binary 和 cc_test rule 没有对外的接口，因此没有 hdrs 属性，直接放在 srcs 中就行。<br>对.cc文件的编译，可以递归地包含在递归的 deps 必报中的所有 cc_library 中的 hdrs 和 srcs 中的文件。</p><h1 id="Output-Directory-Layout-xxx"><a href="#Output-Directory-Layout-xxx" class="headerlink" title="Output Directory Layout xxx"></a>Output Directory Layout xxx</h1><p><a href="https://bazel.build/docs/output_directories">https://bazel.build/docs/output_directories</a><br>条件<br>当前布局<br>● Bazel 必须在包含 WORKSPACE 的目录 or 其子目录中被调用<br>● 输出根目录（outputRoot）默认为：<br>    ○ linux：~/.cache/bazel<br>    ○ macos：/private/var/tmp<br>    ○ Windows：defaults to %HOME%, %USERPROFILE%<br>    ○ 如果设置了环境变量 $TEST_TMPDIR ，对 bazel 做测试，则覆盖默认<br>● 用户构建状态存在于outputUserRoot：outputRoot/<em>bazel</em>$USER，其中包含：<br>    ○ install/md5(Bazel installation manifest)：installBase<br>    ○ 如果 bazel 在 workspace 目录（或者符号链接）/home/user/src/my-project，outputBase 是目录名的 MD5 hash。<br>        ■ 可以使用 –output_base 覆盖原有的 output base 目录<br>        ■ 可以使用 –output_user_root 启动选项覆盖默认的 install base 和 output base目录<br>● bazel-<workspace-name>，bazel-out，bazel-testlogs，bazel-bin 在 workspace 目录，都是一些符号链接，指向 output 目录中 target-specific 的目录。这些文件只为用户方便使用，Bazel 不使用。 </p><p>布局图</p><p>bazel clean<br>● bazel clean 在 outputPath 和 action_cache 目录上执行 ，并移除 workspace 符号链接。–expunge 清空整个 outputBase。</p><h4 id="Wrokspace-Rules。xxxx"><a href="#Wrokspace-Rules。xxxx" class="headerlink" title="Wrokspace Rules。xxxx"></a><a href="https://bazel.build/reference/be/workspace">Wrokspace Rules</a>。xxxx</h4><p>当你使用bazel build xxxx命令进行编译时，bazel 会以 WORKSPACE 文件所在目录作为根目录（寻找输入和BUILD文件）进行编译，并存储编译结果。<br>WORKAPCE 文件里定义了bazel项目的一些基本信息，和项目需要的外部依赖（比如当前项目依赖外部项目中的目标，或者从网上下载项目）<br>● 主项目的BUILD文件可以使用 WORKSPACE 中的名字，依赖外部 target<br>● WORKSPACE 文件中的语法和BUILD类似，但是还允许其他的规则<br>● repository rules（workspace rules）<br>    ○ 内置规则：<a href="https://docs.bazel.build/versions/main/be/workspace.html">https://docs.bazel.build/versions/main/be/workspace.html</a><br>        ■ local_repository<br>        ■ new_local_repository<br>    ○ starlark 中内嵌的 repository 规则（git or http）：<a href="https://docs.bazel.build/versions/main/repo/index.html">https://docs.bazel.build/versions/main/repo/index.html</a><br>    ○ 用户自定义 repository 规则：<a href="https://docs.bazel.build/versions/main/skylark/repository_rules.html">https://docs.bazel.build/versions/main/skylark/repository_rules.html</a><br>外部依赖定义方式<br>详细见：<a href="https://docs.bazel.build/versions/main/external.html">https://docs.bazel.build/versions/main/external.html</a><br>建议 http_archive &gt; git_repository &gt; new_git_repository<br>依赖其他 Bazel 项目<br>可以使用 local_repository，git_repository, http_archive，分别代表：从本地文件系统软连接，引用 git 仓库，从网上下载。<br>● WORKSPACE 中写法：<br>local_repository(<br>    name = “coworkers_project”,<br>    path = “/path/to/coworkers-project”,<br>)</p><p>● BUILD 中写法：@coworkers_project//foo:bar 。外部项目的命名必须是合法的workspace名字，即用 xx_xx，而不是 xx-xx。<br>依赖其他非 Bazel 项目<br>new_local_repository，new_git_repository， http_archive<br>依赖外部包<br>比如maven项目</p><h2 id="认识-bazelrc文件-xxxx"><a href="#认识-bazelrc文件-xxxx" class="headerlink" title="认识.bazelrc文件 xxxx"></a>认识.bazelrc文件 xxxx</h2><p>bazel在编译时可以指定编译选项，包括gcc的选项以及 bazel 自身的选项。否则，每次使用bazel build xxxx命令进行编译时，你都需要指定编译选项，比如c++17。</p><h1 id="编写-BUILD-文件"><a href="#编写-BUILD-文件" class="headerlink" title="编写 BUILD 文件"></a>编写 BUILD 文件</h1><h2 id="BUILD-文件的风格"><a href="#BUILD-文件的风格" class="headerlink" title="BUILD 文件的风格"></a>BUILD 文件的风格</h2><p>使用 <a href="https://github.com/bazelbuild/buildifier">Buildifier</a> 格式化 BUILD 文件。</p><ul><li><p>文件的结构：</p><ul><li><p>描述/注释</p><ul><li>单独的注释下面用空行隔开</li><li>某个元素的注释紧挨着</li></ul></li><li><p>load</p></li><li><p>package</p></li><li><p>对 rules/macros 的调用</p></li></ul></li><li><p>引用当前package的 targets：</p><ul><li><p>使用相对于package 的路径，不要用<code>..</code> </p></li><li><p>生成的文件，引用时以 <code>:</code> 开头，标识其不是源文件</p></li><li><p>源文件不要以 <code>:</code> 开头</p></li><li><p>rules 需要以<code>:</code>  开头</p><pre><code class="python">cc_library(    name = &quot;lib&quot;,    srcs = [&quot;x.cc&quot;],    hdrs = [&quot;:gen_header&quot;],)genrule(    name = &quot;gen_header&quot;,    srcs = [],    outs = [&quot;x.h&quot;],    cmd = &quot;echo &#39;int x();&#39; &gt; $@&quot;,)</code></pre></li></ul></li><li><p>target 命名</p><ul><li>命名需要有描述性<ul><li>如果 target 包含源文件，target name 需要和 源文件名一致。</li><li>与 package 同名的 target 在最后一层目录，其名字需要具有描述性，如果描述和target不一致，不要用同名 target。</li><li>当使用 eponymous target 时，建议用 短名字：(<code>//x</code> instead of <code>//x:x</code>)。</li><li>如果在同一个 package 中，建议用局部引用： (<code>:x</code> instead of <code>//x</code>)。</li><li>不要使用保留的关键字。如 all，<code>__pkg__</code>等。</li></ul></li><li>google 的推荐命名做法</li></ul></li><li><p>visibility</p><ul><li>尽量使用准确的可见性，只有对外暴露的才使用 public。</li></ul></li><li><p>dependencies</p><ul><li>尽量限制为直接依赖。代码中有的依赖中也写。</li><li>本 package 的依赖优先写，不要用绝对 package 名。</li><li>将通用的依赖放在一个变量中。</li></ul></li><li><p>Globs</p><ul><li>使用 <code>[]</code> 标识没有 targets，不要使用 glob 去匹配 nothing。</li><li>不要用递归的 globs 匹配源文件，如 <code>glob([&quot;**/*.java&quot;])</code>)。</li><li>建议每个文件夹下都放一个 BUILD 文件，生成依赖图。</li><li>非递归的 globs 是可接受的。</li></ul></li><li><p>其他惯例</p><ul><li>使用大写和下划线声明常量（如  <code>GLOBAL_CONSTANT</code>），使用小写和下划线声明变量（如  <code>my_variable</code>）。</li><li>labels 不要切分，便于替换等操作。</li><li>name 属性的名字需要是 常量字符串。</li><li>设置布尔值属性时，使用 true/false 而不是 0/1。</li></ul></li></ul><h2 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h2><ul><li><p>当一条内容会被多次使用，可以在当前 BUILD 文件中定义变量（全局常量一般用大写字母），如 <code>COPTS = [&quot;-DVERSION=5&quot;]</code> 。</p></li><li><p>在多个 BUILD 文件间共享变量，需要放在 .bzl 文件中。</p><ul><li>.bzl 文件中的定义（变量和函数）可以用在 BUILD 文件中。</li></ul><p>In <code>path/to/variables.bzl</code>, write:</p><pre><code class="python">COPTS = [&quot;-DVERSION=5&quot;]</code></pre><p>Then, you can update your <code>BUILD</code> files to access the variable:</p><pre><code class="python">load(&quot;//path/to:variables.bzl&quot;, &quot;COPTS&quot;)cc_library(  name = &quot;foo&quot;,  copts = COPTS,  srcs = [&quot;foo.cc&quot;],)</code></pre></li></ul><h2 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h2><p>bazel 可以依赖其他项目的 targets，其他项目的依赖叫做外部依赖（<em>external dependencies</em>）。</p><p><code>WORKSPACE/WORKSPACE.bazel</code> 文件描述了 bazel 如何获取其他项目的源文件，称作 <em>repository rules</em> /<em>workspace rules</em></p><ul><li>其他项目也包含了多个 BUILD 文件描述自己的 targets。</li><li>mian 项目中的 BUILD 文件可以使用 WORKSPACE 中定义的名字，来引用外部的 targets。</li></ul><p>Bazel comes with a few <a href="https://bazel.build/reference/be/workspace">built-in repository rules</a> and a set of <a href="https://bazel.build/rules/lib/repo">embedded Starlark repository rules</a>. Users can also write <a href="https://bazel.build/rules/repository_rules">custom repository rules</a> to get more complex behavior.</p><h3 id="bazel-支持的外部依赖类型"><a href="#bazel-支持的外部依赖类型" class="headerlink" title="bazel 支持的外部依赖类型"></a>bazel 支持的外部依赖类型</h3><ol><li>Depending on other Bazel projects<ul><li>可以用 <a href="https://bazel.build/reference/be/workspace#local_repository"><code>local_repository</code></a>, <a href="https://bazel.build/rules/lib/repo/git#git_repository"><code>git_repository</code></a> or <a href="https://bazel.build/rules/lib/repo/http#http_archive"><code>http_archive</code></a> ，从本地文件系统软链，或者引用 git repository，或者下载。</li></ul></li><li>Depending on non-Bazel projects<ul><li>为此项目的依赖写 BUILD 文件。build_file </li></ul></li><li>Depending on external packages<ul><li>Maven artifacts and repositories</li></ul></li></ol><ul><li><p>获取依赖：</p><ul><li><p>一般通过 <code>bazel build</code></p></li><li><p>要为一些 targets 预拉取，使用 <code>bazel fetch</code></p></li><li><p>无条件拉取所有依赖，使用 <code>bazel sync</code></p></li><li><p>As fetched repositories are <a href="https://bazel.build/docs/external#layout">stored in the output base</a>, fetching happens per workspace</p></li></ul></li><li><p>Shadowing dependencies</p><ul><li>尽可能在自己的项目中只依赖一种版本</li><li>xxx</li></ul></li><li><p>通过命令行覆写 repositories</p><ul><li>设置 <a href="https://bazel.build/reference/command-line-reference#flag--override_repository"><code>--override_repository</code></a> flag. 使用此flag，只改变外部 repository 的内容，而不改变源码。</li><li>to override <code>@foo</code> to the local directory <code>/path/to/local/foo</code>, pass the <code>--override_repository=foo=/path/to/local/foo</code> flag。</li><li>用途<ul><li>debugging，不去拉远端，而改本地，让调试更方便。</li><li>Vendoring，没法发起网络调用的环境下，使用本地 repository。</li></ul></li></ul></li><li><p>Transitive dependencies</p><ul><li>Bazel only reads dependencies listed in your <code>WORKSPACE</code> file. If your project (<code>A</code>) depends on another project (<code>B</code>) which lists a dependency on a third project (<code>C</code>) in its <code>WORKSPACE</code> file, you’ll have to add both <code>B</code> and <code>C</code> to your project’s <code>WORKSPACE</code> file. This requirement can balloon the <code>WORKSPACE</code> file size, but limits the chances of having one library include <code>C</code> at version 1.0 and another include <code>C</code> at 2.0.</li></ul></li><li><p>缓存外部依赖</p><ul><li>Bazel 默认只会对修改的部分重新下载。如果强制重新下载，使用  <code>bazel sync</code>。</li></ul></li><li><p>布局</p><ul><li>外部依赖下载到 external 文件夹。</li><li><code>bazel clean</code> 只清除了软链，而 <code>bazel clean --expunge</code> 清除了所有外部 artifacts。</li></ul></li><li><p>线下构建</p><ul><li>xxx</li></ul></li></ul><h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li><p>A repository rule should generally be responsible for:</p><ul><li><p>Detecting system settings and writing them to files.</p></li><li><p>Finding resources elsewhere on the system.</p></li><li><p>Downloading resources from URLs.</p></li><li><p>Generating or symlinking BUILD files into the external repository directory.</p></li></ul></li><li><p>尽量避免使用 <code>repository_ctx.execute</code> </p><ul><li>当使用非bazel 化的 c++ library，优先推荐使用 <code>repository_ctx.download()</code> ，之后写 BUILD 文件构建它，而不是运行   <code>ctx.execute([&quot;make&quot;])</code>。</li></ul></li><li><p>Prefer <a href="https://bazel.build/rules/lib/repo/http#http_archive"><code>http_archive</code></a> to <code>git_repository</code> and <code>new_git_repository</code>：</p><ul><li>Git repository 依赖于系统中的 git，而 HTTP 下载器是集成在 bazel 中的，没有系统依赖。</li><li><code>http_archive</code> 支持 <code>urls</code> 列表作为 mirrors, 而  <code>git_repository</code> 只支持单个的 <code>remote</code>。</li></ul></li></ul><h2 id="通过-Bzlmod-管理依赖-new-xxx"><a href="#通过-Bzlmod-管理依赖-new-xxx" class="headerlink" title="通过 Bzlmod 管理依赖 new xxx"></a>通过 Bzlmod 管理依赖 new xxx</h2><h1 id="运行-bazel"><a href="#运行-bazel" class="headerlink" title="运行 bazel"></a>运行 bazel</h1><h2 id="用-bazel-构建"><a href="#用-bazel-构建" class="headerlink" title="用 bazel 构建"></a>用 bazel 构建</h2><h3 id="可用的-bazel-命令"><a href="#可用的-bazel-命令" class="headerlink" title="可用的 bazel 命令"></a>可用的 bazel 命令</h3><ul><li><a href="https://bazel.build/docs/user-manual#analyze-profile"><code>analyze-profile</code></a>: Analyzes build profile data.</li><li><a href="https://bazel.build/docs/user-manual#aquery"><code>aquery</code></a>: Executes a query on the <a href="https://bazel.build/docs/build#analysis">post-analysis</a> action graph.</li><li><a href="https://bazel.build/docs/build#bazel-build"><code>build</code></a>: 构建特定目标</li><li><a href="https://bazel.build/docs/user-manual#canonicalize-flags"><code>canonicalize-flags</code></a>: Canonicalize Bazel flags.</li><li><a href="https://bazel.build/docs/user-manual#clean"><code>clean</code></a>: 移除输出文件，并停止 server</li><li><a href="https://bazel.build/docs/cquery"><code>cquery</code></a>: Executes a <a href="https://bazel.build/docs/build#analysis">post-analysis</a> dependency graph query.</li><li><a href="https://bazel.build/docs/user-manual#dump"><code>dump</code></a>: Dumps the internal state of the Bazel server process.</li><li><a href="https://bazel.build/docs/user-manual#help"><code>help</code></a>: 打印命令的 help 信息，或者索引</li><li><a href="https://bazel.build/docs/user-manual#info"><code>info</code></a>: 打印 bazel server 的运行时信息</li><li><a href="https://bazel.build/docs/build#fetching-external-dependencies"><code>fetch</code></a>: 拉取 target 的所有外部依赖</li><li><a href="https://bazel.build/docs/user-manual#mobile-install"><code>mobile-install</code></a>: 在 mobile 设备上安装apps</li><li><a href="https://bazel.build/docs/query-how-to"><code>query</code></a>: 执行依赖图的查询</li><li><a href="https://bazel.build/docs/user-manual#running-executables"><code>run</code></a>: 运行特定 target</li><li><a href="https://bazel.build/docs/user-manual#shutdown"><code>shutdown</code></a>: 停止 bazel server</li><li><a href="https://bazel.build/docs/user-manual#running-tests"><code>test</code></a>: 构建和运行特定的 test target</li><li><a href="https://bazel.build/docs/user-manual#version"><code>version</code></a>: 打印 bazel 的 version 信息</li></ul><h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><ul><li><code>bazel help command</code>: 打印 command 的 help 和 options</li><li><code>bazel help</code><a href="https://bazel.build/docs/user-manual#startup-options"><code>startup_options</code></a>: Options for the JVM hosting Bazel.</li><li><code>bazel help</code><a href="https://bazel.build/docs/build#specifying-build-targets"><code>target-syntax</code></a>: 解释特定 target 的句法</li><li><code>bazel help info-keys</code>: info 命令中使用的 keys</li></ul><p>command：bazel tool 执行的许多函数。<code>bazel build</code> 和 <code>bazel test</code> 用的比较多。</p><h3 id="构建单个-target"><a href="#构建单个-target" class="headerlink" title="构建单个 target"></a>构建单个 target</h3><p>用 label 标识要构建的 target。</p><ul><li>loads</li><li>analyzes</li><li>execute</li></ul><h3 id="构建多个-target"><a href="#构建多个-target" class="headerlink" title="构建多个 target"></a>构建多个 target</h3><p>bazel 允许多种方法，去声明要构建的 target，叫做 target patterns（Target patterns are a generalization of the label syntax for <em>sets</em> of targets, using wildcards. 单个targe也是一种通配 target 的特例），用于 <code>build</code>, <code>test</code>,   <code>query</code> commands。</p><ul><li>foo/… 表示 所有 package 的通配符</li><li>:all 表示某个 package 中所有的 targets</li><li>:* 是 :all 的超集，包含了 file 和 rule</li></ul><table><thead><tr><th><code>//foo/bar:wiz</code></th><th>Just the single target <code>//foo/bar:wiz</code>.</th></tr></thead><tbody><tr><td><code>//foo/bar</code></td><td>Equivalent to <code>//foo/bar:bar</code>.</td></tr><tr><td><code>//foo/bar:all</code></td><td><strong>All rule targets</strong> in the package <code>foo/bar</code>.</td></tr><tr><td><code>//foo/...</code></td><td><strong>All rule targets</strong> in <strong>all packages</strong> beneath the directory <code>foo</code>.</td></tr><tr><td><code>//foo/...:all</code></td><td><strong>All rule targets</strong> in <strong>all packages</strong> beneath the directory <code>foo</code>.</td></tr><tr><td><code>//foo/...:*</code></td><td><strong>All targets (rules and files)</strong> in <strong>all packages</strong> beneath the directory <code>foo</code>.</td></tr><tr><td><code>//foo/...:all-targets</code></td><td><strong>All targets (rules and files)</strong> in <strong>all packages</strong> beneath the directory <code>foo</code>.</td></tr><tr><td><code>//...</code></td><td><strong>All targets</strong> in packages <strong>in the workspace</strong>. This does not include targets from <a href="https://bazel.build/docs/external">external repositories</a>.</td></tr><tr><td><code>//:all</code></td><td><strong>All targets</strong> in the <strong>top-level package</strong>, if there is a <code>BUILD</code> file at the root of the workspace.</td></tr></tbody></table><p>不以 // 开头的 target pattern，以相对于 working 目录的方式解析，下述例子假设有一个 working 目录：foo:</p><table><thead><tr><th><code>:foo</code></th><th>Equivalent to <code>//foo:foo</code>.</th></tr></thead><tbody><tr><td><code>bar:wiz</code></td><td>Equivalent to <code>//foo/bar:wiz</code>.</td></tr><tr><td><code>bar/wiz</code></td><td>Equivalent to:<code>//foo/bar/wiz:wiz</code> if <code>foo/bar/wiz</code> is a package<code>//foo/bar:wiz</code> if <code>foo/bar</code> is a package<code>//foo:bar/wiz</code> otherwise</td></tr><tr><td><code>bar:all</code></td><td>Equivalent to <code>//foo/bar:all</code>.</td></tr><tr><td><code>:all</code></td><td>Equivalent to <code>//foo:all</code>.</td></tr><tr><td><code>...:all</code></td><td>Equivalent to <code>//foo/...:all</code>.</td></tr><tr><td><code>...</code></td><td>Equivalent to <code>//foo/...:all</code>.</td></tr><tr><td><code>bar/...:all</code></td><td>Equivalent to <code>//foo/bar/...:all</code>.</td></tr></tbody></table><ul><li><p>bazel 允许 target 部分使用 / 而不是只有 :，在 bash finelname expansion 中很方便。</p><ul><li>例如 ：<code>foo/bar/wiz</code> is equivalent to <code>//foo/bar:wiz</code> (if there is a package <code>foo/bar</code>) or to <code>//foo:bar/wiz</code> (if there is a package <code>foo</code>).</li></ul></li><li><p>bazel 支持一次命令中有多个 target pattern</p><ul><li><code>bazel build foo/... bar/...</code>：构建 foo 目录和 bar 目录下的所有 target。</li><li><code>bazel build -- foo/... -foo/bar/...</code>：构建 foo 目录下 除了 foo/bar 下的所有 targets<ul><li><code>--</code> 是必要的，防止后续以 <code>-</code> 开头的参数，被解释为额外的 options </li><li> 这种方式并不能真正保证 /foo/bar 的 targets 不被构建，因为其target可能被其他部分依赖了，作为依赖被构建了</li></ul></li></ul></li><li><p>target 中带有  <code>tags = [&quot;manual&quot;]</code>  的 target，在执行 build / test 的命令时（query 命令不做此过滤），不会被包含在 target pattern（…, :*, :all 等） 中。必须明确指定。</p></li></ul><h3 id="拉取外部依赖"><a href="#拉取外部依赖" class="headerlink" title="拉取外部依赖"></a>拉取外部依赖</h3><p>默认情况下，bazel 在构建时下载和链接外部依赖。但我们有例外时 ：</p><ul><li><p>想知道何时加入了新的外部依赖</p></li><li><p>无网前，提前拉取依赖</p></li></ul><p>可以指定 <code>--fetch=false</code> flag 防止自动拉取。</p><ul><li>对于本地文件系统中文件的使用，不管这个 flag 是否设置，都会去拉取。</li><li>当关闭此 flag，但是构建过程中又需要外部的依赖，构建则会失败。</li><li>当需要运行 bazel fetch 时，此 flag 需要开启。<ul><li>fetch 发生在第一次构建前</li><li>加入新的外部依赖后</li></ul></li><li>拉取好外部依赖后， WORKSPACE 文件不修改时，fetch 不必再运行。</li><li><code>bazel fetch //foo:bar //bar:baz</code> 拉取这俩 target  需要的外部依赖。</li><li><code>bazel fetch //...</code> 拉取 workspace 需要的所有外部依赖。</li></ul><h4 id="repository-cache"><a href="#repository-cache" class="headerlink" title="repository cache"></a>repository cache</h4><p>bazel 试图避免多次拉取同一个文件，将所有下载的文件缓存在 <code>~/.cache/bazel/_bazel_$USER/cache/repos/v1/</code>. （此位置可以通过  <code>--repository_cache</code> option 修改 ），供所有 workspaces 和 installed versions 共享。</p><ul><li>如果下载请求的文件有 sha256，而 cache 中有文件有相同的 sha256，则可以直接使用，不仅安全，且避免非必要下载。</li><li>每次命中缓存，cache 中的文件的修改时间都被更新，最后一次使用 cache 目录中文件的时间很容易确定。for example to manually clean up the cache. The cache is never cleaned up automatically, as it might contain a copy of a file that is no longer available upstream.</li></ul><h4 id="Distribution-files-directories"><a href="#Distribution-files-directories" class="headerlink" title="Distribution files directories"></a>Distribution files directories</h4><p>和 repository cache 类似，用于避免重复下载。两者的主要差别是distribution directory  需要人工准备。</p><p>bazel 在搜索 repository cache之前，先在 分布式目录中搜寻。</p><p>使用  <a href="https://bazel.build/reference/command-line-reference#flag--distdir"><code>--distdir=/path/to-directory</code></a> option，可以指定额外的目录去寻找文件，指定目录下的文件都可用（可能使得目录很大）。如果 WORKSPACE 文件中指定了sha256，那么只有匹配的文件会被用。</p><h4 id="隔离环境中运行-bazel"><a href="#隔离环境中运行-bazel" class="headerlink" title="隔离环境中运行 bazel"></a>隔离环境中运行 bazel</h4><p>为了保证 bazel 二进制的尺寸较小，Bazel 的隐式依赖在首次运行时，通过网络连接拉取。这些隐式的依赖包含的 toolchains 和 rules 可能并不是对所有人都是有必要的。但在隔离环境中会有问题，尽管可能在</p><ul><li><p>可以在有网的情况下，准备一个包含这些依赖的 distribution directory，通过线下的方式传输到隔离环境中。</p></li><li><p>对于每个新的 Bazel 二进制，都需要准备这样的目录，因为每个 release 的隐式依赖，可能会不同。</p></li><li><p>构建依赖，需要拉取 bazel 的仓库代码，并构建 @additional_distfiles//:archives.tar target，将生成的产物，解压到新的目录中。</p><ul><li><code>tar xvf bazel-bin/external/additional_distfiles/archives.tar -C &quot;$NEW_DIRECTORY&quot; --strip-components=3</code></li></ul></li><li><p>最后，在隔离环境中使用 bazel 时，<code>--distdir</code> flag 指向目录，或者在 .bazelrc 里面新增一条 <code>build --distdir=path/to/directory</code></p></li></ul><h3 id="Build-configurations-and-cross-compilation"><a href="#Build-configurations-and-cross-compilation" class="headerlink" title="Build configurations and cross-compilation"></a>Build configurations and cross-compilation</h3><h2 id="commands-和-options"><a href="#commands-和-options" class="headerlink" title="commands 和 options"></a>commands 和 options</h2><p>–copts 等</p><h2 id="编写-bazelrc-文件"><a href="#编写-bazelrc-文件" class="headerlink" title="编写 bazelrc 文件"></a>编写 bazelrc 文件</h2><h2 id="通过脚本调用-Bazel"><a href="#通过脚本调用-Bazel" class="headerlink" title="通过脚本调用 Bazel"></a>通过脚本调用 Bazel</h2><h2 id="客户端和服务端架构"><a href="#客户端和服务端架构" class="headerlink" title="客户端和服务端架构"></a>客户端和服务端架构</h2><p>Bazel 系统是 long-lived server 进程。相比 batch-oriented  （A technique that uses a single program loading to process many individual jobs, tasks, or requests for service.） 实现，可以做诸多优化，如缓存 BUILD 文件，依赖图等，从而加速增量的构建，允许不同的命令共享相同的 packages 缓存，使得 queries 也很快。</p><ul><li>当运行 bazel 时，启动了一个 client。</li><li>client 基于output base（默认是 base workspace 目录和 uderid）寻找 server。base workspace 和 urserid 的不同使得并发执行成为可能，因为会启动不同的server。<ul><li>如果同一个用户在多个 workspace 中构建，则有多个 Bazel server 进程。</li><li>多个用户可以在同一个 workstation 并行构建，因为基于不同的 userids，output base 不同。</li><li>如果client 找不到运行中的 server 实例，则新建一个。</li><li>server 进程空闲一段时间（默认 3h）后会停止。可以通过  startup option <code>--max_idle_secs</code>) 修改这一选项。<ul><li>不要同时留下太多空闲的 server，可以在执行完成后显示地关闭，或者设置小一点的过期时间。</li></ul></li></ul></li><li>使用 ps x/ ps -e f，Bazel server 进程的名字是 bazel(dirname)。<ul><li>dirname 是包含 workspace 目录根的目录。</li><li>如果用 ps 的其他选项，server 进程名可能只显示 java。</li><li>可以使用 shutdown 命令停止进程：<ul><li>停止前会先检查任务是否完成</li><li>一般没什么用，但是在脚本中很有用，当知道某个构建在特定的workspace 不会再发生。</li><li>接受  <code>--iff_heap_size_greater_than _n_</code>  option，需要输入一个整形的参数（MB）则根据已用内存量设定关闭。</li></ul></li><li>运行 <code>bazel</code> 时，client 首先检查 server 是否是适当的版本；<ul><li>停止旧的 server，启动新 server。</li><li>确保使用长时间运行的 server 进程，不会影响正确的版本。</li></ul></li></ul></li></ul><h1 id="配置构建"><a href="#配置构建" class="headerlink" title="配置构建"></a>配置构建</h1><h2 id="可配置的属性"><a href="#可配置的属性" class="headerlink" title="可配置的属性"></a>可配置的属性</h2><h2 id="与-c-规则集成"><a href="#与-c-规则集成" class="headerlink" title="与 c++ 规则集成"></a>与 c++ 规则集成</h2><h2 id="Toolchain-Resolution-Implementation-Details？no-need"><a href="#Toolchain-Resolution-Implementation-Details？no-need" class="headerlink" title="Toolchain Resolution Implementation Details？no need"></a>Toolchain Resolution Implementation Details？no need</h2><h2 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h2><p>使用 Starlark （domain-specific language：DSL）声明编译目标</p><p>编译目标：具体说明了编译的 输入和依赖，编译规则，以及编译规则的可配置选项</p><p>编译规则：具体说明了Bazel 使用的编译工具（如编译器和链接方法及对应的配置）</p><p>Starlark</p><p>语法和python3类似，支持 None，bool，dict，function，int，list，string，文件为.bzl 后缀。</p><p>偏好不变性，只有 lists 和 dicts 是可变数据结构，但是对可变数据的修改只对当前上下文下创建的对象有效。</p><p>因为Bazel 编译是并行执行，当前文件定义的 list 一旦脱离当前环境，比如被其他文件饮用，则无法再编辑修改。</p><h3 id="BUILD-和-bzl-文件的区别"><a href="#BUILD-和-bzl-文件的区别" class="headerlink" title="BUILD 和 .bzl 文件的区别"></a>BUILD 和 .bzl 文件的区别</h3><p>BUILD 文件通过调用规则注册目标；.bal 文件提供了常量，规则，宏和函数的定义。</p><p>原生函数（native functions）和规则（native rules）在 BUILD 文件中是全局符号；而.bal 文件需要通过 native 模块加载这些函数和规则。</p><p>BUILD 文件中的限制：1）不可声明函数；2）不可使用*args和**kwarg参数。</p><p>BUILD 文件</p><p>大部分 BUILD 文件中只包含编译 rule 的声明，所以顺序是无关的。</p><p>BUILD 中不能包含函数的定义（为了将 code 和 data 分离，但是list comprehension 和 if 表达式是可以的）。函数可以在 .bzl 文件中声明；不允许有 *args 和 **kwargs 参数，需要显示列出所有的参数。</p><p>Starlark 的程序不可以执行任意的IO，因此对 BUILD 文件的解释不受外界影响（只依赖已知的输入，因此输出是可复制的）。</p><p>load</p><p>Bazel 的扩展是以 .bzl 结尾的文件。通过 load 声明从扩展中导入符号。<br>load(“//foo/bar:file.bzl”, “some_library”) ：加载 foo/bar/file.bzl 并将符号 some_library 添加到环境中。这样可以使用新的 rule，function，或者常量（如 string，list 等）。<br>● load 必须在最外层，不可以写在 function 内。<br>● load 的第一个参数表示 .bzl 文件，如果是一个相对的 label，则根据包含当前 bzl 文件的 package 来解析，而不是目录，且此 label 用前置 ：来表示。<br>● load 支持别名，可以给导入的符号分配不同的名字。load(“//foo/bar:file.bzl”, library_alias = “some_library”)<br>● 可以在 load 中同时定义别名和符号：load(“:my_rules.bzl”, “some_rule”, nice_alias = “some_other_rule”) </p><p>.bzl 文件中，对于_开头的符号不会被导入，并且不能从其他文件中加载，目前，可见性不影响加载。</p><p>编译 rule 的类型<br>● *_binary：编译可执行程序<br>● *_test：可依赖其他 libraries。<br>● *_library：指定单独编译的模块。可以依赖其他 libraries，binaries。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bazel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bash_base</title>
      <link href="/2022/04/25/bash-base/"/>
      <url>/2022/04/25/bash-base/</url>
      
        <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>shell维护着一组环境变量，用来记录特定的系统信息。比如系统的名称、登录到系统上的用户名、用户的系统ID（也称为UID）、用户的默认主目录以及shell查找程序的搜索路径。可以用set 命令来显示一份完整的当前环境变量列表。</li><li>只要脚本在引号中出现美元符，它就会以为你在引用一个变量。要显示美元符，你必须在它前面放置一个反斜线。</li></ul><h2 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h2><ul><li>使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。<code>val=$val1</code></li></ul><h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><ul><li>从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。</li><li>命令替换会创建一个子shell来运行对应的命令。子shell（subshell）是由运行该脚本的shell所创建出来的一个独立的子shell（child shell）。正因如此，由该子shell所执行命令是无法使用脚本中所创建的变量的。<ul><li>反引号字符：<code>testing=</code>date``</li><li>$() 格式：：<code>testing=$(date)</code></li></ul></li></ul><h1 id="管道连接（piping）-｜"><a href="#管道连接（piping）-｜" class="headerlink" title="管道连接（piping） ｜"></a>管道连接（piping） ｜</h1><ul><li>Linux系统实际上会同时运行这两个命令，在系统内部将它们连接起来。在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据传输不会用到任何中间文件或缓冲区。</li><li>可以在一条命令中使用任意多条管道。可以持续地将命令的输出通过管道传给其他命令来细化操作。</li><li>用法：<code>ls -al | more</code> 查看长文件列表</li></ul><h1 id="执行数学计算"><a href="#执行数学计算" class="headerlink" title="执行数学计算"></a>执行数学计算</h1><h2 id="expr-命令"><a href="#expr-命令" class="headerlink" title="expr 命令"></a>expr 命令</h2><p>可识别少数的数学和字符串操作符</p><ul><li>数学：+， -， *， /， %</li><li>逻辑运算： ｜， &amp;， &lt;，&lt;=， &gt; &gt;=， !=</li><li>字符串：<ul><li>STRING : REGEXP：如果REGEXP 匹配到了STRING 中的某个模式，返回该模式匹配</li><li>match STRING REGEXP：同上</li><li>substr STRING POS LENGTH：返回起始位置为POS （从1 开始计数）、长度为LENGTH 个字符的子字符</li><li>index STRING CHARS：返回在STRING 中找到CHARS 字符串的位置；否则，返回0</li><li>length STRING：返回字符串 STRING 的数值长度</li><li><ul><li>TOKEN：将 TOKEN 解释成字符串，即使是关键字</li></ul></li><li>(EXPRESSION)：返回 Expression 的值</li></ul></li><li>问题：<ul><li>脚本中使用，需要对 * 等符号做转义，用\： <code>expr 5 \* 2</code></li><li>将一个数学算式的结果赋给一个变量，需要使用命令替换来获取expr 命令的输出：<code>var3=$(expr $var2 / $var1)</code></li></ul></li></ul><h2 id="operation"><a href="#operation" class="headerlink" title="$[ operation ]"></a>$[ operation ]</h2><ul><li>在将一个数学运算结果赋给某个变量时，可以用美元符和方括号<code>$[ operation ]</code>将数学表达式围起来。</li><li>bash shell数学运算符只支持整数运算。z shell 支持完整的浮点数算术操作</li></ul><h1 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h1><ul><li>退出状态码是一个0～255的整数值，在命令结束运行时由命令传给shell。可以捕获这个值并在脚本中使用：<code>echo $?</code><ul><li>如果退出状态码大于 255，最终的结果是指定的数值除以256后得到的余数</li></ul></li><li>默认情况下，shell脚本会以脚本中的最后一个命令的退出状态码退出。<ul><li><code>exit 5</code></li><li><code>exit $val</code>：返回变量</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bash_function</title>
      <link href="/2022/04/23/bash-function/"/>
      <url>/2022/04/23/bash-function/</url>
      
        <content type="html"><![CDATA[<h1 id="创建-使用函数"><a href="#创建-使用函数" class="headerlink" title="创建/使用函数"></a>创建/使用函数</h1><pre><code class="bash">function func &#123;    cmds&#125;# another methodfunc() &#123;    cmds&#125;</code></pre><ol><li><p>函数使用必须在定义后了；函数名是唯一的</p></li><li><p>函数执行退出后，用标准变量 <code>$?</code> 确定函数的退出状态码</p><ul><li>只看最后一条语句，所以无法判断中间是否执行成功</li><li>函数退出后要马上用，否则就是其他语句的状态码了<ul><li>使用 return 命令 退出函数并返回特定的退出状态码，return 命令中可指定一个整数值（范围：0-255，返回后必须要马上取返回值。</li><li>使用 exit n</li></ul></li></ul></li><li><p>使用函数输出：函数用 <code>echo</code> 语句显示计算的结果，调用方可获取到此结果。如：</p><pre><code class="bash">function fun1 &#123;    echo $[ $val * 2 ]&#125;result=$(fun1) # `fun1` 也可以，叫做命令替换，这里用来使用函数的输出</code></pre></li></ol><h1 id="函数中使用变量"><a href="#函数中使用变量" class="headerlink" title="函数中使用变量"></a>函数中使用变量</h1><h2 id="向函数传递参数"><a href="#向函数传递参数" class="headerlink" title="向函数传递参数"></a>向函数传递参数</h2><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>#linux shell 字符串作变量名 间接变量引用 evel<br><a href="https://blog.csdn.net/whatday/article/details/105466009">https://blog.csdn.net/whatday/article/details/105466009</a><br><a href="https://blog.csdn.net/whatday/article/details/105459629">https://blog.csdn.net/whatday/article/details/105459629</a></p><p>#Shell 单引号’’ 双引号”” 反引号`` 和$()的区别和用法<br><a href="https://zhuanlan.zhihu.com/p/91663627">https://zhuanlan.zhihu.com/p/91663627</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bash_if</title>
      <link href="/2022/04/23/bash-if/"/>
      <url>/2022/04/23/bash-if/</url>
      
        <content type="html"><![CDATA[<h1 id="if-判断是普通命令"><a href="#if-判断是普通命令" class="headerlink" title="if 判断是普通命令"></a>if 判断是普通命令</h1><h2 id="if-then-语句"><a href="#if-then-语句" class="headerlink" title="if-then 语句"></a>if-then 语句</h2><pre><code class="bash">if cmd then    cmdsfi###if cmd; then    cmdsfi</code></pre><ol><li>根据 cmd 命令退出状态码确定是否执行then</li><li>这里的 cmd 就是 pwd，grep 之类的命令</li></ol><h2 id="if-then-else-语句"><a href="#if-then-else-语句" class="headerlink" title="if-then_else 语句"></a>if-then_else 语句</h2><pre><code class="bash">if cmd then    cmdselse    cmdsfi</code></pre><h2 id="嵌套-if"><a href="#嵌套-if" class="headerlink" title="嵌套 if"></a>嵌套 if</h2><pre><code class="bash">if cmd1then    cmdselif cmd2then    cmdsfi</code></pre><h1 id="test-命令"><a href="#test-命令" class="headerlink" title="test 命令"></a>test 命令</h1><p>if-then 语句不能测试命令退出状态码之外的条件。</p><pre><code class="bash">if test conditionsthen    cmdsfi</code></pre><ol><li>test 会测试不同的条件，如果成立，则推出并返回退出状态码0</li><li>conditions 是test 命令要测试的一系列参数和值，当为空时，test 返回非0。可以用来测试某个变量是否有值</li></ol><h1 id=""><a href="#" class="headerlink" title="[]"></a>[]</h1><p>[] 类似 test 命令，可以判断三类条件：</p><ol><li>数值比较：使用文本比较，用数学符号可能被解析为字符串从而得到错误的结果。（很神奇，执行数学运算，又是直接用 <code>$[ $val + $val2 ]</code> 等数学符号<ul><li>bash 只能处理整数，如果只用 echo 显示结果没限制 <code>if [ $val1 -eq $val2 ]</code></li></ul></li><li>字符串比较：使用标准的数学比较符号，如 &lt;， &gt;， = 等<ul><li>比较字符串的相等性，测试会将所有的标点和大小写考虑在内 <code>if [ $val1 != $val2 ]</code></li><li>字符串顺序<ul><li>大于小于号必须转义，否则会被当作转义符 <code>if [ $val1 \&lt; $val2 ]</code></li><li>使用 ascii 顺序：大写字母比小写字母小，而 bash 的 sort 命令是按照系统本地化语言定义的排序顺序，即小写在大写前面</li></ul></li><li>字符串大小<ul><li><code>if [ -z $val ]</code> 判断 $val 的长度是否为 0，从而判断字符串是否为空，为空返回 true</li><li><code>if [ -n $val ]</code> 字符串不为空则返回 true，未被定义过的也为空</li><li>使用未定义/未初始化的变量不好，所以在用于数值/字符串比较之前，需要用 -n/-z 先测试下变量是否有值</li></ul></li></ul></li><li>文件比较：测试 Linux 文件系统上文件和目录的状态<ul><li><code>-d</code>：file 是否存在并且是目录</li><li><code>-e</code>：file 是否存在</li><li><code>-f</code>：file 存在 &amp; 是文件</li><li><code>-r</code>：存在 &amp; 可读</li><li><code>-s</code>：存在 &amp; 非空</li><li><code>-w</code>：存在 &amp; 可写</li><li><code>-x</code>：存在 &amp; 可执行</li><li><code>-O</code>：存在 &amp; 属当前用户所有</li><li><code>-G</code>：存在 &amp; 默认组与当前用户相同</li><li><code>file1 nt file2</code>：检查 1 是否比 2 新</li><li><code>file1 ot file2</code>：verse</li></ul></li></ol><h1 id="复合条件测试"><a href="#复合条件测试" class="headerlink" title="复合条件测试"></a>复合条件测试</h1><ol><li>[ condation1 ] &amp;&amp; [ condation2 ]</li><li>[ condation1 ] || [ condation2 ]</li></ol><h1 id="用于数学表达式"><a href="#用于数学表达式" class="headerlink" title="(()) 用于数学表达式"></a>(()) 用于数学表达式</h1><p>(( expression ))：exp 可以是任意的数学赋值或表达式，不需要将表达式计算符号（&gt;, &lt; 之类的做转义，相比 test 命令更高级）</p><ul><li>val++, val–, ++val, –val, </li><li>! 逻辑去反</li><li>~ 位取反</li><li>** 幂运算</li><li>&lt;&lt; , &gt;&gt;： 位移</li><li>&amp;, |：位布尔和/或</li><li>&amp;&amp;, ||：逻辑和/或</li></ul><h1 id="用于高级字符串处理"><a href="#用于高级字符串处理" class="headerlink" title="[[]] 用于高级字符串处理"></a>[[]] 用于高级字符串处理</h1><p>[[ expression ]]</p><ul><li>除了 test 中支持的功能外，还支持模式匹配</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>generic_algorithm</title>
      <link href="/2022/02/19/generic-algorithm/"/>
      <url>/2022/02/19/generic-algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>头文件：algorithm，numeric（数值泛型算法，累加之类的数值运算？）</p><ul><li>泛型算法（generic algorithm）<ul><li>算法：实现了经典算法的公共接口，如排序，搜索</li><li>泛型的：可以用于不同类型的元素和多种容器类型（如标准库类型 vector，list，内置数组类型，or 其他）</li></ul></li></ul><ul><li>一般情况下，算法不直接操作容器，运行在迭代器上，执行迭代器的操作<ul><li>迭代器令算法不依赖于容器类型 -&gt; 迭代器操作元素 </li><li><strong>算法依赖元素类型上可发生的操作</strong> -&gt; 比如比较大小，内置元素类型有 &gt;，&lt; ，自定义类型需要自定义操作运算符，从而让算法可操作</li><li>编程假设：<strong>算法</strong>不改变底层容器的大小<ul><li>可读，修改，移动元素</li><li>由<strong>插入迭代器</strong>，完成向容器中添加元素</li></ul></li></ul></li></ul><ul><li>一般情况下，标准库算法对一个范围内的元素进行操作，此范围称作“输入范围”，由两个参数表示：指向要处理的第一个元素和尾元素之后的迭代器</li></ul><h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>算法遍历输入范围的方式相同，但是使用范围中元素的方式不同。</p><h2 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h2><ul><li>find</li><li>count</li><li>accumulate(beg,end,init_val)<ul><li>init_val 决定了函数使用哪个加法运算符以及返回值的类型</li><li>编程假设：将元素类型加到和的类型上的操作必须是可行的</li><li>自定义对象操作吗？ 和 运算符时怎么用？只要类定义了操作就可以了吧？</li></ul></li><li>equal：用于确定两个序列是否有相同的值<ul><li>只要两个序列的元素可以用==比较即可</li><li>假设：第二个序列至少和第一个序列一样长</li></ul></li></ul><h2 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h2><ol><li>被写入的序列大小，不小于要写入的元素个数（空vector不可以直接fill，除非用了back_inserter）</li><li>不改变容器的大小</li></ol><ul><li>fill(beg,end,val)</li><li>fill_n(dest,n,val)<ul><li>假定 dest 指向一个元素，从 dest开始的序列至少包含 n 个</li></ul></li><li>back_inserter<ul><li>fill_n(back_inserter(vec),10,0);</li></ul></li><li>copy</li><li>replace</li><li>replace_copy<ul><li>不改变原序列</li></ul></li></ul><h2 id="重排容器元素"><a href="#重排容器元素" class="headerlink" title="重排容器元素"></a>重排容器元素</h2><ul><li>sort</li><li>stable_sort：维持相等元素的原有顺序</li><li>uniq<ul><li>返回的迭代器指向最后一个不重复元素之后的位置，此位置之后的元素依然存在，但是我们不知道他的值是什么。</li></ul></li></ul><h1 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h1><ol><li>希望的操作方式与默认的不同，如sort默认用升序，想用降序</li><li>我们的序列保存了未定义运算符的元素类型（如 SaleData 自定义数据结构）</li></ol><h2 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h2><ul><li>谓词（predicate）：可调用的表达式，其返回结果是可用于做条件的值。<ul><li>一元谓词（unary）：只接受单一参数</li><li>二元谓词（binary）：两个参数</li></ul></li></ul><p>算法接受谓词作为第三个参数，对序列中的元素调用谓词，因此元素类型必须能转换为谓词的参数类型</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>lambda</title>
      <link href="/2022/02/15/lambda/"/>
      <url>/2022/02/15/lambda/</url>
      
        <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>算法可接受一元谓词/二元谓词，传递给算法的函数必须只有1/2个参数。局限性：算法只支持1个/2参数，而需要传入2/3+个参数。需要其他特性满足需求。</p><p>可向算法传递任何类别的可调用对象。</p><ul><li>可调用对象（callable object）：对于一个对象或者表达式，如果可以<strong>对其使用调用运算符</strong>，即()，则称为可调用的。<ul><li>谓词是可调用表达式</li><li>函数</li><li>函数指针</li><li>重载了函数调用运算符的类</li><li>lambda 表达式<ul><li>表示可调用的代码单元，可理解为未命名的内联函数</li><li>与函数类似，不同在于：可能定义在函数内部</li></ul></li></ul></li></ul><h1 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h1><p>格式 <code>[capture list] (parameter list) -&gt; return type &#123; function body &#125;</code></p><ul><li>[capture list] lambda 所在函数中定义的局部变量的列表<ul><li>lambda 将局部变量包含在其捕获列表中明确表示将会使用这些变量。</li><li>只有捕获了函数的局部变量，才能在lambda 的函数体中使用该变量。</li><li>lambda 可以直接使用局部 static 变量和他它在函数之外声明的名字。</li><li>值捕获：<ul><li>捕获的变量必须可拷贝。</li><li>函数传值参数类似，区别在于：被捕获的变量是在 lambda 创建时拷贝的，而不是调用时。<pre><code class="cpp">void fcn1 &#123;  size_t v1 = 42;  auto f = [v1] &#123;return v1;&#125;;  v1 = 0;  audo j = f(); // j = 42，保存了创建 lambda 时 v1 的拷贝&#125;</code></pre></li><li>值被拷贝的变量，lambda 不会改变其值，如果希望改变捕获的变量，必须在参数列表首加上关键字 <code>mutable</code>。因此可变 lambda 可省略参数列表。</li></ul></li><li>引用捕获<ul><li>与返回引用的限制和问题一致：需要确保 lambda 执行时所引用（指针/迭代器指向）的对象确实存在。因为 lambda 捕获的都是局部变量，如果在函数外使用此 lambda，引用捕获原函数的局部变量已经消失了，所以有问题。</li><li>函数可直接返回可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回了 lambda，与函数不能返回一个局部变量的引用类似，此lambda 不可以包含引用的捕获。</li><li>如果可能，应该避免捕获指指针/引用。</li><li>引用的变量是否可变取决于此引用指向的是否为 const 类型。</li></ul></li><li>显示捕获<ul><li>明确写出要捕获哪个变量。</li></ul></li><li>隐式捕获<ul><li>由编译器根据 lambda 体中的代码推断我们要使用哪些变量。</li><li>&amp; ： 引用捕获， = ：值捕获。</li></ul></li><li>显示和隐式捕获可以同时使用，此时隐式捕获 &amp;/= 作为捕获列表的第一个元素，后面的显示捕获必须使用和隐式捕获不同的方式。</li></ul></li></ul><ul><li>尾置返回类型<ul><li>其他普通函数中，当返回类型比较复杂（如数组的指针or引用时也使用）auto f() -&gt; int(*)[10] {}</li></ul></li><li>必须包含：<code>[capture list]</code> 和 <code>&#123; function body &#125;</code><ul><li><code>auto f = [] &#123;return 42;&#125;</code> 只有 return 语句，返回类型从返回的表达式推断而来，<ul><li><code>&#123; function body &#125;</code> 中包含任何其他语句，且未指定返回类型时，则默认返回 void</li></ul></li></ul></li></ul><h2 id="lambda-是函数对象"><a href="#lambda-是函数对象" class="headerlink" title="lambda 是函数对象"></a>lambda 是函数对象</h2><p>当定义 lambda 时，编辑器会生成一个与 lambda 对应的新的（未命名）的新类型。</p><ul><li>该类中有重载的函数调用运算符</li><li>该类中必须为每个值捕获的变量建立数据成员，并作为构造函数的参数初始化</li><li>对于 lambda 通过引用捕获的变化，程序负责确保 lambda 执行时所引用的对象确实存在，因此编译器可以直接使用该引用而无需存储为数据成员</li><li>此类中不包含默认构造函数，赋值运算符及默认的析构函数，是否包含拷贝/移动构造函数通常需要视捕获的数据成员类型而定</li></ul><p>向一个函数传递 lambda 时，同时定义了一个新类型和该类型的一个对象，传递的参数就是此编译器生成的类类型的未命名对象。</p><p>使用 auto 定义用 lambda 初始化的变量时，定义了一个从 lambda 生成的类型的对象。</p><h1 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当算法只支持一元谓词，而功能必须用 2 个参数时，可以将有2个参数的可调用对象适配为1个参数的可调用对象。</p><p>如果 lambda 的捕获列表为空，通常可以使用函数来替代它。</p><ol><li>如果需要很多地方使用相同的操作，应该定义为函数。</li><li>如果一个操作要访问很多语句才能完成，使用函数更好</li></ol><p>可将 bind 看作是通用的<strong>函数适配器</strong>，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</p><ul><li><strong>适配器</strong>是标准库中的通用概念，本质上是一种机制，能使某种事物的行为看起来像另一种事物一样。<ul><li>容器适配器：接受一种已有的容器类型，使其行为看起来像一种不同的类型</li><li>顺序容器适配器：stack，queue，priority_queue</li></ul></li></ul><h2 id="bind-使用"><a href="#bind-使用" class="headerlink" title="bind 使用"></a>bind 使用</h2><p>头文件：<code>functional</code></p><p>一般形式：<code>auto newCallable = bind(callable, arg_list);</code></p><p>arg_list 是 callable 的参数。当调用 newCallable 时，newCallable 会调用 callable，并传递给 arg_list 的参数。</p><p>arg_list 中的参数可能包含形如 <code>_n</code> 的参数，<code>_n</code> 是一个参数，表示“占位符（placeholder）”，是 newCallable 的参数，n 表示在 newCallable 中参数的位置。如 <code>_1/_2</code> 是 newCallable 的第一/二个参数，依次类推。</p><p>使用占位符(<code>_n</code>)时需要引入命名空间：<code>using namespace std::placeholders;</code>。头文件 <code>functiondal</code>。</p><h2 id="bind-的参数"><a href="#bind-的参数" class="headerlink" title="bind 的参数"></a>bind 的参数</h2><p>可以用 bind 重排参数顺序：</p><ul><li>传给 g 的参数按位置绑定到占位符，即：第一个参数绑定到 _1，第二个参数绑定到 _2。当调用f时，按照 f 中的顺序放置。<pre><code class="cpp">auto g = bind(f, a, b, _2, c, _1);g(X, Y);f(a, b, Y, c, X);</code></pre></li></ul><p>绑定引用参数：</p><ul><li><p>默认情况下，bind 中非占位符的参数被拷贝到 callable 中，但是，与 lambda 类似，有些参数 1）希望以引用的方式传递；2）要绑定的类型无法拷贝。</p><pre><code class="cpp">for_each(words.begin(), words.end(),  [&amp;os,c](const string&amp; s) &#123; os &lt;&lt; s &lt;&lt; c;&#125;);========&gt;ostream &amp;print(ostream &amp;os, const string&amp; s, char c) &#123;    os &lt;&lt;s &lt;&lt; c;&#125;for_each(words.begin(), words.end(), bind(print, os, _1, &#39; &#39;)); // 有误， ostream 是可不拷贝的====&gt; for_each(words.begin(), words.end(), bind(print, std::ref(os), _1, &#39; &#39;));</code></pre></li></ul><p>如果我们希望传递给 bind 一个对象而又不拷贝它，必须使用标准库 ref 函数。</p><ul><li>ref 函数返回一个对象，包含给定的引用，此对象是可拷贝的。</li><li>cref 函数生成保存 const 引用的类。</li><li>ref，cref 定义在头文件 <code>functional</code> 中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>smart_ptr</title>
      <link href="/2022/02/15/smart-ptr/"/>
      <url>/2022/02/15/smart-ptr/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>namespace</title>
      <link href="/2022/02/15/namespace/"/>
      <url>/2022/02/15/namespace/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gccVSg++</title>
      <link href="/2022/02/14/gccVSg/"/>
      <url>/2022/02/14/gccVSg/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>我们在编译c/c++代码的时候，有人用gcc，有人用g++，于是各种说法都来了，譬如c代码用gcc，而c++代码用g++，或者说编译用gcc，链接用g++，一时也不知哪个说法正确，如果再遇上个extern “C”，分歧就更多了，这里我想作个了结，毕竟知识的目的是令人更清醒，而不是更糊涂。</p><p>gcc and g++ are compiler-drivers of the <strong>GNU Compiler Collection</strong> (which was once upon a time just the GNU C Compiler).</p><p>GNU Compiler Collection： Referrers to all the different languages that are supported by the GNU compiler.</p><p>gcc: GNU C   Compiler</p><p>g++: GNU C++ Compiler</p><p>当使用编译工具时，自动根据文件类型，来决定调用哪个后台程序，此时会有点差别，（但是可以通过 <code>-x 语言</code> 这个参数来覆盖这个规定）</p><p>The probably most important difference in their defaults is which libraries they link against automatically.</p><p>According to GCC’s online documentation link options and how g++ is invoked, g++ is equivalent to gcc -xc++ -lstdc++ -shared-libgcc (the 1st is a compiler option, the 2nd two are linker options). This can be checked by running both with the -v option (it displays the backend toolchain commands being run).</p><h2 id="误区一-gcc只能编译c代码-g-只能编译c-代码"><a href="#误区一-gcc只能编译c代码-g-只能编译c-代码" class="headerlink" title="误区一:gcc只能编译c代码,g++只能编译c++代码"></a>误区一:gcc只能编译c代码,g++只能编译c++代码</h2><p>结论：两者都可以，但是请注意：</p><ol><li>gcc 在编译 <code>*.c\*.cpp</code> 文件时，分别以 C 和 C++ 的方式编译。</li><li>g++ 也可以编译 <code>*.c\*.cpp</code> 文件，认为文件都是 cpp 的。</li><li>如果使用 g++ 链接对象文件，会自动链接 std C++ 库，而 gcc 不会做这个，此时可以通过 <code>gcc -lstdc++</code> 参数来链接 c++ std 库。</li><li>gcc 编译 C 文件没有预定义的宏（has fewer predefined macros.）</li><li>gcc 编译 <code>*.cpp</code> and g++ 编译 <code>*.c\*.cpp</code> 文件时，有一些额外的宏( has a few xtra macros.)</li></ol><p>Extra Macros when compiling *.cpp files:</p><pre><code class="cpp">#define __GXX_WEAK__ 1#define __cplusplus 1#define __DEPRECATED 1#define __GNUG__ 4#define __EXCEPTIONS 1#define __private_extern__ extern</code></pre><ol start="6"><li>后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；</li><li>后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的，例如下面的代码：<ul><li><del>如果按照C的语法规则，OK，没问题，但是，一旦把后缀改为cpp，立刻报三个错：这3个错分别对应前面红色标注的部分。可见C++的语法规则更加严谨一些。</del></li><li>但是实操后发现，后缀为 .c 时，不论是gcc还是g++都是报错，但是错误的中间一句不一样，gcc 认为是隐式转换，g++ 认为是未声明</li><li></li></ul></li><li>编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C++程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。</li></ol><pre><code class="c">#include &lt;stdio.h&gt;int main(int argc, char* argv[]) &#123;   if(argv == 0) return;   printString(argv);   return;&#125;int printString(char* string) &#123;  sprintf(string, &quot;This is a test.\n&quot;);&#125;</code></pre><p>gcc</p><p><img src="https://s2.loli.net/2023/03/12/7wpXANZvKlQOSxj.png" alt="截屏2023-03-12 22.26.45.png"></p><p>g++</p><p><img src="https://s2.loli.net/2023/03/12/xQ4dHVyzakq3BvK.png" alt="截屏2023-03-12 22.27.08.png"></p><p>cpp 后缀<br><img src="https://s2.loli.net/2023/03/12/GiLfmHuCh2wePK3.png" alt="截屏2023-03-12 22.31.51.png"></p><h2 id="误区二-gcc不会定义-cplusplus宏，而g-会"><a href="#误区二-gcc不会定义-cplusplus宏，而g-会" class="headerlink" title="误区二:gcc不会定义__cplusplus宏，而g++会"></a>误区二:gcc不会定义__cplusplus宏，而g++会</h2><p>实际上，这个宏只是标志着编译器将会把代码按C还是C++语法来解释，如上所述，如果后缀为.c，并且采用gcc编译器，则该宏就是未定义的，否则，就是已定义。</p><h2 id="误区三-编译只能用gcc，链接只能用g"><a href="#误区三-编译只能用gcc，链接只能用g" class="headerlink" title="误区三:编译只能用gcc，链接只能用g++"></a>误区三:编译只能用gcc，链接只能用g++</h2><p>严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。</p><p>因为gcc命令不能自动和C++程序使用的库联接，所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，<strong>g++ is equivalent to gcc -xc++ -lstdc++ -shared-libgcc</strong> <a href="https://stackoverflow.com/questions/172587/what-is-the-difference-between-g-and-gcc">参考</a></p><h2 id="误区四-extern-“C”与gcc-g-有关系"><a href="#误区四-extern-“C”与gcc-g-有关系" class="headerlink" title="误区四:extern “C”与gcc/g++有关系"></a>误区四:extern “C”与gcc/g++有关系</h2><p>实际上并无关系，无论是gcc还是g++，用extern “c”时，都是以C的命名方式来为symbol命名，否则，都以c++方式命名。试验如下：<br>me.h：<br>extern “C” void CppPrintf(void);</p><p>me.cpp:<br>#include <iostream><br>#include “me.h”<br>using namespace std;<br>void CppPrintf(void)<br>{<br>     cout &lt;&lt; “Hello\n”;<br>}</p><p>test.cpp:<br>#include &lt;stdlib.h&gt;<br>#include &lt;stdio.h&gt;<br>#include “me.h”<br>int main(void)<br>{<br>    CppPrintf();<br>    return 0;<br>}</p><ol><li>先给me.h加上extern “C”，看用gcc和g++命名有什么不同<br>[root@root G++]# g++ -S me.cpp     //g++的参数-S： 是指把文件编译成为汇编代码<br>[root@root G++]# less me.s<br>.globl _Z9CppPrintfv        //注意此函数的命名<pre><code> .type   CppPrintf, @function</code></pre></li></ol><p>[root@root GCC]# gcc -S me.cpp<br>[root@root GCC]# less me.s<br>.globl _Z9CppPrintfv        //注意此函数的命名<br>        .type   CppPrintf, @function<br>完全相同！</p><ol start="2"><li>去掉me.h中extern “C”，看用gcc和g++命名有什么不同<br>[root@root GCC]# gcc -S me.cpp<br>[root@root GCC]# less me.s<br>.globl _Z9CppPrintfv        //注意此函数的命名<pre><code> .type   _Z9CppPrintfv, @function</code></pre></li></ol><p>[root@root G++]# g++ -S me.cpp<br>[root@root G++]# less me.s<br>.globl _Z9CppPrintfv        //注意此函数的命名<br>        .type   _Z9CppPrintfv, @function<br>完全相同！</p><p>【结论】完全相同，可见extern “C”与采用gcc/g++并无关系，以上的试验还间接的印证了前面的说法：在编译阶段，g++是调用gcc的。</p><blockquote><p>摘自 <a href="https://blog.csdn.net/tjcwt2011/article/details/103410446">https://blog.csdn.net/tjcwt2011/article/details/103410446</a><br>部分参考 <a href="https://stackoverflow.com/questions/172587/what-is-the-difference-between-g-and-gcc">stackoverflow</a> 上的回答</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>regex</title>
      <link href="/2022/02/13/regex/"/>
      <url>/2022/02/13/regex/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>正则表达式是你所定义的模式模板 （pattern template），Linux工具可以用它来过滤文本。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>Linux中的不同应用程序可能会用不同类型的正则表达式。</p><p>正则表达式是通过正则表达式引擎 （regular expression engine）实现的。</p><p>正则表达式引擎是一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配。</p><p>在Linux中，有两种流行的正则表达式引擎：</p><ol><li>POSIX基础正则表达式（basic regular expression，BRE）引擎。 <ul><li>大多数Linux工具都至少符合POSIX BRE引擎规范，能够识别该规范定义的所有模式符号。</li><li>有些工具（比如sed编辑器）只符合了BRE引擎规范的子集。这是出于速度方面的考虑导致的，因为<strong>sed编辑器希望能尽可能快地处理数据流中的文本</strong>）。</li></ul></li><li>POSIX扩展正则表达式（extended regular expression，ERE）引擎。<ul><li>gawk程序用ERE引擎来处理它的正则表达式模式。</li></ul></li></ol><h1 id="BRE"><a href="#BRE" class="headerlink" title="BRE"></a>BRE</h1><h2 id="文本字符"><a href="#文本字符" class="headerlink" title="文本字符"></a>文本字符</h2><p>最基本的BRE模式是匹配数据流中的文本字符。</p><pre><code>$ echo &quot;This is a test&quot; | sed -n &#39;/test/p$ echo &quot;This is a test&quot; | gawk &#39;/test/&#123;print $0&#125;&#39;This is a test”</code></pre><ul><li>正则表达式并不关心模式在数据流中的位置。它也不关心模式出现了多少次。一旦正则表达式匹配了文本字符串中任意位置上的模式，它就会将该字符串传回Linux工具。</li><li>正则表达式模式都区分大小写。</li><li>可以在正则表达式中使用空格和数字。<ul><li>如果你在正则表达式中定义了空格，那么它必须出现在数据流中。甚至可以创建匹配多个连续空格的正则表达式模式。<code>$ sed -n &#39;/  /p&#39; data1</code></li></ul></li></ul><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p><code>.*[]^$&#123;&#125;\+?|()</code></p><p>如果要用某个特殊字符作为文本字符，就必须转义——用反斜线（\） 。</p><ul><li>要使用正斜线，也需要进行转义。</li></ul><h2 id="锚字符"><a href="#锚字符" class="headerlink" title="锚字符"></a>锚字符</h2><ol><li><p>脱字符（<code>^</code>）<strong>定义从数据流中文本行的行首开始的模式</strong>。如果模式出现在行首之外的位置，正则表达式模式则无法匹配。要用脱字符，就必须将它放在正则表达式中指定的模式前面。</p><pre><code>$ echo &quot;Books are great&quot; | sed -n &#39;/^Book/p&#39;Books are great</code></pre><ul><li>脱字符会在每个由换行符决定的新数据行的行首检查模式。只要模式出现在新行的行首，脱字符就能够发现它。</li><li>如果你将脱字符放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了。</li><li>如果指定正则表达式模式时只用了脱字符，就不需要用反斜线来转义。</li><li>但如果你在模式中先指定了脱字符，随后还有其他一些文本，那么你必须在脱字符前用转义字符。？</li></ul></li><li><p>特殊字符美元符（<code>$</code>）定义了<strong>行尾锚点</strong>。将这个特殊字符放在文本模式之后来指明数据行必须以该文本模式结尾。 <code>$ echo &quot;This is a good book&quot; | sed -n &#39;/book$/p</code></p></li><li><p>两种字符组合<br>在一些常见情况下，可以在同一行中将行首锚点和行尾锚点组合在一起使用。比如<strong>过滤出数据流中的空白行。</strong> <code>$ sed &#39;/^$/d&#39; data5</code></p></li></ol><h2 id="点号字符"><a href="#点号字符" class="headerlink" title="点号字符"></a>点号字符</h2><p>点号用来匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字符的位置没有字符，那么模式就不成立。<code>$ sed -n &#39;/.at/p&#39; data6</code></p><h2 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h2><p>使用方括号来定义一个字符组。方括号中包含所有你希望出现在该字符组中的字符。相对于点字符，能限定待匹配的字母。<br>如果字符组中的某个字符出现在了数据流中，那它就匹配了该模式。</p><ul><li>字符组中必须有个字符来匹配相应的位置。<code>$ echo &quot;Yes&quot; | sed -n &#39;/[Yy]es/p&#39;</code></li><li>字符组不必只含有字母，也可以在其中使用数字。 <code>$ sed -n &#39;/[0123]/p&#39; data7</code></li></ul><h3 id="排除型字符组"><a href="#排除型字符组" class="headerlink" title="排除型字符组"></a>排除型字符组</h3><p>在正则表达式模式中，也可以反转字符组的作用。可以寻找组中没有的字符，而不是去寻找组中含有的字符。要这么做的话，只要在字符组的开头加个脱字符。</p><pre><code>$ sed -n &#39;/[^ch]at/p&#39; data6This test is at line four.</code></pre><h2 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h2><p>可以用单破折线符号在字符组中表示字符区间。</p><ul><li>只需要指定区间的第一个字符、单破折线以及区间的最后一个字符就行了。</li><li>还可以在单个字符组指定多个不连续的区间。<pre><code>$ sed -n &#39;/^[0-9][0-9][0-9][0-9][0-9]$/p&#39; data8 // 数字$ sed -n &#39;/[c-h]at/p&#39; data6  // 字母$ sed -n &#39;/[a-ch-m]at/p&#39; data6</code></pre></li></ul><h2 id="特殊的字符组"><a href="#特殊的字符组" class="headerlink" title="特殊的字符组"></a>特殊的字符组</h2><p><img src="https://s2.loli.net/2022/02/14/xt6AMXLDSKrhinB.png" alt="BRE.png"></p><h2 id="星号"><a href="#星号" class="headerlink" title="星号"></a>星号</h2><p>在字符后面放置星号表明该字符必须在匹配模式的文本中出现<strong>0次或多次</strong>。</p><p>点号特殊字符和星号特殊字符组合起来。<strong>这个组合能够匹配任意数量的任意字符</strong>。它通常用在数据流中两个可能相邻或不相邻的文本字符串之间。</p><h1 id="扩展正则表达式-ERE"><a href="#扩展正则表达式-ERE" class="headerlink" title="扩展正则表达式 ERE"></a>扩展正则表达式 ERE</h1><p>POSIX ERE模式包括了一些可供Linux应用和工具使用的额外符号。<strong>gawk程序能够识别ERE模式，但sed编辑器不能。</strong></p><p>警告记住，sed编辑器和gawk程序的正则表达式引擎之间是有区别的。gawk程序可以使用大多数扩展正则表达式模式符号，并且能提供一些额外过滤功能，而这些功能都是sed编辑器所不具备的。但正因为如此，<strong>gawk程序在处理数据流时通常才比较慢</strong>。</p><h2 id="问号"><a href="#问号" class="headerlink" title="问号"></a>问号</h2><p>问号表明前面的字符<strong>可以出现0次或1次，但只限于此</strong>。它不会匹配多次出现的字符。</p><p>与星号一样，你可以将问号和字符组一起使用。<code>$ echo &quot;bt&quot; | gawk &#39;/b[ae]?t/&#123;print $0&#125;</code></p><h2 id="加号"><a href="#加号" class="headerlink" title="加号"></a>加号</h2><p>加号表明前面的字符<strong>可以出现1次或多次，但必须至少出现1次</strong>。如果该字符没有出现，那么模式就不会匹配。</p><h2 id="花括号"><a href="#花括号" class="headerlink" title="花括号"></a>花括号</h2><p>ERE中的花括号允许你<strong>为可重复的正则表达式指定一个上限</strong>。这通常称为<strong>间隔 （interval）</strong>。可以用两种格式来指定区间。</p><ul><li>m ：正则表达式准确出现m 次。</li><li>m, n ：正则表达式至少出现m 次，至多n 次。</li><li>默认情况下，gawk程序不会识别正则表达式间隔。必须指定gawk程序的–re-interval 命令行选项才能识别正则表达式间隔。</li></ul><pre><code>$ echo &quot;bet&quot; | gawk --re-interval &#39;/be&#123;1,2&#125;t/&#123;print $0&#125;&#39;bet$ echo &quot;bat&quot; | gawk --re-interval &#39;/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;&#39;bat</code></pre><h2 id="管道符号"><a href="#管道符号" class="headerlink" title="管道符号"></a>管道符号</h2><p>管道符号允许你在检查数据流时，用逻辑OR 方式指定正则表达式引擎要用的两个或多个模式。如果任何一个模式匹配了数据流文本，文本就通过测试。如果没有模式匹配，则数据流文本匹配失败。</p><p><code>$ echo &quot;The cat is asleep&quot; | gawk &#39;/cat|dog/&#123;print $0&#125;</code></p><h2 id="表达式分组"><a href="#表达式分组" class="headerlink" title="表达式分组"></a>表达式分组</h2><p>正则表达式模式也可以用圆括号进行分组。当你将正则表达式模式分组时，该组会被视为一个标准字符。可以像对普通字符一样给该组使用特殊字符。</p><pre><code>$ echo &quot;Saturday&quot; | gawk &#39;/Sat(urday)?/&#123;print $0&#125;&#39;Saturday</code></pre><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><pre><code>#!/bin/bashgawk --re-interval &#39;/^\(?[2-9][0-9]&#123;2&#125;\)?(| |-|\.)[0-9]&#123;3&#125;( |-|\. )[0-9]&#123;4&#125;/&#123;print $0&#125;&#39;echo &quot;317-555-1234&quot; | ./isphone</code></pre><h1 id="引用-参考"><a href="#引用-参考" class="headerlink" title="引用/参考"></a>引用/参考</h1><p>摘录来自: [美] Richard Blum. “Linux命令行与shell脚本编程大全（第3版）。” Apple Books. </p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chore</title>
      <link href="/2022/02/08/chore/"/>
      <url>/2022/02/08/chore/</url>
      
        <content type="html"><![CDATA[<p> todo</p><ul><li><p> 开发时先写总逻辑，再加日志，监控之类的，以防太多日志代码搞混</p></li><li><p>公司各种服务说明文档都提供了http请求的例子，但是对http请求的构成不熟悉，不仅限制了对已有例子实操，也阻碍了在业务代码中使用和开发。</p><ul><li>get 和 post：<ul><li> <a href="https://www.zhihu.com/question/28586791">https://www.zhihu.com/question/28586791</a></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sed</title>
      <link href="/2022/01/10/sed/"/>
      <url>/2022/01/10/sed/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><p>shell脚本最常见的一个用途就是<strong>处理文本文件。检查日志文件、读取配置文件、处理数据元素</strong>，shell脚本可以帮助我们将文本文件中各种数据的日常处理任务自动化。但仅靠shell脚本命令来处理文本文件的内容有点勉为其难。</p><p>如果<u>想在shell脚本中处理任何类型的数据</u>，你得熟悉Linux中的sed和gawk工具。这两个工具能够极大简化需要进行的数据处理任务。</p><h1 id="sed-编辑器简介"><a href="#sed-编辑器简介" class="headerlink" title="sed 编辑器简介"></a>sed 编辑器简介</h1><ul><li><strong>sed编辑器</strong>被称作流编辑器 （stream editor），流编辑器会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。</li><li>在交互式文本编辑器中（比如vim），你可以用键盘命令来交互式地插入、删除或替换数据中的文本。</li></ul><p>sed编辑器可以<strong>根据命令来处理数据流中的数据</strong>，这些命令要么从命令行中输入，要么存储在一个命令文本文件中。在流编辑器<strong>将所有命令与一行数据匹配完毕后，它会读取下一行数据并重复这个过程。</strong>在流编辑器处理完流中的所有数据行后，它就会终止。</p><p>sed编辑器会执行下列操作：</p><ol><li>一次从输入中读取一行数据。</li><li>根据所提供的编辑器命令匹配数据。</li><li>按照命令修改流中的数据。</li><li>将新的数据输出到STDOUT 。</li></ol><h2 id="sed-命令"><a href="#sed-命令" class="headerlink" title="sed 命令"></a>sed 命令</h2><p>格式：<code>sed options script file</code></p><ul><li>options 选项允许你修改sed 命令的行为<ul><li><code>-e script</code>：在处理输入时，将script 中指定的命令添加到已有的命令中</li><li><code>-f file</code>：在处理输入时，将file 中指定的命令添加到已有的命令中</li><li><code>-n</code>：不产生命令输出，使用print 命令来完成输出</li><li><code>-i</code>：就地修改</li></ul></li><li>script 参数指定了应用于流数据上的单个命令。如果需要用多个命令，要么使用 <code>-e</code> 选项在命令行中指定，要么使用 <code>-f</code> 选项在单独的文件中指定。</li><li>file 参数表示要处理的数据文件？</li></ul><ol><li><p>在命令行定义编辑器命令：<code>$ echo &quot;This is a test&quot; | sed &#39;s/test/big test/&#39;</code></p><ul><li>默认情况下，sed编辑器会将指定的命令应用到STDIN 输入流上。这样你可以直接将数据通过管道输入sed编辑器处理。</li><li>sed编辑器并不会修改文本文件的数据。它只会将修改后的数据发送到STDOUT。</li></ul></li><li><p>在命令行使用多个编辑器命令：<code>$ sed -e &#39;s/brown/green/; s/dog/cat/&#39; data1.txt</code></p><ul><li>命令之间必须用分号隔开，并且在命令末尾和分号之间不能有空格。</li><li>也可以用bash shell中的次提示符来分隔命令。只要输入第一个<strong>单引号标示出sed程序脚本的起始</strong>（sed编辑器命令列表），bash会继续提示你输入更多命令，直到输入了标示结束的单引号。要在封尾单引号所在行结束命令。bash shell一旦发现了封尾的单引号，就会执行命令。<pre><code>$ sed -e &#39;&gt; s/brown/green/&gt; s/fox/elephant/&gt; s/dog/cat/&#39; data1.txt</code></pre></li></ul></li><li><p>从文件中读取编辑器命令：<code>$ sed -f script1.sed data1.txt</code></p></li></ol><h1 id="script"><a href="#script" class="headerlink" title="script"></a>script</h1><h2 id="s-（substitute）命令"><a href="#s-（substitute）命令" class="headerlink" title="s （substitute）命令"></a><code>s （substitute）命令</code></h2><p>用斜线间指定的第二个文本字符串来替换第一个文本字符串模式。</p><h3 id="替换标记"><a href="#替换标记" class="headerlink" title="替换标记"></a>替换标记</h3><ul><li>默认情况下它只替换每行中出现的第一处。要让替换命令能够替换一行中不同地方出现的文本必须使用替换标记 （substitution flag）。替换标记会在替换命令字符串之后设置。<code>s/pattern/replacement/flags</code></li><li>数字，表明新文本将替换第几处模式匹配的地方；</li><li>g ，表明新文本将会替换所有匹配的文本；</li><li>p ，表明匹配所在行的内容要打印出来；和 -n 搭配使用，只输出被替换命令修改过的行。</li><li>w file ，将替换的结果写到文件中。<code>sed &#39;s/test/trial/w test.txt&#39; data5.txt</code></li></ul><h3 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h3><ul><li>正斜线通常用作字符串分隔符，因而如果它出现在了模式文本中的话，必须用反斜线来转义。<code>$ sed &#39;s/\/bin\/bash/\/bin\/csh/&#39; /etc/passwd</code></li><li>要解决这个问题，sed编辑器允许选择其他字符来作为替换命令中的字符串分隔符：<code>$ sed &#39;s!/bin/bash!/bin/csh!&#39; /etc/passwd</code>。感叹号被用作字符串分隔符，这样路径名就更容易阅读和理解了。</li></ul><h2 id="使用地址"><a href="#使用地址" class="headerlink" title="使用地址"></a>使用地址</h2><p>默认情况下，在sed编辑器中使用的命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须用行寻址 （line addressing）。</p><h3 id="以数字形式表示行区间"><a href="#以数字形式表示行区间" class="headerlink" title="以数字形式表示行区间"></a>以数字形式表示行区间</h3><ol><li><p>在命令中指定的地址可以是单个行号：<code>$ sed &#39;2s/dog/cat/&#39; data1.txt</code></p></li><li><p>用起始行号、逗号以及结尾行号指定的一定区间范围内的行：<code>$ sed &#39;2,3s/dog/cat/&#39; data1.txt</code></p><ul><li>如果想将命令作用到文本中从某行开始的所有行，可以用特殊地址——<strong>美元符</strong>。</li></ul></li></ol><p><strong>在单行上执行多条命令，可以用花括号将多条命令组合在一起</strong>。sed编辑器会处理地址行处列出的每条命令。也可以置地址区间。</p><pre><code>$ sed &#39;2&#123;&gt; s/fox/elephant/&gt; s/dog/cat/&gt; &#125;&#39; data1.txt</code></pre><h4 id="用文本模式来过滤出行"><a href="#用文本模式来过滤出行" class="headerlink" title="用文本模式来过滤出行"></a>用文本模式来过滤出行</h4><p>sed编辑器允许指定文本模式来过滤出命令要作用的行。<code>/pattern/command</code>，例如 <code>$ sed &#39;/Samantha/s/bash/csh/&#39; /etc/passwd</code></p><h2 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h2><p>与替换命令使用方式类似，它会删除匹配指定寻址模式的所有行。使用该命令时要特别小心，如果你忘记加入寻址模式的话，流中的所有文本行都会被删除。</p><pre><code>$ sed &#39;d&#39; data1.txt  // 删除所有行$ sed &#39;3d&#39; data1.txt  // 删除指定的第二行$ sed &#39;2,3d&#39; data1.txt  // 删除区间 2-3 行$ sed &#39;/pattern/d&#39; data1.txt // 删除匹配pattern的所有行$ sed &#39;/pattern1/,/pattern2/d&#39; data1.txt // 删除指定行之间的所有行，包括指定行。你指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能。- 如果 pattern1 在 pattern2 之后再次出现，则删除功能会再次打开，删除后面的所有行。- 如果 pattern2 不存在，同理，也会删除 pattern1 后的所有行</code></pre><h2 id="插入和附加文本"><a href="#插入和附加文本" class="headerlink" title="插入和附加文本"></a>插入和附加文本</h2><ul><li><code>插入（insert ）命令（i ）</code>会在指定行前增加一个新行；</li><li><code>附加（append ）命令（a ）</code>会在指定行后增加一个新行。</li></ul><p>它们不能在单个命令行上使用，比如只插入一行时，可以在一条命令行上操作；但是当插入两行时，就得以两行的形式表示，且新行最后用反斜线。</p><pre><code>sed &#39;[address]command\new line\new line\new line&#39; </code></pre><p>你必须指定是要将行插入还是附加到另一行。可以匹配一个数字行号或文本模式，但不能用地址区间。这合乎逻辑，因为你只能将文本插入或附加到单个行的前面或后面，而不是行区间的前面或后面。<br>如果你有一个多行数据流，想要将新行附加到数据流的末尾，只要用代表数据最后一行的美元符就可以了：<code>$ sed &#39;$a\line&#39; data.txt</code></p><h2 id="修改行"><a href="#修改行" class="headerlink" title="修改行"></a>修改行</h2><p>与插入和附加文本类似</p><pre><code>$ sed &#39;3c\&gt; This is a changed line of text.&#39; data6.txt// 用 pattern$ sed &#39;/pattern/c\&gt; This is a changed line of text.&#39; data6.txt// 用区间寻址会替换这两行$ sed &#39;2,3c\&gt; This is a new line of text.&#39; data6.txt</code></pre><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p><code>[address]y/inchars/outchars/</code></p><ul><li>转换（transform ）命令（y ）对inchars 和outchars 值进行一对一的映射。inchars 中的第一个字符会被转换为outchars 中的第一个字符，第二个字符会被转换成outchars 中的第二个字符。这个映射过程会一直持续到处理完指定字符。如果inchars 和outchars 的长度不同，则sed编辑器会产生一条错误消息。</li><li>转换命令是一个全局命令，也就是说，它会文本行中找到的所有指定字符自动进行转换，而不会考虑它们出现的位置。同理，你无法限定只转换在特定地方出现的字符。<pre><code>$ echo &quot;This 1 is 2 is 3 hah&quot; | sed &#39;y/123/456/&#39;This 4 is 5 is 6 hah$</code></pre></li></ul><h2 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h2><h3 id="p-命令"><a href="#p-命令" class="headerlink" title="p 命令"></a>p 命令</h3><pre><code>$ echo &quot;this is a test&quot; | sed &#39;p‘ // 单纯打印文本$ sed -n &#39;/number 3/p&#39; data6.txt // 打印匹配到 number 3 的行，txt文本内容全部都会打印，但是匹配行会出现两次$ sed -n &#39;2,3p&#39; data6.txt // 区间行打印多次</code></pre><h3 id="命令：打印行号"><a href="#命令：打印行号" class="headerlink" title="= 命令：打印行号"></a>= 命令：打印行号</h3><pre><code>$ sed -n &#39;/number 4/&#123;&gt; =&gt; p&gt; &#125;&#39; data6.txt4This is line number 4.</code></pre><h3 id="列出（list-）命令（l-）"><a href="#列出（list-）命令（l-）" class="headerlink" title="列出（list ）命令（l ）"></a>列出（list ）命令（l ）</h3><p>打印数据流中的文本和不可打印的ASCII字符。“任何不可打印字符要么在其八进制值前加一个反斜线，要么使用标准C风格的命名法（用于常见的不可打印字符），比如\t ，来代表制表符。</p><pre><code>$ cat data9.txtThis    line    contains        tabs.$$ sed -n &#39;l&#39; data9.txtThis\tline\tcontains\ttabs.$$</code></pre><h2 id="使用sed处理文件"><a href="#使用sed处理文件" class="headerlink" title="使用sed处理文件"></a>使用sed处理文件</h2><h3 id="w-命令：向文件中写入行"><a href="#w-命令：向文件中写入行" class="headerlink" title="w 命令：向文件中写入行"></a>w 命令：向文件中写入行</h3><p><code>[address]w filename</code></p><ul><li>filename 可以使用相对路径或绝对路径，但不管是哪种，运行sed编辑器的用户都必须有文件的写权限。</li><li>地址可以是sed中支持的任意类型的寻址方式，例如单个行号、文本模式、行区间或文本模式。</li><li>src 是命令之外的file，dst 是 filename，即把 file 的内容写入 filename。命令里指定的行和位置针对的是 src 源文件。</li></ul><p>如果要根据一些公用的文本值从主文件中创建一份数据文件，比如下面的邮件列表中的，那么w 命令会非常好用。</p><pre><code>$ cat data11.txtBlum, R       BrowncoatMcGuiness, A  AllianceBresnahan, C  BrowncoatHarken, C     Alliance$$ sed -n &#39;/Browncoat/w Browncoats.txt&#39; data11.txt // sed编辑器会只将包含文本模式的数据行写入目标文件。$$ cat Browncoats.txtBlum, R       BrowncoatBresnahan, C  Browncoat$</code></pre><h3 id="r命令：从文件中读取行"><a href="#r命令：从文件中读取行" class="headerlink" title="r命令：从文件中读取行"></a>r命令：从文件中读取行</h3><p>读取（read ）命令（r ）允许你将一个独立文件中的数据插入到数据流中。</p><p>读取命令的格式如下：<code>[address]r filename</code></p><ul><li>filename 参数指定了数据文件的绝对路径或相对路径。你在<strong>读取命令中使用地址区间，只能指定单独一个行号或文本模式地址。</strong></li><li>sed编辑器会将文件中的所有文本行插入到指定地址后。</li><li>要在数据流的末尾添加文本，只需用美元符地址符就行了。</li><li>从filename中读取行，写入外面的 f。</li></ul><p>读命令和删除命令配合使用：利用另一个文件中的数据来替换文件中的占位文本。<br>举例来说，假定你有一份套用信件保存在文本文件中：</p><pre><code>$ cat notice.stdWould the following people:LISTplease report to the ship&#39;s captain.$</code></pre><p>套用信件将<strong>通用占位文本LIST 放在人物名单的位置</strong>。要在占位文本后插入名单，只需读取命令就行了。但这样的话，占位文本仍然会留在输出中。要删除占位文本的话，你可以用删除命令。结果如下：</p><pre><code>$ sed &#39;/LIST/&#123;&gt; r data11.txt&gt; d&gt; &#125;&#39; notice.stdWould the following people:Blum, R       BrowncoatMcGuiness, A  AllianceBresnahan, C  BrowncoatHarken, C     Allianceplease report to the ship&#39;s captain.$</code></pre><p>r 命令是：读别人，写入我；w 命令是：读我，写别人。</p><h2 id="参考-引用"><a href="#参考-引用" class="headerlink" title="参考/引用"></a>参考/引用</h2><p>摘录来自: [美] Richard Blum. “Linux命令行与shell脚本编程大全（第3版）。” Apple Books. </p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk</title>
      <link href="/2022/01/10/awk/"/>
      <url>/2022/01/10/awk/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="awk-编辑器简介"><a href="#awk-编辑器简介" class="headerlink" title="awk 编辑器简介"></a>awk 编辑器简介</h1><p><a href="https://blog.csdn.net/gechangli7/article/details/51547641">awk、gawk、nawk、mawk的简单介绍</a></p><p>gawk程序是Unix中的原始awk程序的GNU版本。gawk程序让流编辑迈上了一个新的台阶，<strong>它提供了一种编程语言而不只是编辑器命令</strong>。在gawk编程语言中，你可以做下面的事情：</p><ol><li>定义变量来保存数据；</li><li>使用算术和字符串操作符来处理数据；</li><li>使用结构化编程概念（比如if-then 语句和循环）来为数据处理增加处理逻辑；</li><li>通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告。”</li></ol><h1 id="awk-命令"><a href="#awk-命令" class="headerlink" title="awk 命令"></a>awk 命令</h1><p>gawk程序的基本格式如下：<code>gawk options program file</code></p><h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2><ul><li><code>-F fs</code>：指定行中划分数据字段的字段分隔符</li><li><code>-f file</code>：从指定的文件中读取程序</li><li><code>-v var=value</code>：定义gawk程序中的一个变量及其默认值</li><li><code>-mf N</code>：指定要处理的数据文件中的最大字段数</li><li><code>-mr N</code>：指定数据文件中的最大数据行数</li><li><code>-W keyword</code>：指定gawk的兼容模式或警告等级</li></ul><h2 id="program-file"><a href="#program-file" class="headerlink" title="program file"></a>program file</h2><ol><li>gawk程序脚本用一对花括号来定义。你必须将脚本命令放到两个花括号（{} ）中。</li><li>由于 <strong>gawk 命令行</strong>假定脚本是单个文本字符串，你还必须将脚本放到单引号中。</li></ol><pre><code>$ gawk &#39;&#123;print &quot;Hello World!&quot;&#125;&#39;This is a testHello World!helloHello World!This is another testHello World!# 要终止这个gawk程序，你必须表明数据流已经结束了。bash shell提供了一个组合键来生成EOF（End-of-File）字符。Ctrl+D组合键会在bash中产生一个EOF字符。这个组合键能够终止该gawk程序并返回到命令行界面提示符下。</code></pre><h2 id="使用数据字段变量"><a href="#使用数据字段变量" class="headerlink" title="使用数据字段变量"></a>使用数据字段变量</h2><p>gawk的主要特性之一是其处理文本文件中数据的能力。它会<strong>自动给一行中的每个数据元素（一列）分配一个变量</strong>。</p><p>默认情况下，gawk会将如下变量分配给它在文本行中发现的数据字段：<code>$0</code> 代表整个文本行；<code>$1</code> 代表文本行中的第1个数据字段；<code>$n</code> 代表文本行中的第 n 个数据字段</p><p>在文本行中，每个数据字段都是通过<strong>字段分隔符</strong>划分的。gawk在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。<strong>gawk中默认的字段分隔符是任意的空白字符（例如空格或制表符）</strong>。</p><h2 id="在程序脚本中使用多个命令"><a href="#在程序脚本中使用多个命令" class="headerlink" title="在程序脚本中使用多个命令"></a>在程序脚本中使用多个命令</h2><ol><li><p>在命令行上的程序脚本中使用多条命令，只要在命令之间放个分号即可。</p></li><li><p>也可以用次提示符一次一行地输入程序脚本命令。（不用分号）</p></li></ol><h2 id="从文件中读取程序"><a href="#从文件中读取程序" class="headerlink" title="从文件中读取程序"></a>从文件中读取程序</h2><pre><code>$ cat script3.gawk&#123;text = &quot;&#39;s home directory is &quot;print $1 text $6&#125;$$ gawk -F: -f script3.gawk /etc/passwd”# script3.gawk 程序脚本定义了一个变量来保存 print 命令中用到的文本字符串。注意，gawk程序在引用变量值时并未像shell脚本一样使用美元符。</code></pre><h2 id="在处理数据前-后运行脚本"><a href="#在处理数据前-后运行脚本" class="headerlink" title="在处理数据前/后运行脚本"></a>在处理数据前/后运行脚本</h2><p>gawk在读取数据前执行 BEGIN 关键字后指定的程序脚本。END 关键字允许你指定一个程序脚本，gawk会在读完数据后执行它。</p><p>如果在命令行里输入 BEGIN/END ，则需要将整个命令加单引号</p><pre><code>$ cat script4.gawkBEGIN &#123;print &quot;The latest list of users and shells&quot;print &quot; UserID \t Shell&quot;print &quot;-------- \t -------&quot;FS=&quot;:&quot;   # 特殊变量，是定义字段分隔符的另一种方法。这样就不用依靠脚本用户在命令行选项中定义字段分隔符了。&#125;&#123;print $1 &quot;     \t &quot;  $7&#125;END &#123;print &quot;This concludes the listing&quot;&#125;$ gawk -f script4.gawk /etc/passwd</code></pre><h1 id="引用-参考"><a href="#引用-参考" class="headerlink" title="引用/参考"></a>引用/参考</h1><p>摘录来自: [美] Richard Blum. “Linux命令行与shell脚本编程大全（第3版）。” Apple Books. </p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grep</title>
      <link href="/2022/01/06/grep/"/>
      <url>/2022/01/06/grep/</url>
      
        <content type="html"><![CDATA[<h1 id="grep：输出匹配模式的行"><a href="#grep：输出匹配模式的行" class="headerlink" title="grep：输出匹配模式的行"></a>grep：输出匹配模式的行</h1><p>grep 命令的命令行格式如下： <code>grep [option...] [patterns] [file...]</code></p><ul><li>grep 命令会在<strong>输入</strong>或<strong>指定的文件中</strong>查找包含匹配<u>指定模式</u>的字符的行。grep 的输出就是包含了匹配模式的行。无法在文本中匹配 newline 字符。</li><li>option 和 file 参数可以有 0/多个。patterns 参数包含 1/多个以新行分割的模式，当 options 是 <code>-e patterns</code> 或 <code>-f file</code>时，新行被忽略。</li><li>file 为 - 时，表示标准输出；如果没有指定 input，grep 搜索这个工作目录。</li></ul><p>默认情况下，grep 命令用基本的Unix风格正则表达式来匹配模式。Unix风格正则表达式采用特殊字符来定义怎样查找匹配的模式。</p><p>常用下面四个，具体见 options 部分</p><ul><li><code>-v</code></li><li><code>-n</code></li><li><code>-c</code></li><li><code>-e</code></li></ul><h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2><h3 id="grep-程序的信息"><a href="#grep-程序的信息" class="headerlink" title="grep 程序的信息"></a>grep 程序的信息</h3><ul><li><code>--help</code></li><li><code>-V</code> / <code>--version</code></li></ul><h3 id="匹配控制"><a href="#匹配控制" class="headerlink" title="匹配控制"></a>匹配控制</h3><ul><li><code>-e patterns</code> / <code>--regexp=patterns</code> ：匹配某些模式中的一个或多个</li><li><code>-f file</code> / <code>--file=file</code>：匹配文件中的模式</li><li><code>-i</code> / <code>-y</code> \ <code>--ignore-case</code>：忽略文件和匹配中的大小写</li><li><code>--no-ignore-case</code>：不忽略大小写</li><li><code>-v</code> / <code>--invert-match</code>：不匹配的行</li><li><code>-w</code> / <code>--word-regexp</code>：匹配包含整个单词的行</li><li><code>-x</code> / <code>--line-regexp</code>：匹配包含整个行的行</li></ul><h3 id="输出控制"><a href="#输出控制" class="headerlink" title="输出控制"></a>输出控制</h3><ul><li><code>-c</code> / <code>--count</code>：不输出具体行，输出行数</li><li><code>--color[=WHEN]</code> / <code>--colour[=WHEN]</code>：对选中的数据高亮</li><li><code>-L</code> / <code>--files-without-match</code>：输出匹配行所在文件的名字，匹配到第一次出现就返回</li><li><code>-m num</code> / <code>--max-count=num</code>：只搜索前 m 行</li><li><code>-o</code> / <code>--only-matching</code>：只输出匹配行的匹配的部分，每个匹配一行输出</li><li><code>-q</code> / <code>--quiet / --silent</code>：不向标准输出输出。如果搜索到匹配，马上返回 0 状态码，如果有错误，也马上返回。同 -s / –no-messages。</li></ul><h3 id="输出行前缀控制"><a href="#输出行前缀控制" class="headerlink" title="输出行前缀控制"></a>输出行前缀控制</h3><ul><li><code>-b</code> / <code>--byte-offset</code></li><li><code>-H</code> / <code>--with-filename</code>：输出匹配时，前缀输出文件名</li><li><code>-h</code> / <code>--no-filename</code>：当输入只有一个文件时，不输出文件名</li><li><code>--label=LABEL</code> </li><li><code>-n</code> / <code>--line-number</code>：输出匹配所在的行数</li><li><code>-T</code> / <code>--initial-tab</code>：输出前缀时，以tab形式展示</li><li><code> -Z</code> / <code>--null</code></li></ul><h3 id="上下文行的控制"><a href="#上下文行的控制" class="headerlink" title="上下文行的控制"></a>上下文行的控制</h3><p>Context lines 是接近匹配行的非匹配行。</p><ul><li><code>-A num</code> \ <code>--after-context=num</code>：输出匹配行后 num 行</li><li><code>-B num</code> \ <code>--before-context=num</code>：输出匹配行前 num 行</li><li><code>-C num</code> \ <code>-num \ --context=num</code>：输出匹配行前，后 num 行</li><li><code>--group-separator=string</code></li><li><code> --no-group-separator</code></li></ul><p>“alias grep=’grep –color=auto”</p><p>有四种 grep 的变种，通过 options 控制：</p><ul><li><code>-G</code> / <code>--basic-regexp</code>：默认的（BRE：basic regular expressions）</li><li><code>-E</code> / <code>--extended-regexp</code>：支持POSI，将匹配模式解释为扩展的正则匹配表达式 （EREs）</li><li><code>-F</code> / <code>--fixed-strings</code>：egrep 命令支持POSIX扩展正则表达式。POSIX扩展正则表达式含有更多的可以用来指定匹配模式的字符。</li><li><code>-P</code> / <code>--prel-regexp</code> ：fgrep 支持将匹配模式指定为用换行符分隔的一列固定长度的字符串。这样就可以把这列字符串放到一个文件中，然后在fgrep 命令中用其在一个大型文件中搜索字符串了。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>部分摘录来自: [美] Richard Blum. “Linux命令行与shell脚本编程大全（第3版）。” Apple Books.</li><li>部分翻译自 <code>info grep</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang 学习</title>
      <link href="/2021/08/22/go%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
      <url>/2021/08/22/go%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>这个<a href="https://www.bogotobogo.com/">学习</a> 网站真的很不错！<br>go 的教程在<a href="https://www.bogotobogo.com/GoLang/GoLang_HelloWorld.php">这里</a></p><h1 id="go-起源"><a href="#go-起源" class="headerlink" title="go 起源"></a>go 起源</h1><ul><li>Go语言有时候被描述为“C类似语言”，或者是“21世纪的C语言”。</li><li>Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。</li><li>Go语言的家族树中还有其它的祖先，包括CSP（communication sequential processes，顺序通信进程，并行程序通过管道进行通信和同步控制），Pascal 等。</li><li>同时，Go 语言也有很多创新的设计：Go语言的<strong>切片</strong>为动态数组提供了有效的随机存取的性能（这可能会让人联想到链表的底层的共享机制）；Go语言新发明的<strong>defer语句</strong>。</li></ul><h1 id="go-背景"><a href="#go-背景" class="headerlink" title="go 背景"></a>go 背景</h1><ul><li>Go项目是在Google公司维护超级复杂的几个软件系统遇到的一些问题的反思</li><li>只有通过简洁的设计，才能让一个系统保持稳定、安全和持续的进化。</li><li>Go项目包括编程语言本身，附带了相关的工具和标准库，以及简洁编程哲学的宣言。</li><li>Go语言源代码本身就包含了构建规范。</li><li>Go 1.12中，当当前的目录或者父目录中有go.mod，且目录在 $GOPATH/src 之外，go 命令支持使用 modules。为了兼容性，如果目录在$GOPATH/src中，不论是否有 go.mod，都使用旧的 GOPATH 模式。</li></ul><p>go module <a href="https://www.bogotobogo.com/GoLang/GoLang_Modules_1_Creating_a_new_module.php">参考1</a></p><h1 id="go-代码组织"><a href="#go-代码组织" class="headerlink" title="go 代码组织"></a>go 代码组织</h1><ul><li>Go 程序组织在 package 中。一个 package 是同一个目录下的多个同时编译（compiled）的源文件，源文件中定义的函数，类型，变量，常量等，对且同一个 package 下的源文件是可见的。</li><li>一个Go repository 包含一个或多个 modules。一个 module 是多个同时发布（released）的 Go packages。典型地，一个 Go repo 包含一个 module，位于 repo 的根目录下。<ul><li>go.mod 声明 module path：是同一个module 中所有 package 的 import path 的前缀；也指明了从哪里寻找文件并下载。</li><li>如果 package 在 module 的当前目录或者子目录下，且没有自己的 go.mod 文件，则属于当前 module。</li></ul></li><li>import path 是用来导入 package 的string，即 module path + package 在module 中的子目录名<ul><li>标准库中的 package 不需要 module path prefix。</li></ul></li></ul><h1 id="go-项目结构"><a href="#go-项目结构" class="headerlink" title="go 项目结构"></a>go 项目结构</h1><p>参见 <a href="https://github.com/golang-standards/project-layout">go standards</a><br>推荐直接看汉语版，有别人的一些简介：见<a href="https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md">Go 面向包的设计和架构分层</a>，同时[Go 包的组织和命名]（<a href="https://github.com/danceyoung/paper-code/blob/master/package-style-guideline/packagestyleguideline.md%EF%BC%89%E4%B9%9F%E5%BE%88%E6%8E%A8%E8%8D%90%E7%9C%8B%E4%B8%80%E7%9C%8B%E3%80%82">https://github.com/danceyoung/paper-code/blob/master/package-style-guideline/packagestyleguideline.md）也很推荐看一看。</a></p><p>go 会忽略以.或者_开头的文件或目录。<br>Go 项目中不要用 src 文件夹。因为 $GOPATH 环境变量指向当前使用的 workspace ，这个workspace 包含顶级目录：/pkg，/bin 和 /src。实际 go 项目是 /src 目录下的子目录，因此不推荐。（Go 1.11 后可以将项目放置在 GOPATH 之外，但也不推荐这种布局）</p><ul><li>/cmd<ul><li>此项目的主应用。目录名要和可执行程序的名字一致，不要在这个目录放置过多文件</li><li>对于可以被其他项目 import 的代码，放置在 /pkg 目录下，如果不想让其他人重用，可放在/internal 目录下</li><li>main 函数 import 并 invoke 在/internal 和 /pkg 目录中的代码是很常见的</li></ul></li><li>/internal<ul><li>私有的应用和库代码</li><li>Go1.14 中，Go 编译器强制其他库或者应用不可以 import internal 目录下的代码</li><li>可以在项目中的任何层级，包含一个或多个 internal 目录，在 internal 目录内又可以额外增加结构，从而分离共享（pkg）和非共享（app）的代码</li></ul></li><li>/pkg<ul><li>可以被外部应用使用的库代码</li><li>明确告诉其他人，这个目录下的代码是可以安全使用的</li></ul></li><li>/vendor<ul><li>App 的依赖，手动或者 go modules 维护</li><li>go mod vecdor 命令创建/vendor 目录</li></ul></li></ul><hr><ul><li>/api<ul><li>service app 目录</li></ul></li><li>web<ul><li>web app 目录</li><li>static web assets, server side templates and SPAs.</li></ul></li><li>通用的 app 目录<ul><li>/configs<ul><li>配置文件模版或者默认的配置</li></ul></li><li>/init<ul><li>system init（systemd, upstart, sysv），以及处理manage/supervisor的配置</li></ul></li><li>scripts<ul><li>执行各种 build，install，analysis 等操作的脚本，从而使得 Makefile 简单而小</li></ul></li><li>/build<ul><li>用于打包和持续集成</li><li>将cloud（AMI），容器（Docker），OS（deb，rpm，pkg）的包配置和脚本放置在/build/package目录下</li><li>将 CI（travis, circle, drone）相关的配置和脚本放置在 /build/ci 目录下</li></ul></li><li>/deployments or /deploy<ul><li>IaaS, PaaS,templates (docker-compose, kubernetes/helm, mesos, terraform, bosh)</li></ul></li><li>/test<ul><li>任意测试文件，还可以包含 /test/data自目录</li></ul></li></ul></li><li>其他目录<ul><li>/docs</li><li>tools<ul><li>支持此项目的工具？这些 tools 可以 import /pkg和/internal 目录下的代码</li></ul></li><li>exaamples</li><li>third_party<ul><li>外部帮助工具，forked code，和其他第三方 utilities</li></ul></li><li>/githooks</li><li>/assets<ul><li>你项目repo的图片，logs等</li></ul></li><li>/website<ul><li>如果不再github上放置项目，这里说明项目所在的网页</li></ul></li></ul></li></ul><p>？ 不太懂 pkg，third_party ，tools 啥区别？</p><h2 id="go-文件结构"><a href="#go-文件结构" class="headerlink" title="go 文件结构"></a>go 文件结构</h2><ul><li>首先需要选择 module path，如 example.com/user/hello，进入hello，go mod init example.com/user/hello<br>```go<br>package main</li></ul><p>import “fmt”</p><p>func main() {<br>    fmt.Println(“Hello, world.”)<br>}</p><pre><code># go 控制语句# go 工具- go install：将二进制文件安装在go workspace的bin目录下【？没成功】- go clean -i：删除workspace的bin目录下的二进制文件- Gofmt：reformats Go source code- golint prints out style mistakes.</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊ERC20</title>
      <link href="/2019/12/23/%E4%BB%A5%E5%A4%AA%E5%9D%8AERC20/"/>
      <url>/2019/12/23/%E4%BB%A5%E5%A4%AA%E5%9D%8AERC20/</url>
      
        <content type="html"><![CDATA[<ul><li>译文：<a href="https://mp.weixin.qq.com/s?__biz=MzIwODA3NDI5MA==&mid=2652525287&idx=1&sn=4e8409169abb97a7ba36471cece34ad3&chksm=8ce651babb91d8ac9c6a69f25344981a11d29e799940dbce953b0b43cdb6ea65f64ec508b842&scene=21#wechat_redirect">2017-理解ERC-20 token合约-以太坊爱好者</a> <ul><li>原文：<a href="https://www.wealdtech.com/articles/understanding-erc20-token-contracts/">2017-Understanding ERC-20 token contracts-Jim McDonald</a></li></ul></li></ul><p>从这篇文章中可知，ERC20 就是一个记录 &lt;地址，资产&gt; 的键值存储数据库。所有的 存 token、取 token 操作相当于在记录里面的增/删/改一条记录。</p><ul><li><a href="https://www.jianshu.com/p/4002a5212885">2018-教你如何一步步创建ERC20代币-Pony小马</a></li></ul><p>这篇文章实践为例，构建简单的 ERC20 代币，介绍了ERC20的标准接口并做了实现和部署。</p><ul><li>译文：<a href="https://mp.weixin.qq.com/s/foM1QWvsqGTdHxHTmjczsw">2017-代币支付的以太坊智能服务-以太坊爱好者</a><ul><li>原文：<a href="https://www.wealdtech.com/articles/ethereum-smart-service-payment-with-tokens/">2017-Ethereum smart service payment with tokens-Jim McDonald</a></li></ul></li></ul><p>这篇文章主要以伪代码的形式，说明了外部服务如何使用 token 作为一种支付方式。以图文并茂的方式告诉我们几个函数的适用场景。包括 ：<code>approve()</code>，<code>transfer()</code>，<code>transferFrom()</code>，<code>approveAndCall()</code>，<code>receiveApproval()</code>，<code>transferAndCall()</code>，<code>tokenFallback()</code>。</p><ul><li><p><a href="https://dev.to/jklepatch/the-2-ways-to-transfer-erc20-tokens-in-solidity-3h40">The 2 ways to transfer ERC20 Tokens in Solidity</a></p><ul><li><p>transfer() (simple transfers)</p><ul><li>Import the ERC20 token<ul><li><code>import  &quot;github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol&quot;;</code></li></ul></li><li>Import the address of the token</li></ul></li><li><p>Call transfer()</p></li></ul></li><li><p>transferFrom() (delegated transfer)</p><ul><li>Import the ERC20 token</li><li>Import the address of the token</li><li>Call approve()</li><li>Call transferFrom()</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> solidity </tag>
            
            <tag> 智能合约 </tag>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊-Transaction</title>
      <link href="/2019/12/22/%E4%BB%A5%E5%A4%AA%E5%9D%8A-Transaction/"/>
      <url>/2019/12/22/%E4%BB%A5%E5%A4%AA%E5%9D%8A-Transaction/</url>
      
        <content type="html"><![CDATA[<ul><li>本文主要参考（并根据自己的理解进行思路的梳理）<ul><li><a href="https://blog.csdn.net/TurkeyCock/article/details/80485391">以太坊交易源码分析</a></li><li><a href="https://blog.csdn.net/yzpbright/article/details/83538362s">GoLand导入并编译以太坊源码go-ethereum</a></li><li><a href="https://ethereum.iethpay.com/how-to-sign-and-hash-tx.html">交易签名以及哈希值的计算</a></li></ul></li></ul><h2 id="交易定义"><a href="#交易定义" class="headerlink" title="交易定义"></a>交易定义</h2><ul><li>由 <code>EOA（externally owned account）</code>生成的，签过名的消息</li><li>万事始于交易。交易可触发以太坊（全局的单个状态机）状态的转换，调用智能合约在 <code>EVM</code> 中的执行</li></ul><h2 id="交易基本流程"><a href="#交易基本流程" class="headerlink" title="交易基本流程"></a>交易基本流程</h2><ul><li><p>发起交易：指定目标地址和交易金额，以及需要的 gas/gaslimit，还可以填充 data 字段</p></li><li><p>交易签名：使用账户私钥对交易（实际是交易的 hash）进行签名</p></li><li><p>提交交易：把交易加入到交易缓冲池 txpool 中（会先对交易签名进行验证）</p></li><li><p>广播交易：通知 EVM 执行，同时把交易信息广播给其他结点</p></li></ul><p><img src="https://i.loli.net/2019/12/22/MBHsouZ8PK6AGip.png" alt="transaction-execute.jpg"></p><h3 id="交易处理入口函数"><a href="#交易处理入口函数" class="headerlink" title="交易处理入口函数"></a>交易处理入口函数</h3><p>用户通过 <code>JSON RPC</code> 发起 <code>eth_sendTransaction</code> 请求，最终会调用 <code>PublicTransactionPoolAPI</code> 的实现，代码位于<code> internal/ethapi/api.go</code>。</p><p>首先根据 <code>from</code> 地址查找到对应的 <code>wallet</code>。根据参数值去设置默认值，比如 <code>amount</code> <code>gasPrice</code>  <code>nonce</code> 字段可以没有输入。还会检查 <code>data</code> 和 <code>input</code> 是否重复输入，并且不相等。对参数值进行检查，如果是创建合约，检查 <code>data</code>是否为空。</p><p>接着主要做了以下3件事：</p><ul><li><p>通过 <code>SendTxArgs.toTransaction() </code>创建交易</p></li><li><p>通过<code>Wallet.SignTx()</code>对交易进行签名。Wallet是一个接口，具体实现在 keyStoreWallet 中。</p></li><li><p>通过<code>submitTransaction()</code>提交交易</p></li></ul><pre><code class="go">// SendTransaction creates a transaction for the given argument, sign it and submit it to the// transaction pool.func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error) &#123;    // Look up the wallet containing the requested signer    account := accounts.Account&#123;Address: args.From&#125;    wallet, err := s.b.AccountManager().Find(account)    if err != nil &#123;        return common.Hash&#123;&#125;, err    &#125;    if args.Nonce == nil &#123;        // Hold the addresse&#39;s mutex around signing to prevent concurrent assignment of the same nonce to multiple accounts.        s.nonceLock.LockAddr(args.From)        defer s.nonceLock.UnlockAddr(args.From)    &#125;    // Set some sanity defaults and terminate on failure    if err := args.setDefaults(ctx, s.b); err != nil &#123;        return common.Hash&#123;&#125;, err    &#125;    // Assemble the transaction and sign with the wallet    tx := args.toTransaction() //*****    signed, err := wallet.SignTx(account, tx, s.b.ChainConfig().ChainID)//*****    if err != nil &#123;        return common.Hash&#123;&#125;, err    &#125;    return SubmitTransaction(ctx, s.b, signed)//*****&#125;</code></pre><h3 id="创建交易实例"><a href="#创建交易实例" class="headerlink" title="创建交易实例"></a>创建交易实例</h3><p>首先处理输入参数的 <code>input/data</code> 字段，推荐用 <code>input</code>，<code>data</code> 是为了向后兼容。</p><p>如果目标地址为空的话，表示这是一个创建智能合约的交易，调用 <code>NewContractCreation()</code>。否则说明这是一个普通交易，调用 <code>NewTransaction()</code>。不管调用哪个，最终都会生成一个Transaction实例，处理函数是一样的，只是 <code>to</code> 参数有没有值的区别，transaction 类型字段见下。</p><pre><code class="go">//代码位于internal/ethapi/api.gofunc (args *SendTxArgs) toTransaction() *types.Transaction &#123;    var input []byte    if args.Input != nil &#123;        input = *args.Input    &#125; else if args.Data != nil &#123;        input = *args.Data    &#125;    if args.To == nil &#123;        return types.NewContractCreation(uint64(*args.Nonce), (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input)    &#125;    return types.NewTransaction(uint64(*args.Nonce), *args.To, (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input)&#125;</code></pre><h4 id="SendTxArgs-结构"><a href="#SendTxArgs-结构" class="headerlink" title="SendTxArgs 结构"></a>SendTxArgs 结构</h4><p>和 <code>JSON</code> 字段相应的，包括了地址、gas、金额这些交易信息，<code>nonce</code> 是一个随账户交易次数自增的数字，一般会在默认设置中自动获取填充。交易还可以携带一些额外数据，存放在 <code>data</code> <strong>或者</strong> <code>input</code> 字段中。</p><pre><code class="go">//代码位于internal/ethapi/api.go// SendTxArgs represents the arguments to sumbit a new transaction into the transaction pool.type SendTxArgs struct &#123;    From     common.Address  `json:&quot;from&quot;`    To       *common.Address `json:&quot;to&quot;`    Gas      *hexutil.Uint64 `json:&quot;gas&quot;`    GasPrice *hexutil.Big    `json:&quot;gasPrice&quot;`    Value    *hexutil.Big    `json:&quot;value&quot;`    Nonce    *hexutil.Uint64 `json:&quot;nonce&quot;`    // We accept &quot;data&quot; and &quot;input&quot; for backwards-compatibility reasons. &quot;input&quot; is the newer name and should be preferred by clients.    Data  *hexutil.Bytes `json:&quot;data&quot;`    Input *hexutil.Bytes `json:&quot;input&quot;`&#125;</code></pre><h4 id="transaction类型"><a href="#transaction类型" class="headerlink" title="transaction类型"></a>transaction类型</h4><p>主要就是包含了一个 <code>txdata</code> 类型的字段，其他3个都是缓存。</p><pre><code class="go">// 代码位于 core/types/transaction.gotype Transaction struct &#123;    data txdata    // caches    hash atomic.Value    size atomic.Value    from atomic.Value&#125;</code></pre><h4 id="txdata-类型"><a href="#txdata-类型" class="headerlink" title="txdata 类型"></a>txdata 类型</h4><p>相对于输入参数中的字段，多了 <code>V、R、S</code> 和 <code>hash</code> 4 个字段，少了 <code>from</code> 字段。&lt;v,r,s&gt;是签名后才能得到的，现在生成的交易实例中不包含。</p><p> 其他节点收到交易时，通过 &lt;v,r,s&gt; 及 消息hash 计算出 <code>from</code> 字段，参见 <strong>交易签名</strong> 部分。</p><pre><code class="go">// 代码位于 core/types/transaction.gotype txdata struct &#123;    AccountNonce uint64          `json:&quot;nonce&quot;    gencodec:&quot;required&quot;`    Price        *big.Int        `json:&quot;gasPrice&quot; gencodec:&quot;required&quot;`    GasLimit     uint64          `json:&quot;gas&quot;      gencodec:&quot;required&quot;`    Recipient    *common.Address `json:&quot;to&quot;       rlp:&quot;nil&quot;` // nil means contract creation    Amount       *big.Int        `json:&quot;value&quot;    gencodec:&quot;required&quot;`    Payload      []byte          `json:&quot;input&quot;    gencodec:&quot;required&quot;`    // Signature values    V *big.Int `json:&quot;v&quot; gencodec:&quot;required&quot;`    R *big.Int `json:&quot;r&quot; gencodec:&quot;required&quot;`    S *big.Int `json:&quot;s&quot; gencodec:&quot;required&quot;`    // This is only used when marshaling to JSON.    Hash *common.Hash `json:&quot;hash&quot; rlp:&quot;-&quot;`&#125;</code></pre><h3 id="交易签名"><a href="#交易签名" class="headerlink" title="交易签名"></a>交易签名</h3><p>先通过 <code>Keccak-256</code> 算法计算交易数据的 has h值，然后结合账户的私钥，通过 ECDSA（Elliptic Curve Digital Signature Algorithm），也就是椭圆曲线数字签名算法生成签名数据。</p><p><img src="https://i.loli.net/2019/12/22/X5xb6N4hMg1yDGW.png" alt="SignTx.jpg"></p><pre><code class="go">//代码位于 accounts/keystore/wallet.go/* SignTx implements accounts.Wallet, attempting to sign the given transaction with the given account. If the wallet does not wrap this particular account, an error is returned to avoid account leakage (even though in theory we may/be able to sign via our shared keystore backend).*/func (w *keystoreWallet) SignTx(account accounts.Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error) &#123;    // Make sure the requested account is contained within    if !w.Contains(account) &#123;        return nil, accounts.ErrUnknownAccount    &#125;    // Account seems valid, request the keystore to sign    return w.keystore.SignTx(account, tx, chainID) //*****&#125;</code></pre><p>插播一条：从交易原信息和&lt;v,r,s&gt;生成 <code>from</code> 字段的示意图。TODO：代码示例</p><p><img src="https://i.loli.net/2019/12/22/iaUXbWy45P91R6O.png" alt="txCalFrom.jpg"></p><h4 id="keystore-SignTx"><a href="#keystore-SignTx" class="headerlink" title="keystore.SignTx"></a>keystore.SignTx</h4><p>这里会首先判断账户是否已经解锁，如果已经解锁的话就可以获取它的私钥。</p><p>然后创建签名器，如果要符合 EIP155 规范的话，需要把 chainID 传进去，也就是我们的 “–networkid” 令行参数。</p><p>调用一个全局函数 <strong>SignTx()</strong> 完成签名.</p><pre><code class="go">//代码位于 accounts/keystore/keystore.go//SignTx signs the given transaction with the requested account.func (ks *KeyStore) SignTx(a accounts.Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error) &#123;    // Look up the key to sign with and abort if it cannot be found    ks.mu.RLock()    defer ks.mu.RUnlock()    unlockedKey, found := ks.unlocked[a.Address]    if !found &#123;        return nil, ErrLocked    &#125;    // Depending on the presence of the chain ID, sign with EIP155 or homestead    if chainID != nil &#123;        return types.SignTx(tx, types.NewEIP155Signer(chainID), unlockedKey.PrivateKey)    &#125;    return types.SignTx(tx, types.HomesteadSigner&#123;&#125;, unlockedKey.PrivateKey)&#125;</code></pre><h4 id="全局-types-signTx-完成签名"><a href="#全局-types-signTx-完成签名" class="headerlink" title="全局 types.signTx 完成签名"></a>全局 types.signTx 完成签名</h4><p>主要分为3个步骤：</p><ul><li>生成交易的hash值</li><li>根据hash值和私钥生成签名</li><li>把签名数据填充到Transaction实例中</li></ul><pre><code class="go">//代码位于 core/types/transaction_signing.go// SignTx signs the transaction using the given signer and private keyfunc SignTx(tx *Transaction, s Signer, prv *ecdsa.PrivateKey) (*Transaction, error) &#123;    h := s.Hash(tx)    sig, err := crypto.Sign(h[:], prv)    if err != nil &#123;        return nil, err    &#125;    return tx.WithSignature(s, sig)&#125;</code></pre><h5 id="交易散列生成"><a href="#交易散列生成" class="headerlink" title="交易散列生成"></a>交易散列生成</h5><pre><code class="go">//代码位于 core/types/transaction_signing.go// Hash returns the hash to be signed by the sender.// It does not uniquely identify the transaction.func (s EIP155Signer) Hash(tx *Transaction) common.Hash &#123;    return rlpHash([]interface&#123;&#125;&#123;        tx.data.AccountNonce,        tx.data.Price,        tx.data.GasLimit,        tx.data.Recipient,        tx.data.Amount,        tx.data.Payload,        s.chainId, uint(0), uint(0),    &#125;)&#125;</code></pre><p>先进行RLP编码（一种数据序列化方法），然后再用SHA3-256生成hash值。TODO：RLP 编码实现。</p><pre><code class="go">//代码位于 core/types/block.gofunc rlpHash(x interface&#123;&#125;) (h common.Hash) &#123;    hw := sha3.NewLegacyKeccak256()    rlp.Encode(hw, x)    hw.Sum(h[:0])    return h&#125;</code></pre><h5 id="根据hash值和私钥生成签名"><a href="#根据hash值和私钥生成签名" class="headerlink" title="根据hash值和私钥生成签名"></a>根据hash值和私钥生成签名</h5><p>TODO：签名的过程</p><p>通过 ECDSA 算法生成签名数据，最终会返回的签名是一个字节数组，按R / S / V的顺序排列。</p><pre><code class="go">//代码位于 crypto/signature_cgo.go/*Sign calculates an ECDSA signature. This function is susceptible to chosen plaintext attacks that can leak information about the private key that is used for signing. Callers mustbe aware that the given digest cannot be chosen by an adversery. Commonsolution is to hash any input before calculating the signature.*/// The produced signature is in the [R || S || V] format where V is 0 or 1.func Sign(digestHash []byte, prv *ecdsa.PrivateKey) (sig []byte, err error) &#123;    if len(digestHash) != DigestLength &#123;        return nil, fmt.Errorf(&quot;hash is required to be exactly %d bytes (%d)&quot;, DigestLength, len(digestHash))    &#125;    seckey := math.PaddedBigBytes(prv.D, prv.Params().BitSize/8)    defer zeroBytes(seckey)    return secp256k1.Sign(digestHash, seckey)&#125;</code></pre><h5 id="填充签名数据"><a href="#填充签名数据" class="headerlink" title="填充签名数据"></a>填充签名数据</h5><p>把签名数据的这3个值填充到Transaction结构中。</p><pre><code class="go">//代码位于 core/types/transaction.go// WithSignature returns a new transaction with the given signature.// This signature needs to be in the [R || S || V] format where V is 0 or 1.func (tx *Transaction) WithSignature(signer Signer, sig []byte) (*Transaction, error) &#123;    r, s, v, err := signer.SignatureValues(tx, sig)    if err != nil &#123;        return nil, err    &#125;    cpy := &amp;Transaction&#123;data: tx.data&#125;    cpy.data.R, cpy.data.S, cpy.data.V = r, s, v    return cpy, nil&#125;</code></pre><h6 id="SignatureValues"><a href="#SignatureValues" class="headerlink" title="SignatureValues"></a>SignatureValues</h6><p>生成的签名数据是字节数组类型，需要通过signer.SignatureValues()函数转换成3个big.Int类型的数据，然后填充到Transaction结构的R / S / V字段上。</p><p>TODO：v 到底怎么回事，一会加27，一会加35</p><pre><code class="go">//代码位于 /core/transaction_signing.go// SignatureValues returns signature values. This signature// needs to be in the [R || S || V] format where V is 0 or 1.func (fs FrontierSigner) SignatureValues(tx *Transaction, sig []byte) (r, s, v *big.Int, err error) &#123;    if len(sig) != crypto.SignatureLength &#123;        panic(fmt.Sprintf(&quot;wrong size for signature: got %d, want %d&quot;, len(sig), crypto.SignatureLength))    &#125;    r = new(big.Int).SetBytes(sig[:32])    s = new(big.Int).SetBytes(sig[32:64])    v = new(big.Int).SetBytes([]byte&#123;sig[64] + 27&#125;)    return r, s, v, nil&#125;</code></pre><h3 id="提交交易"><a href="#提交交易" class="headerlink" title="提交交易"></a>提交交易</h3><p>就看我参考的原文吧。主要是前两点和最近做的东西有点关系。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp debug</title>
      <link href="/2019/11/29/C-%E9%9A%8F%E8%AE%B0/"/>
      <url>/2019/11/29/C-%E9%9A%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="bazel"><a href="#bazel" class="headerlink" title="bazel"></a>bazel</h1><ol><li>.bazelrc 中关闭 copt</li><li>bazel build –copt=”-g” –strip=”never” …</li></ol><p>build –cxxopt=”–std=c++17”<br>#build –copt=-O2<br>build –incompatible_no_support_tools_in_action_inputs=false</p><p><a href="https://blog.csdn.net/shaomingliang499/article/details/50536796">https://blog.csdn.net/shaomingliang499/article/details/50536796</a></p><ul><li><p>想要随机产生0-100间的整数，从而做排序的操作</p><ul><li><a href="https://www.cnblogs.com/VVingerfly/p/5990714.html">C++产生随机数</a>             </li><li>通常用 <code>srand((unsigned)time(0)) </code>或者<code>srand((unsigned)time(NULL))</code>来 产生种子。如果仍然觉得时间间隔太小。可以在<code>(unsigned)time(0)</code>或者<code>(unsigned)time(NULL)</code>后面乘上某个合适的整数。 例如,<code>srand((unsigned)time(NULL)*10)</code>。</li><li><a href="https://blog.csdn.net/yangziluomu/article/details/102013793">浮点随机数产生</a></li></ul></li></ul><h1 id="C-类访问控制（public-protected-private）"><a href="#C-类访问控制（public-protected-private）" class="headerlink" title="C++ 类访问控制（public/protected/private）"></a>C++ 类访问控制（public/protected/private）</h1><p>C++中 public，protected， private 访问标号小结<br>第一：private, public, protected 访问标号的访问范围。<br>private：只能由1.该类中的函数、2.其友元函数访问。<br>不能被任何其他访问，该类的对象也不能访问。<br>protected：可以被1.该类中的函数、2.子类的函数、以及3.其友元函数访问。<br>但不能被该类的对象访问。<br>public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。<br>注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。<br>————————————————<br>版权声明：本文为CSDN博主「sppg1949」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/sppg1949/article/details/6716561">https://blog.csdn.net/sppg1949/article/details/6716561</a></p><p>// const, inline, this, 引用, 列表初始化 </p><p>声明是用户可以看到的部分，客户非常信任地使用这个特性，希望得到一定的结果，但是你在实现里使用了不同的缺省值，那么将是灾难性的。因此编译器禁止声明和定义时同时定义缺省参数值。</p><p>类的成员函数的参数表在声明时默认参数位于参数表右部，如int fn(int a,int b=0,int c=5)之类的，但在它定义的时候则不能加默认参数，只能写int fn(int a,int b,int c);</p><p>若声明时没有定义缺省参数值，那么在定义成员函数时可以定义缺省参数值。但这种情况通常用户是看不见的，因此应避免。</p><p>对于非类中的函数，在函数声明中定义默认参数的另外一个好处时，可以利用声明来随意更改默认参数的值。<br>————————————————<br>版权声明：本文为CSDN博主「abraham_li」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/abraham_li/article/details/49611719">https://blog.csdn.net/abraham_li/article/details/49611719</a></p><p>5、char test[4]={‘t’,’e’,’s’,’t’}或char test[]={‘t’,’e’,’s’,’t’}  这种情况下因为不管是数字长度缺省还是刚好填充字符个数，编译器都不会添加结尾符，所以这两种情况得到的结果不确定！<br>其他和 char 相关的都会自动在后面加 ‘\0’</p><ul><li><p>关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。</p><ul><li>所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。</li></ul></li><li><p>定义在类声明之中的成员函数将自动地成为内联函数</p></li><li><p>慎用内联</p><ul><li>内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着“内联”这个关键字吗？内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>以下情况不宜使用内联：<ul><li>（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。</li><li>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如“偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。</li></ul></li></ul></li><li><p>如果inline函数出现的话，其定义必须相同。建议把inline函数的定义放到头文件中。在每个调用该inline函数的文件中包含该头文件。这种方法保证对每个inline函数只有一个定义，且程序员无需复制代码，并且不可能在程序的生命期中引起无意的不匹配的事情。<br><a href="https://blog.csdn.net/nanhaizhixin/article/details/7564084">https://blog.csdn.net/nanhaizhixin/article/details/7564084</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>区块链相关技术前沿洞察</title>
      <link href="/2019/11/05/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E5%89%8D%E6%B2%BF%E6%B4%9E%E5%AF%9F/"/>
      <url>/2019/11/05/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E5%89%8D%E6%B2%BF%E6%B4%9E%E5%AF%9F/</url>
      
        <content type="html"><![CDATA[<hr><p>2019 CCF区块链技术大会 ，  中国工程院院士陈纯院士发表了《联盟区块链关键技术与区块链的监管挑战》主题演讲  </p><h3 id="核心观点"><a href="#核心观点" class="headerlink" title="核心观点"></a>核心观点</h3><ol><li>联盟链底层平台的核心是性能、安全隐私、可用性和可扩展；</li><li>链上链下数据协同技术是未来发展的几个重要方向；</li><li>区块链的监管技术是区块链健康和持续发展的关键。</li></ol><h3 id="联盟区块链的4大关键技术"><a href="#联盟区块链的4大关键技术" class="headerlink" title="联盟区块链的4大关键技术"></a>联盟区块链的4大关键技术</h3><h4 id="联盟区块链高性能"><a href="#联盟区块链高性能" class="headerlink" title="联盟区块链高性能"></a>联盟区块链高性能</h4><p>问题： 大规模的节点，或大数据量的情况下区块链性能会急剧下降  </p><p>技术突破：包括高性能的共识算法、新型的共识机制、高效智能合约引擎、软硬件协同优化  等；希望能够提供共识效率与安全性，主要是为了要支撑大规模各种网络结构的主网。</p><h4 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h4><p>动态成员的准入机制，以及节点失效后的快速恢复机制。 （不能整个系统停下来加节点，应该是可以实时动态的。某几个节点出问题，我要删除的话，不能停下来删除，系统不能停）</p><p>去中心化联盟自治的管理机制，是通过多方提案投票表决方法还是别的方法，这些都要有机制。有人会怀疑，联盟链是不是真正能做到管理的公平机制 。</p><h4 id="高可扩展"><a href="#高可扩展" class="headerlink" title="高可扩展"></a>高可扩展</h4><p>编程可扩展，我们说支持多种编程语言的使用。当然越普通的编程语言越好；</p><p>存储方式可扩展，能不能支持多类型、多组织形式的数据可信存储；</p><p>支持预言机提供可信外部数据源服务；</p><p>支持跨链，实现同构链与异构链的跨链协同。</p><h4 id="区块链安全隐私"><a href="#区块链安全隐私" class="headerlink" title="区块链安全隐私"></a>区块链安全隐私</h4><p>中国要首先要全面支持我国加密算法和标准。</p><p>商业应用需要平台业务数据隐私保护，可以通过命名空间的方式在物理层面进行业务数据的分离？？  </p><p>更细粒度的隐私交易机制，实现交易可验证但是不可见。</p><p>基于可信执行环境等技术实现节点密钥管理和数据加密存储，基于默克尔、DAG等数据组织技术，防止文件被篡改。  </p><h3 id="链上链下数据协同技术？？？"><a href="#链上链下数据协同技术？？？" class="headerlink" title="链上链下数据协同技术？？？"></a>链上链下数据协同技术？？？</h3><p>CAP定理，就是一致性、可用性、分区容忍性 ；</p><p>区块链的不可能三⻆模型对应过来，它是去中心化、可扩展、安全 。</p><p>区块链系统需要通过链下系统扩展计算和存储能力。另一方面，现有系统链下需要与区块链对接以解决信息孤岛、防篡改等问题。</p><p>所谓的链上就是区块链，链下就是所有传统的信息系统。   要求链上链下数据，如果能够协同就能确<br>保关联性和一致性。</p><p>目前国内外对链上链下数据协同的技术才刚刚起步，也有一些协同研究，包括侧链和状态通道，为了提高性能和计算能力。</p><p>链上链下要同时考虑链上和链下，包括链下系统如何对接，数据隐私保护的对接、链下存储等。</p><h4 id="链上链下数据协同技术-的4大发展方向"><a href="#链上链下数据协同技术-的4大发展方向" class="headerlink" title="链上链下数据协同技术  的4大发展方向"></a>链上链下数据协同技术  的4大发展方向</h4><ol><li>大规模高性能点对点网络；</li><li>模块化安全密码学协议；</li><li>高性能可编程计算引擎；（可用不同的编程语言编写智能合约）</li><li>可定义的数据分发协议。</li></ol><h3 id="区块链监管技术发展趋势"><a href="#区块链监管技术发展趋势" class="headerlink" title="区块链监管技术发展趋势"></a>区块链监管技术发展趋势</h3><p>区块链的监管技术，这应该是  区块链健康和可持续发展的关键之一。  </p><ol><li>区块链节点的追踪与可视化；</li><li>联盟链穿透式监管技术；</li><li>公链主动发现与探测技术；</li><li>以链治链的体系结构及标准。 </li></ol><hr><p>2016年10月，工信部《中国区块链技术和应用发展白皮书》</p><h3 id="区块链-教育"><a href="#区块链-教育" class="headerlink" title="区块链+教育"></a>区块链+教育</h3><ul><li><strong>学生信用体系</strong> ：学历造假、论文造假、求职简历造假，用人单位、院校缺乏验证手段，蒙受信息不对称产生的损失，降低了学校与企业间、院校与院校间的信任。  <ul><li>帮助有良好记录的学生获得更多的激励措施，并构建起一个良性的信用生态 。 </li></ul></li></ul><ul><li><strong>产权保护</strong>：针对一些学术性实验、跨校组织的公开课以及多媒体教学资源，在网络上往往存在<strong>版权纠纷与学术纠纷</strong>，对学者以及研究人员缺乏相应的知识产权保护，影响了高等学府对学术研究的积极性。<ul><li>可为学术成果提供不可篡改的数字化证明，为学术纠纷提供了权威的举证凭据，降低纠纷事件消耗的人力与时间。    </li></ul></li></ul><p>2017[区块链技术在教育领域的应用模式与现实挑战*□杨现民 李新 吴焕庆 赵可云]</p><ul><li>优化教育业务流程，实现高效、低廉的教育资源交易。  <ul><li>在教育资源共享方面，利用分布式账本技术实现用户与资源间的直接联系，能够简化操作流程，提高资源共享效率，以此来促进教育资源的开放共享，解决资源孤岛问题。  </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零碎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法与数据结构学习必备</title>
      <link href="/2019/11/03/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E5%BF%85%E5%A4%87/"/>
      <url>/2019/11/03/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E5%BF%85%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cxyxiaowu.com/2917.html">程序员必须掌握的算法有哪些？谈谈这这几年学过的算法</a></p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="算法分析神器—时间复杂度"><a href="#算法分析神器—时间复杂度" class="headerlink" title="算法分析神器—时间复杂度"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU1MDE4MzUxNA==&mid=2247483867&idx=1&sn=6270b56b79cb74334eb4faf80de05f0a&scene=21#wechat_redirect">算法分析神器—时间复杂度</a></h3><ul><li> 刻画算法的运行时间 ：程序运行时间和问题规模 N 的函数关系</li><li> 时间复杂度 ： 我们一般只关心随着问题规模 n 趋于无穷时函数中对函数结果影响最大的项，也就是最高次项 </li><li> 一般我们会保留最高次项并忽略该项的系数 ， O代表了运行时间函数的一个渐进上界 </li><li> 时间复杂度可以表示某个算法的运行时间的趋势，大致地度量算法效率的好坏 </li><li> 时间复杂度的计算 </li><li> 得出运行时间的函数 </li><li> 对函数进行简化   </li></ul><h3 id="佩奇学编程-复杂度分析原来这么简单"><a href="#佩奇学编程-复杂度分析原来这么简单" class="headerlink" title="佩奇学编程 | 复杂度分析原来这么简单"></a><a href="https://mp.weixin.qq.com/s?__biz=MzIwODg1OTkzNw==&mid=2247484427&idx=1&sn=0ce7de439699dd3169ed8488cb5cd659&scene=21#wechat_redirect">佩奇学编程 | 复杂度分析原来这么简单</a></h3><ul><li>空间复杂度那块有一些不妥之处，要辨证看待</li></ul><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><h3 id="线性表（List）"><a href="#线性表（List）" class="headerlink" title="线性表（List）"></a>线性表（List）</h3><p>零个或多个数据元素的有限序列。除头尾节点，有且仅有一个前驱，一个后继。</p><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>逻辑上相邻的元素，位置上也相邻，三个重要属性：</p><ul><li>存储空间的起始位置</li><li>线性表的最大存储容量</li><li>线性表的当前长度</li></ul><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><h4 id="基础数据结构：【动画】如何轻松手写链表？"><a href="#基础数据结构：【动画】如何轻松手写链表？" class="headerlink" title="基础数据结构：【动画】如何轻松手写链表？"></a><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247486106&idx=2&sn=039eb52871cfe5428c7fcf1e770c8760&scene=21#wechat_redirect">基础数据结构：【动画】如何轻松手写链表？</a></h4><ul><li>熟悉节点的数据结构、理清思路、边界条件（输入边界（输入参数，为空，在链表中是否存在），特殊边界（头部，尾部））、手写代码（定义节点，增加节点，删除节点）、测试用例（普通测试、边界测试、特殊测试）</li></ul><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><ul><li><a href="https://blog.csdn.net/u013709270/article/details/53470428">跳跃表的原理及实现</a><ul><li>类似排序数组中二分插入，不过有层级的概念</li><li>大致看懂了，但是还没有自己实现！！</li></ul></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485133&idx=1&sn=5206c44c6ea6416d6c955e6eda29bc38&scene=21#wechat_redirect">以后有面试官问你「跳跃表」，你就把这篇文章扔给他</a></li></ul><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><ul><li>用数组描述的链表。——游标实现法</li><li><a href="https://blog.csdn.net/weixin_43340991/article/details/83475643">线性表-静态链表</a></li></ul><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247486111&idx=2&sn=c5861252c84f0c1fcd3e51e77f98e377&scene=21#wechat_redirect">三分钟基础知识：什么是栈？</a><ul><li>数组实现栈</li><li>链式栈</li></ul></li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><p><a href="https://sort.hust.cc/">十大经典排序算法</a></p><ul><li><strong>n</strong>：数据规模；<strong>k</strong>：“桶”的个数；<strong>In-place</strong>：占用常数内存，不占用额外内存；<strong>Out-place</strong>：占用额外内存；<strong>稳定性</strong>：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li></ul><p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-Lm9JtwbhXVOfXyecToy%2F-Lm9KQIJAMvCgJQzErQS%2F-Lm9KSPi7v-ygMtlI6Zr%2Fsort.png?generation=1565688978687703&alt=media"></p><h3 id="基于比较的排序算法：O-nlogn"><a href="#基于比较的排序算法：O-nlogn" class="headerlink" title="基于比较的排序算法：O(nlogn)"></a>基于比较的排序算法：O(nlogn)</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><a href="https://blog.csdn.net/nrsc272420199/article/details/82587933">快速排序</a></p><h3 id="不比较的排序算法"><a href="#不比较的排序算法" class="headerlink" title="不比较的排序算法"></a>不比较的排序算法</h3><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p><a href="https://www.cnblogs.com/eaglet/archive/2010/09/16/1828016.html">算法系列-计数排序</a></p><ul><li> 计数排序是一种算法复杂度 O(n) 的排序方法，适合于小范围集合的排序。也更适合于有多个重复元素的场景。</li><li> 需要知道这些元素的最大值和最小值，辅助数组的长度为 max - min +1，辅助数组每个元素存放的是值等于这个位置的数出现的次数，使用键值作为索引。只能作为整数的排序。</li><li> <a href="https://blog.csdn.net/haiki66/article/details/103308183">计数排序C++代码实现</a></li></ul><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p><a href="https://blog.csdn.net/developer1024/article/details/79770240">算法：排序算法之桶排序——链表实现</a></p><p><a href="https://www.geeksforgeeks.org/bucket-sort-2/">Bucket Sort-GeeksforGeeks——vector实现</a></p><ul><li>开辟空桶/list<ul><li>vector数组，大小为 N（N代表桶的个数） 的数组，数组中是大小为 M（M是一个桶的大小） 的 vector</li><li>用链表，开辟桶个数的空间存放head指针，这种存储方式，使用插入排序比较好</li></ul></li><li>遍历原数组，使用映射函数将数组元素映射至桶中<ul><li>对于链表来说，就是将元素进行排序的插入操作</li></ul></li><li>对桶中元素进行排序<ul><li>对链表来说，边插入，边排序</li><li>对vector来说，再调用一次排序</li></ul></li><li>将排好序的元素连接起来<ul><li>对链表来说，就是两个排好序的链表的合并</li></ul></li><li><a href="https://blog.csdn.net/haiki66/article/details/103314489">桶排序C++代码实现</a></li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p><a href="https://www.geeksforgeeks.org/radix-sort/">Radix Sort-GeeksforGeeks</a></p><ul><li>每一位排序的时候使用了 计数排序，计数数组只需要10位，0—10。</li></ul><p><a href="https://sort.hust.cc/10.radixsort">基数排序</a></p><ul><li>对于有负数的情况，那么就要多开辟计数数组的空间。比如 [0-9]对应负数，[10-19]对应正数。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="牛客"><a href="#牛客" class="headerlink" title="牛客"></a>牛客</h3><p><a href="https://wenku.baidu.com/view/be829ed084254b35eefd348b.html">稀疏矩阵的压缩存储-三元组表</a></p><ul><li>稀疏矩阵中的零元素非常多，全部存储会浪费很多空间，三元组&lt;row,col,val&gt;，表示第row行，第col列的元素值，不记录零元素，从而压缩稀疏矩阵进行存储。</li></ul><p><a href="https://blog.csdn.net/luoweifu/article/details/12071865">蚂蚁爬行问题</a></p><ul><li><a href="https://blog.csdn.net/xubinlxb/article/details/52529774">百度笔试编程题：爬行的蚂蚁（c++）</a><ul><li>关键点在于：因为每只蚂蚁都在以相同的速度运动，相遇后虽反向运动，仍相当于“穿透式”运动，即另一只反向运动的蚂蚁是当前的蚂蚁。两者交换身份。那么最长时间就是离杆子某一端最远的那个距离/速度。</li><li>以杆子的中点为基准，因为蚂蚁运动的方向不定，则所以蚂蚁掉落的最短的时间就是：<strong>max(靠近端点的最短距离)/速度</strong>；</li></ul></li><li>另一类问题是：给出蚂蚁初始位置和运动方向，给定时间T，求T时蚂蚁在杆子上的位置。<ul><li><a href="https://blog.csdn.net/u012881011/article/details/46787577">算法竞赛入门经典例题-蚂蚁</a></li><li>处理中比较好的一个点：就方向而言，左边L 置为-1，右边R 置为1，碰撞在同一个位置则为0。before记录初始状态，after记录终态，其实也就是 原位置 + T*d。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊DApp</title>
      <link href="/2019/10/26/%E4%BB%A5%E5%A4%AA%E5%9D%8ADApp/"/>
      <url>/2019/10/26/%E4%BB%A5%E5%A4%AA%E5%9D%8ADApp/</url>
      
        <content type="html"><![CDATA[<h2 id="Web开发者视角下解释以太坊"><a href="#Web开发者视角下解释以太坊" class="headerlink" title="Web开发者视角下解释以太坊"></a><a href="https://medium.com/@mvmurthy/ethereum-for-web-developers-890be23d1d0c">Web开发者视角下解释以太坊</a></h2><h3 id="web-App-在客户端-服务器架构下的工作原理"><a href="#web-App-在客户端-服务器架构下的工作原理" class="headerlink" title="web App 在客户端-服务器架构下的工作原理"></a>web App 在客户端-服务器架构下的工作原理</h3><p>如图 webApp</p><p><img src="https://i.loli.net/2019/10/26/GaObWcxqQBFyIDE.png" alt="webApp.png"></p><ul><li>web应用程序托管在主机提供商上</li><li>客户端（可以是浏览器、使用服务的另一个 api 等）向服务器发出请求</li><li>当客户机向服务器发出请求时，服务器执行它的操作，与数据库和/或缓存通信，读取/写入/更新数据库并为客户机服务</li><li>比如闲鱼，外卖，淘宝？提供了一个安全可信的中间商平台，商家和买家其实都要为其服务支付费用</li></ul><p>如果：每个人都能公开且安全地访问数据库，不必依赖这个 webapp 所有者来获取数据，可以节省佣金，也可以访问你的所有数据  ——  分布式 Dapps</p><h3 id="以太坊-Dapp-的架构"><a href="#以太坊-Dapp-的架构" class="headerlink" title="以太坊 Dapp 的架构"></a>以太坊 Dapp 的架构</h3><p>如图：ethereumDapp</p><p><img src="https://i.loli.net/2019/10/26/r8UEeV4cWCXZvTw.png" alt="ethereumDapp.png"></p><ul><li>每个客户机(浏览器)都与自己的应用程序实例进行通信</li><li>在使用应用程序之前，必须下载整个区块链</li></ul><h3 id="以太坊是什么？"><a href="#以太坊是什么？" class="headerlink" title="以太坊是什么？"></a>以太坊是什么？</h3><ol><li>数据库（Database）：存储数据；交易，区块</li><li>代码（code）：具体应用的逻辑，买、卖、取消，退款等，需要编写应用层代码，即合约。将合约编译成以太坊字节码，将字节码部署在区块链上。</li></ol><p>因此，以太坊存储你的数据，存储代码，并在 EVM 中执行代码。</p><p>web3.js 是一个 JavaScript 库，用来连接以太坊节点。将这个库包含（include）进 js 框架中，即可开始构建。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethereum </tag>
            
            <tag> DApp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊智能合约实践</title>
      <link href="/2019/10/25/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/10/25/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>接着上一节，<a href="%5Bhttps://haiki.github.io/2019/10/19/%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/%5D(https://haiki.github.io/2019/10/19/%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/)">从头搭建以太坊私链</a>。试着编写简单的智能合约，并在已经搭建好的链上部署。</p><p>具体参考 <a href="https://www.zhihu.com/people/li-kang-65/posts">李康</a> 的知乎内容。</p><h3 id="使用-Remix-编译合约"><a href="#使用-Remix-编译合约" class="headerlink" title="使用 Remix 编译合约"></a>使用 <a href="https://remix.ethereum.org/">Remix</a> 编译合约</h3><p>编写简单的测试合约</p><pre><code class="solidity">pragma solidity ^0.4.8;contract Test&#123;    uint256 public value;    function Test()&#123;        value = 123;    &#125;&#125;</code></pre><p>选择与合约版本对应的编译器，同时可以选择下面的 开启优化（Enable optimization），这个选项针对于比较大型的合约，对gas之类消耗比较大的情况会很有用。</p><p><img src="https://i.loli.net/2019/10/25/Sgdnjp5wZ3mWIR9.jpg" alt="compiler.JPG"></p><p>编译成功之后，向下拉上图，可以看到 compilation details。点击则可以看到一些详细信息。</p><p><img src="https://i.loli.net/2019/10/25/64HYaAMhw8FDpIn.jpg" alt="compilationDetails.JPG"></p><p>geth1 的控制台下操作如下：</p><p><img src="https://i.loli.net/2019/10/25/xOyVQvibYW6zSNm.jpg" alt="deployContract.JPG"></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/26789825">李康</a> ：我们在部署智能合约时使用的 data 字段是 Bytecode 而不是 Runtime Bytecode，这是因为以太坊上的节点收到合约部署交易时，运行 data 指定的字节码，执行完毕后返回的代码才是真正的合约代码，即 Runtime Bytecode。</p></blockquote><p>也就是说，红框内的 <code>data</code> 字段，是 Bytecode，黄框内的 <code>data</code>，是 Runtime Bytecode。合约的地址是蓝框内的。</p><hr><ul><li><p>对于有参数的智能合约，部署时，需要对参数进行填写！</p></li><li><p>对于下次使用合约，首先得到合约本身，然后 用 <code>.at(address)</code>，而不需要用 <code>new</code> ！</p></li><li><p>对于部署上去的合约，比如上图的 <code>test</code>实例，可直接键入 <code>test.address</code>从而查看合约的地址，键入 <code>test</code> 即可用 <code>json</code>  串的形式，返回 <code>ABI</code>，可以更清晰的去看此合约的接口，参数之类的，还有合约的地址，部署合约返回的交易散列。</p></li><li><p>合约调用常用命令：</p></li></ul><pre><code>eth.getTransactionReceipt(txHash)test.Test(para,...,&#123;from:eth.accounts[0],gas:30000,gasPrice:3,value:&#125;)</code></pre><h5 id="编写-资产聚合与分散合约时遇到的solidity语法问题"><a href="#编写-资产聚合与分散合约时遇到的solidity语法问题" class="headerlink" title="编写 资产聚合与分散合约时遇到的solidity语法问题"></a>编写 资产聚合与分散合约时遇到的solidity语法问题</h5><ul><li><p>字符串的操作库（0.4.x版本）：<a href="https://github.com/Arachnid/solidity-stringutils">https://github.com/Arachnid/solidity-stringutils</a></p><ul><li>（0.5.0版本）：<a href="https://github.com/tokencard/contracts/blob/master/contracts/externals/strings.sol">https://github.com/tokencard/contracts/blob/master/contracts/externals/strings.sol</a></li><li><a href="https://github.com/Arachnid/solidity-stringutils#concatenating-strings">https://github.com/Arachnid/solidity-stringutils#concatenating-strings</a></li></ul></li><li><p>『0016』 - Solidity Types - 玩转 Solidity 数组 （Arrays）：<a href="https://blog.csdn.net/liyuechun520/article/details/78410733">https://blog.csdn.net/liyuechun520/article/details/78410733</a></p></li><li><p>URL的API ：<a href="https://ropsten.etherscan.io/apis#transactions">https://ropsten.etherscan.io/apis#transactions</a></p></li><li><p>Solidity的Using for的使用：<a href="https://blog.csdn.net/qq_33764491/article/details/80604887">https://blog.csdn.net/qq_33764491/article/details/80604887</a></p></li><li><p>library</p></li><li><p>以太坊交易源码分析：<a href="https://blog.csdn.net/TurkeyCock/article/details/80485391">https://blog.csdn.net/TurkeyCock/article/details/80485391</a></p></li></ul><ul><li>go 和 solidity的类型对应关系 <a href="https://islishude.github.io/blog/2019/06/29/blockchain/%E4%BD%BF%E7%94%A8-Go-%E8%BF%9B%E8%A1%8C-Solidity-ABI-%E7%BC%96%E8%A7%A3%E7%A0%81/">https://islishude.github.io/blog/2019/06/29/blockchain/%E4%BD%BF%E7%94%A8-Go-%E8%BF%9B%E8%A1%8C-Solidity-ABI-%E7%BC%96%E8%A7%A3%E7%A0%81/</a></li><li>交易签名的过程：<a href="https://ethereum.iethpay.com/how-to-sign-and-hash-tx.html">https://ethereum.iethpay.com/how-to-sign-and-hash-tx.html</a></li><li>交易签名以及哈希值的计算：<a href="https://ethereum.iethpay.com/how-to-sign-and-hash-tx.html">https://ethereum.iethpay.com/how-to-sign-and-hash-tx.html</a></li><li>以太坊上的交易：<a href="https://ethfans.org/posts/the-business-of-sending-transactions-on-ethereum">https://ethfans.org/posts/the-business-of-sending-transactions-on-ethereum</a></li></ul><ul><li><p><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">Elliptic Curve Cryptography: a gentle introduction</a><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/</a></p></li><li><p><a href="https://ethereum.stackexchange.com/questions/25601/what-is-the-difference-between-web3-eth-sign-web3-eth-accounts-sign-web3-eth-p">What is the difference between web3.eth.sign, web3.eth.accounts.sign, web3.eth.personal.sign functions?</a></p></li><li><p>以太坊上发送交易的九种办法：<a href="https://ethfans.org/posts/the-business-of-sending-transactions-on-ethereum">https://ethfans.org/posts/the-business-of-sending-transactions-on-ethereum</a></p></li><li><p>What are ABI encoding functions in Solidity 0.4.24?：<a href="https://medium.com/@libertylocked/what-are-abi-encoding-functions-in-solidity-0-4-24-c1a90b5ddce8">https://medium.com/@libertylocked/what-are-abi-encoding-functions-in-solidity-0-4-24-c1a90b5ddce8</a></p><ul><li>abi.encode() returns (bytes)</li><li>abi.encodePacked() returns (bytes)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> solidity </tag>
            
            <tag> 智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊概念及API的整合与理解</title>
      <link href="/2019/10/22/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E5%BF%B5%E5%8F%8AAPI%E7%9A%84%E6%95%B4%E5%90%88%E4%B8%8E%E7%90%86%E8%A7%A3/"/>
      <url>/2019/10/22/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E5%BF%B5%E5%8F%8AAPI%E7%9A%84%E6%95%B4%E5%90%88%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Ethereum-Readme"><a href="#Ethereum-Readme" class="headerlink" title="Ethereum Readme"></a>Ethereum Readme</h2><h3 id="Executables"><a href="#Executables" class="headerlink" title="Executables"></a>Executables</h3><p>go-ethereum 项目的<code>cmd</code>文件夹下，有很多包装器/可执行文件</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>geth</td><td>主要的以太坊命令行接口（CLI）客户端，可运行全节点等类型节点。它可以被其他进程用作网关，通过暴露在HTTP，WebSocket和 IPC 传输之上的 JSON RPC 端点进入以太坊网络。</td></tr><tr><td>abigen</td><td></td></tr><tr><td>bootnode</td><td>以太坊客户端实现的精简版，只加入网络的节点发现协议，不运行其他的更高层应用层协议。可作为轻量级启动节点，协助私有网络中的节点发现。</td></tr><tr><td>evm</td><td>开发实用工具</td></tr><tr><td>gethrpctest</td><td>开发实用工具</td></tr><tr><td>rlpdump</td><td>开发实用工具</td></tr><tr><td>puppeth</td><td>CLI向导程序，帮助创建新的以太坊网络</td></tr></tbody></table><h3 id="Running-geth"><a href="#Running-geth" class="headerlink" title="Running geth"></a>Running <code>geth</code></h3><p>命令行标记：<a href="https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options">Command Line Options</a></p><p><code>geth [options] command [command options] [arguments...]</code></p><pre><code>ETHEREUM OPTIONS:LIGHT CLIENT OPTIONS:DEVELOPER CHAIN OPTIONS:ETHASH OPTIONS:TRANSACTION POOL OPTIONS:PERFORMANCE TUNING OPTIONS:ACCOUNT OPTIONS:API AND CONSOLE OPTIONS:NETWORKING OPTIONS:MINER OPTIONS:GAS PRICE ORACLE OPTIONS:VIRTUAL MACHINE OPTIONS:LOGGING AND DEBUGGING OPTIONS:METRICS AND STATS OPTIONS:WHISPER (EXPERIMENTAL) OPTIONS:DEPRECATED OPTIONS:MISC OPTIONS:</code></pre><p><code>geth console</code>命令 ：1）以 fast sync 模式开启 <code>geth</code>；2）启动 <code>geth</code>内建的  <a href="https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console">JavaScript console</a> （通过 <code>console</code> 子命令），调用所有的官方的 web3 methods <a href="https://github.com/ethereum/wiki/wiki/JavaScript-API">JavaScript API</a> 和 <code>geth</code> 本身的 <a href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs">management APIs</a> 。<code>console</code> 是可选项，不写时会 <code>attach</code> 到一个正在运行的 <code>geth</code> 实例（默认是生产节点），即 <code>geth attach</code>。</p><hr><h3 id="JavaScript-console"><a href="#JavaScript-console" class="headerlink" title="JavaScript console"></a><a href="https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console">JavaScript console</a></h3><ul><li><p>以太坊提供了一个  <strong>javascript runtime environment</strong> (JSRE)，可用在交互式（console）或 非交互式（script）模式。 Javascript console 暴露了所有的 web3 Javascript Dapp API( <a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethcall">JavaScript API</a> )和 admin API ( <a href="https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console#javascript-console-api">JavaScript Console</a> )</p></li><li><p>交互式应用，the JSRE REPL Console（<strong>Read, Evaluate &amp; Print Loop</strong>）：</p><ul><li><p><code>geth console</code> ： 开启 geth 节点，并打开控制台</p></li><li><p> <code>geth attach</code>：打开正在运行的 geth 实例的控制台 </p></li></ul></li><li><p>geth 节点在非默认的 ipc 端点下运行，则可以通过 rpc 接口连接</p></li><li><p>note：默认情况下 geth 开启时不启动 http 和 ws 服务，没有提供完整接口</p><pre><code>- `$ geth attach ipc:/some/custom/path `-  `$ geth attach http://191.168.1.1:8545`        -  `$ geth attach ws://191.168.1.1:8546 `</code></pre><ul><li>记录日志信息，不在控制台上打印内容： <code>$ geth --verbosity 5 console 2&gt;&gt; /tmp/eth.log</code></li><li>加载自定义 JavaScript 文件（加载常用函数，设置web3 合约对象）： <code>geth --preload &quot;/my/scripts/folder/utils.js,/my/scripts/folder/contracts.js&quot; console</code></li></ul></li><li><p>交互式应用：JSRE script mode</p><ul><li>还可以向JavaScript解释器执行文件。某种复杂形式：<code>$ geth --jspath &quot;/tmp&quot; --exec &#39;loadScript(&quot;checkbalances.js&quot;)&#39; attach http://123.123.123.123:8545</code></li></ul></li></ul><h3 id="JavaScript-API"><a href="#JavaScript-API" class="headerlink" title="JavaScript API"></a><a href="https://github.com/ethereum/wiki/wiki/JavaScript-API">JavaScript API</a></h3><p>要使应用程序在 Ethereum上 工作，可以使用 web3.js 库提供的 web3 对象。在底层，它通过RPC调用与本地节点通信。web3.js 处理任何暴露 RPC 层的 Ethereum 节点。web3 包含 <code>eth</code>对象（<code>web3.eth</code> 与以太坊区块链的交互），<code>ssh</code>对象（<code>web3.ssh</code> 与Whisper 的交互），<code>net</code>  <code>db</code> <code>ssh</code>。</p><ul><li>Adding web3</li><li>Using callbacks：本协议是与本地的 RPC 节点工作，它的所有功能默认使用同步的 HTTP 请求。</li><li>Batch requests</li><li>A note on big numbers in web3.js<ul><li>浮点数建议小数部分是 20位，所以 <code>balance</code> 一般都建议用 <code>Wei</code>，在给用户展示的时候再转换为 <code>ether</code>。</li></ul></li></ul><h3 id="management-APIs"><a href="#management-APIs" class="headerlink" title="management APIs"></a><a href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs">management APIs</a></h3><h4 id="Enabling-the-management-APIs"><a href="#Enabling-the-management-APIs" class="headerlink" title="Enabling the management APIs"></a>Enabling the management APIs</h4><p>要通过 Geth RPC 端点提供这些 api，需要用命令 <code>--$&#123;interface&#125;api</code> 命令行参数， <code>--$&#123;interface&#125;</code>可以是 <code>rpc,ws,ipc</code>。</p><p><code>geth --ipcapi admin,eth,miner --rpcapi eth,web3 --rpc</code></p><ul><li>在 IPC 接口上启用 admin、官方 DAp p和 miner API；</li><li>通过 HTTP 接口启用 官方的DApp 和 web3 API；</li><li>必须使用 <code>--rpc</code> 标志显式地启用 HTTP RPC 接口</li></ul><h4 id="List-of-management-APIs"><a href="#List-of-management-APIs" class="headerlink" title="List of management APIs"></a>List of management APIs</h4><ul><li><code>admin</code>: Geth node management</li><li><code>debug</code>: Geth node debugging</li><li><code>miner</code>: Miner and <a href="https://github.com/ethereum/wiki/wiki/Ethash-DAG">DAG</a> management</li><li><code>personal</code>: Account management</li><li><code>txpool</code>: Transaction pool inspection</li></ul><p>见 managementAPI 图</p><p><img src="https://i.loli.net/2019/10/23/UJheoOLq7MBvzxI.jpg" alt="managementAPI.JPG"></p><hr><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><ul><li><p><code>geth</code> 后面的多个标记可以写在配置文件中，如  <code>$ geth --config /path/to/your_config.toml</code>。</p></li><li><p>查看配置文件的内容，可使用命令： <code>$ geth --your-favourite-flags dumpconfig</code> 导出已存的配置。</p></li><li><p>只在 geth v1.6.0 以上的版本使用。</p></li></ul><h4 id="Docker-quick-start"><a href="#Docker-quick-start" class="headerlink" title="Docker quick start"></a>Docker quick start</h4><p><code>--rpcaddr 0.0.0.0</code>：如果想从其他容器或者主机访问 RPC。默认情况下，<code>geth</code> 绑定到本地的接口和 RPC 端点，外部无法访问。</p><h4 id="Programmatically-interfacing（连接）-geth-nodes"><a href="#Programmatically-interfacing（连接）-geth-nodes" class="headerlink" title="Programmatically interfacing（连接） geth nodes"></a>Programmatically interfacing（连接） <code>geth</code> nodes</h4><p>通过自己的程序去连接 <code>geth</code> 和以太坊网络，而不是手动地用 <code>console</code> 。<code>geth</code> 内置了对基于JSON-RPC 的 api 的支持：标准的 APIs（<a href="https://github.com/ethereum/wiki/wiki/JSON-RPC">JSON RPC</a>）和 geth 特定的 APIs（<a href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs">Management APIs</a>）。可以通过 HTTP，WebSockets 和 IPC（基于 UNIX 平台的 UNIX 套接字，windows 上称作 pipes） 去暴露。</p><p>默认情况下，IPC 接口打开，暴露 <code>geth</code>支持的所有APIs，HTTP 和 WS 接口需要手动打开，只暴露一部分 APIs，可通过配置关闭或者打开。</p><p>使用自己的编程环境的功能(库、工具等)通过 HTTP、WS 或 IPC 连接到 geth 节点。需要在所有传输上使用 JSON-RPC。可以对多个请求重用相同的连接!</p><p>HTTP based JSON-RPC API options：</p><ul><li><code>--rpc</code> Enable the HTTP-RPC server</li><li><code>--rpcaddr</code> HTTP-RPC server listening interface (default: <code>localhost</code>)</li><li><code>--rpcport</code> HTTP-RPC server listening port (default: <code>8545</code>)</li><li><code>--rpcapi</code> API’s offered over the HTTP-RPC interface (default: <code>eth,net,web3</code>)</li><li><code>--rpccorsdomain</code> Comma separated list of domains from which to accept cross origin requests (browser enforced)<ul><li>参见：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a></li></ul></li></ul><h4 id="JSON-RPC"><a href="#JSON-RPC" class="headerlink" title="JSON RPC"></a><a href="https://github.com/ethereum/wiki/wiki/JSON-RPC">JSON RPC</a></h4>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> API </tag>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从头搭建以太坊私链</title>
      <link href="/2019/10/19/%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/"/>
      <url>/2019/10/19/%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h3 id="安装geth-通过源码编译安装"><a href="#安装geth-通过源码编译安装" class="headerlink" title="安装geth -通过源码编译安装"></a>安装geth -通过源码编译安装</h3><p>参考<a href="https://media.consensys.net/how-to-build-a-private-ethereum-blockchain-fbf3904f337">这个</a>文档</p><ol><li><p><code>[haiki@localhost ~]$ mkdir ethereum</code></p></li><li><p><code>[haiki@localhost ~]$ cd ethereum</code></p></li><li><p><code>[haiki@localhost ethereum]$ git clone https://github.com/ethereum/go-ethereum.git </code></p></li><li><p><code>cd go-ethereum</code></p></li><li><p><code>make geth</code> 进行编译，得到可执行程序，得到编译结尾如下图，则表示编译成功。</p><p><img src="https://i.loli.net/2019/10/19/xMKDnI1kmlCSZNR.jpg" alt="makeGrth.JPG"></p></li><li><p>按照上图提示，需要在执行make的当前目录下执行 <code>./build/bin/geth</code>去安装 geth。此时，我所在的目录是 <code>/home/haiki/ethereum/go-ethereum</code>，如果已经进入到了 <code>/home/haiki/ethereum/go-ethereum/build/bin</code>，可以直接 <code>./geth</code>进行安装。其中，加 <code>./</code> 表示执行当前目录下的 geth 可执行文件。</p></li><li><p>现在，相当于 <code>/home/haiki/ethereum/go-ethereum/build/bin</code>目录下已经有了geth 这个可执行程序，相当于 windows 下的 .exe程序，在这个 bin 目录下，执行 <code>geth version</code>，查看安装是否成功，出现下图，则成功。</p><p><img src="https://i.loli.net/2019/10/19/ZGx3cWEPrCjQnYH.jpg" alt="gethVersion.JPG"></p></li><li><p>如果要使用这个程序，那么需要总是把geth所在的路径包含上，这时候，可以设置一个全局的环境变量，在哪里都可以执行用geth命令。</p><ol><li><code>vim /home/haiki/.bashrc</code></li><li><code>export GETHPATH=/home/haiki/ethereum/go-ethereum/build</code>，在原来的  <code>PATH</code>上加一个 <code>geth</code> 的路径： <code>export PATH=$GOPATH/bin:$GOROOT/bin:$PATH:$GETHPATH/bin</code></li><li>此时，在任何目录下（不必须是 <code>geth</code> 所在的目录下），执行 <code>geth version</code>都可以出现上图的结果。</li></ol></li></ol><h3 id="geth的使用"><a href="#geth的使用" class="headerlink" title="geth的使用"></a>geth的使用</h3><ol><li><p>创建账户</p><ol><li><p><code>[haiki@localhost ~]$ geth --datadir /home/haiki/ethereum/pqgeth account new</code>，按照提示，输入密码（这里是123456）。这个密码不能忘记，忘记没有找回选项。</p></li><li><p>此时在 <code>pqgeth</code> 下会生成一个 <code>keystore</code>文件，其中保存着生成的以太坊地址及用密码加密的私钥；如果不用 <code>--datadir</code> 参数，默认在用户空间的家目录（如/home/haiki）下生成 <code>.ethereum</code>文件（可以用 <code>ls -al</code> 查看），并在里面生成 <code>keystroe</code>文件。</p></li><li><p>按照屏幕显示的结果，即gethAccountNew图，可以知道，得到的地址，密钥文件的存放路径，以及一些安全提示信息。</p><p><img src="https://i.loli.net/2019/10/21/2bstUBRHALoW6Z1.jpg" alt="gethAccountNew.JPG"></p></li><li><p>可以按照相同的方式生成多个账户地址。</p></li></ol></li><li><p>定制私链的创世区块文件：见<a href="https://github.com/ethereum/go-ethereum/blob/master/README.md">官网</a></p><ol><li><p>编写 <code>genesis.json</code> 文件，这条链上的所有的节点都必须知晓这个文件，并达成共识。其中 <code>alloc</code>字段是预先分配有钱的账户，方便后序测试，例如转账这种。其中，chainId用来标识当前是哪条链，可以是任意正整数，network 默认是1，是一个网络。</p><pre><code>&#123;&quot;config&quot;: &#123;    &quot;chainId&quot;: 17,    &quot;homesteadBlock&quot;: 0,    &quot;eip150Block&quot;: 0,    &quot;eip155Block&quot;: 0,    &quot;eip158Block&quot;: 0,    &quot;byzantiumBlock&quot;: 0,    &quot;constantinopleBlock&quot;: 0,    &quot;petersburgBlock&quot;: 0  &#125;,  &quot;alloc&quot;: &#123;        &quot;d1f506b11eb311f955a208962905a526268babc6&quot;: &#123;                &quot;balance&quot;: &quot;100000000&quot;                &#125;        &#125;,  &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;,  &quot;difficulty&quot;: &quot;0x20000&quot;,  &quot;extraData&quot;: &quot;&quot;,  &quot;gasLimit&quot;: &quot;0x2f</code></pre></li><li><p>启动并初始化每个 <code>geth</code> 节点，确保参数设置正确： <code>geth --datadir ~/ethereum/pqgeth/ init genesis.js</code>。如图 genesis1。</p><p><img src="https://i.loli.net/2019/10/21/ygbG7d9CIJY8vo2.jpg" alt="genesis1.JPG"></p><ul><li>此时在 <code>datadir</code>目录下会生成一个 <code>geth</code>文件夹，包含 <code>chaindata</code>，<code>lightchaindata</code></li><li>这时，其实就可以运行 <code>geth </code>啦。但是如果只运行 <code>geth</code>，不加任何参数的情况下，结果如 geth_console1 图、 geth_console2 图，geth_console3 图，此时运行 <code>admin.nodeInfo</code>，可得到 geth_nodeInfo 图，此时的 <code>chainID</code> 和 <code>network</code> 均为1，和我们在 <code>genesis.json</code> 中设置的 <code>chainId:17</code>不一致。？？？</li></ul><p><img src="https://i.loli.net/2019/10/21/VYsRA9S2e7jOnic.jpg" alt="geth_console1.JPG"></p><p><img src="https://i.loli.net/2019/10/21/WIKqwodlz3jkZCn.jpg" alt="geth_console2.JPG"></p><p><img src="https://i.loli.net/2019/10/21/Uqk48FeoMwIt9jL.jpg" alt="geth_console3.JPG"></p><p><img src="https://i.loli.net/2019/10/21/W54UJ1eSxZdjmXq.jpg" alt="geth_console_nodeInfo.JPG"></p></li><li><p>启动一个节点实例，可以根据需要写很多参数，参数详见 <a href="https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options">Command Line Options</a>，为了避免每次写很多参数，可以在家目录的 <code>.bashrc</code> 中（就是配置全局环境的那个地方）编写以下命令：</p><pre><code class="bash">alias geth1=&#39;geth --verbosity 6 --identity &quot;haiki&quot; --rpc --rpcport &quot;20000&quot; --rpcaddr 0.0.0.0 --allow-insecure-unlock --etherbase &quot;d1f506b11eb311f955a208962905a526268babc6&quot;  --rpccorsdomain &quot;*&quot; --datadir &quot;/home/haiki/ethereum/pqgeth&quot; --port &quot;40000&quot; --nodiscover   --rpcapi &quot;db,eth,net,web3&quot; --networkid 2000 --nat &quot;any&quot; console 2&gt;&gt; &quot;/home/haiki/ethereum/pqgeth/node1.log&quot;&#39;</code></pre><ul><li>这样可以使得每次只用 <code>geth1</code> 命令即可相当于后面那一大串命令，而且，执行命令的结果重定向并追加至  <code>&quot;/home/haiki/ethereum/pqgeth/node1.log&quot;</code> 文件中。</li><li>此时可以直接运行 <code>geth1</code>, 屏幕上会得到 geth1图的输出，再次运行 <code>admin.nodeInfo</code>，可得 geth_nodeInfo1 图，此时的 <code>chainID</code> 和 <code>network</code> 分别为 <code>genesis.json</code> 和 <code>.bashrc</code> 中设置的值。</li><li>–allow-insecure-unlock：<a href="https://blog.csdn.net/wo541075754/article/details/98847308">以太坊geth新版本error：account unlock with HTTP access is forbidden</a><br><img src="https://i.loli.net/2019/10/21/talkRKxiQDOrAHv.jpg" alt="geth1.JPG"><br><img src="https://i.loli.net/2019/10/21/bwFu4fJ5zHXyp1v.jpg" alt="geth_nodeInfo1.JPG"></li></ul></li></ol></li><li><p>运行一个矿工：从这里开始的部分可以参考：<a href="https://medium.com/coinmonks/ethereum-setting-up-a-private-blockchain-67bbb96cf4f1">搭建以太坊私链</a></p><ol><li>可以在 <code>geth</code>命令后加选项 <code>--mine --minerthreads 1</code>，这样在启动 <code>geth</code> 时，则就说明会一直挖矿，但这样做使得有很多空块，占用内存，所以为了测试需要，一般用方法2；</li><li><code>geth1</code>，启动节点，控制台下输入 <code>miner.start(1)</code>，默认情况下是 <code>coinbase</code>节点挖矿，也可以用命令设置：<code>&gt;miner.setEtherbase(eth.coinbase)</code>。 不用挖矿时 <code>miner.stop()</code>；没有交易时挖出空块，也可以有奖励，有收入。这里可能遇到的问题：<a href="https://blog.csdn.net/tianlongtc/article/details/80026561">解决miner.start() 返回null</a>   </li></ol></li><li><p>转账</p><ul><li>首先要对发送方账户进行解锁，<code>&gt; ac1 = eth.accounts[0]，&gt; personal.unlockAccount(ac1)</code>，此时要求输入密码。</li><li><code>&gt; eth.sendTransaction(&#123;&quot;from&quot;:ac1,&quot;to&quot;:ac2,&quot;value&quot;:10&#125;)</code> ，<code>value</code> 对应的单位是 <code>wei</code>， 如果想用 <code>ether</code>，可以用 <code>amount = web3.toWei(3,&#39;ether&#39;)</code>这种，把 <code>value</code> 的参数设置为 <code>amount</code>。这里要注意的是，参数的键值 <code>“from”,&quot;to&quot;,&quot;val&quot;</code> 需要用双引号引起来。</li><li>用 <code>eth.getBalance(ac2)</code> 查看转账是否到账，因为 <code>ac1</code> 一直在挖矿，其资金一直在上涨。当测试完成时，可以停止挖矿。其他命令的尝试和使用参见 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#json-rpc-api">JSON RPC</a></li></ul></li><li><p>再启动一个节点，称作节点2，连接到已经搭建的区块链上</p><ol><li>新建一个存储节点信息，区块链信息，账户信息的文件夹，<code>mkdir ~/ethereum/go-ethereum/kkgeth</code></li><li>需要连接到第一个节点所在的区块链上，他们的创世块是一样的，这个节点也要初始化一下：<code> geth --datadir ~/ethereum/kkgeth/ init genesis.js</code>，注意这时用的 <code>datadir</code>。</li><li>和第一个节点做连接，则需要用到 <code>enode</code>，<code>enode</code> 的信息可以在运行的节点1中输入：<code>admin.nodeInfo.enode</code>得到。  这时候，要把 <code>geth1</code>中的 <code>----nodiscover</code> 去掉，让其他节点能够发现第一个节点。</li><li>和上面一样，开一个 <code>geth</code> 的实例<pre><code class="bash">alias geth2=&#39;geth --bootnodes enode://129265846efde605637ca4dee3e98e95cb466c386c64204bdedc84e98ff1e30d44e7e11e7fa6a561e8a3499acae31797da14749e3dab97af0fea682812f87b7f@127.0.0.1:40000 --verbosity 6 --identity &quot;pq&quot; --rpc --rpcport &quot;20001&quot; --rpcaddr 0.0.0.0  --allow-insecure-unlock --etherbase &quot;23b882359eed499a3b9cd06643c096e9ce048cfa&quot;  --rpccorsdomain &quot;*&quot; --datadir &quot;/home/haiki/ethereum/kkgeth&quot; --port &quot;40001&quot; --rpcapi &quot;db,eth,net,web3&quot; --networkid 2000 --nat &quot;any&quot; console 2&gt;&gt; &quot;/home/haiki/ethereum/kkgeth/node2.log&quot;&#39;</code></pre></li><li>运行 <code>geth2</code>，运行 <code>admin.addPeer(&#39;enode://129265846efde605637ca4dee3e98e95cb466c386c64204bdedc84e98ff1e30d44e7e11e7fa6a561e8a3499acae31797da14749e3dab97af0fea682812f87b7f@127.0.0.1:40000&#39;)</code> ，再输入 <code>net.peerCount</code> ，显示1，则表示已经连接到一个节点。可以用 <code>admin.peers</code> 查看当前连接到的节点信息，用 <code>net.peerCount </code> 查看网络中节点连接个数。这里有个奇怪现象，就是作为 bootnode 的那个节点，会连好多个节点。 在命令中只连接了一个节点，但是会显示其他的不知道哪里的节点。其他新增节点的命令可以看 ： <a href="https://www.netkiller.cn/blockchain/ethereum/faq.add.node.html">新增节点后不生效</a></li></ol></li></ol><h3 id="开启多个节点的脚本"><a href="#开启多个节点的脚本" class="headerlink" title="开启多个节点的脚本"></a>开启多个节点的脚本</h3><p>来自 <a href="https://victorjiangxin.github.io/">姜大佬</a> ，需要修改 端口base，地址什么的。</p><p>用法： <code>sh  startChain.sh  &lt;id&gt; </code> ，自动创建一条链，以及自动创建文件夹。如：<code>sh startChain.sh 1</code>。</p><pre><code class="shell">#!/usr/bin/shif [ &quot;&quot; = &quot;$1&quot; ];then    id=0else    id=$1firpcport_base=55000port_base=50000networkid=23333rpcport=$(($rpcport_base+$id))port=$(($port_base+$id))GETH_ROOT=&quot;$HOME/jx-eth&quot;datadir=&quot;$GETH_ROOT/data$id&quot;# judge if the chain has been initif [ ! -d $datadir ];then    if [ ! -f &quot;$GETH_ROOT/genesis.json&quot; ];then        echo &quot;Can&#39;t find genesis.json in dir $GETH_ROOT, plz re-create file gensis.json&quot;        exit 1    else        mkdir $datadir        geth --datadir $datadir init &quot;$GETH_ROOT/genesis.json&quot;    fifigeth --datadir $datadir --identity &quot;ETH-NODE$id&quot; --rpc --rpcport &quot;$rpcport&quot; --rpcaddr 0.0.0.0 --rpccorsdomain &quot;*&quot; --rpcapi &quot;personal,db,eth,net,web3&quot; --nodiscover --maxpeers 20 --networkid $networkid --port $port console</code></pre><p>tmux</p><p><a href="https://blog.csdn.net/Em_dark/article/details/82255248">linux 下安装npm和node</a></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> 私链 </tag>
            
            <tag> geth </tag>
            
            <tag> go环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2019/10/10/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/10/10/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<ul><li><p><a href="https://zhuanlan.zhihu.com/p/40133139">Linux 任务后台运行 —screen常用命令</a></p></li><li><p><a href="https://blog.csdn.net/hejunqing14/article/details/50338161">用screen 在后台运行程序</a></p><ul><li>Linux使用screen之后terminal就没法往上走看前面的输出内容了，<code>ctrl a+[</code> 然后使用上下                                                         </li></ul></li><li><p><a href="https://blog.csdn.net/stormbjm/article/details/9086163">linux下添加用户并赋予root权限</a></p><ul><li><a href="http://blog.chinaunix.net/uid-26000296-id-3496103.html">linux新建用户与权限修改</a></li></ul></li><li><p><a href="https://blog.csdn.net/li_101357/article/details/46778827">useradd 与adduser的区别</a></p><ul><li>用 addusr 比较好，如果用usradd，加 -m 参数，这样可以生成一个自己用户的目录</li></ul></li><li><p><a href="https://www.biaodianfu.com/linux-configure-make-make-install.html">Linux软件安装 ./configure,make,make install的作用</a></p></li><li><p><a href="https://cnbin.github.io/blog/2015/06/22/linux-slash-configure-prefix-ming-ling/">Linux ./configure –prefix 命令</a></p></li><li><p><a href="https://juejin.im/">Golang环境变量设置详解</a></p></li><li><p><a href="https://www.jianshu.com/p/4e699ff478a5">go环境变量配置 (GOROOT和GOPATH)</a></p><ul><li>GOROOT：是go的安装目录</li><li>GOPATH的值不能与GOROOT相同。用于指定我们的开发工作区(workspace),是存放源代码、测试文件、库静态文件、可执行文件的工作。</li></ul></li><li><p><a href="https://cnbin.github.io/blog/2015/06/22/linux-xiu-gai-huan-jing-bian-liang-path/">Linux 修改环境变量 PATH</a></p></li><li><p><a href="http://www.findme.wang/blog/detail/id/1.html">查看linux中某个端口（port）是否被占用</a></p></li><li><p>root用户修改其他普通用户的密码（忘记密码情况）</p><ul><li>不记得用户名 <code>cat/etc/shadow</code> ，查看用户名</li><li>知道用户名，输入  <code>  passwd 用户名</code></li></ul></li><li><p>以太坊上的交易：<a href="https://ethfans.org/posts/the-business-of-sending-transactions-on-ethereum">https://ethfans.org/posts/the-business-of-sending-transactions-on-ethereum</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="/2019/10/10/java/"/>
      <url>/2019/10/10/java/</url>
      
        <content type="html"><![CDATA[<ul><li><p><code>int[] num = new int[0];</code> 开辟一个大小为 0（即 <code>num.length == 0</code> ） 的空间，可以在 <code>empty array</code>上遍历，但是不能在 <code>null</code> array 上遍历。</p></li><li><p><code>readline();</code> 参见脱坑指南 <a href="https://blog.csdn.net/swingline/article/details/5357581#commentBox">被readLine()折腾了一把</a></p></li><li><p><code>.txt</code> 文件一定要用 <code>notepad++</code> 看，用电脑自带的记事本，看起来不会空行之类的，所有数据堆成一片。</p></li><li><p><a href="https://blog.csdn.net/ustcjackylau/article/details/42454779">java Queue中 remove/poll, add/offer, element/peek区别</a></p></li><li><p><a href="https://blog.csdn.net/foart/article/details/4295645">Java Math的 floor,round和ceil的总结</a></p></li><li><p><a href="https://blog.csdn.net/u010255818/article/details/52733256">java中Properties类的操作</a></p></li><li><p><a href="https://www.iteye.com/blog/tristan-wang-647729">Java读取Properties文件的六种方法</a></p></li><li><p><a href="https://blog.csdn.net/u010983881/article/details/49762595">HashMap 和 HashTable 的区别到底是什么？</a></p></li><li><p>ArrayList 和 LinkedList 的区别？</p></li><li><p><a href="https://blog.csdn.net/shlearry/article/details/50553986">java中 .currentTimeMillis的用法和含义</a></p></li><li><p><a href="https://www.iteye.com/blog/blackproof-1709336">Class.forName和ClassLoader.loadClass</a></p></li><li><p>switch case中，在某个case中定义的变量，在其他case中可以直接拿来使用。return和break的区别是，前者直接返回，不执行这个函数下面的语句了。而后者是直接跳出当前的switch语句。</p><pre><code class="java">import java.io.*;import java.util.*;public class test&#123;    public int[] testSwitch(int n)&#123;        switch(n)&#123;            case 1:            //boolean take = new boolean[10];                            int[] res = new int[10];                for(int i = 0; i &lt; 5; i++)                    res[i] = i;                return res;            case 2:                 res = new int[5];                for(int j = 0; j &lt; 5; j++)                    res[j] = j+10;                return res;        &#125;        return null;    &#125;    public static void main(String[] args)&#123;        test t = new test();        int[] res1 = new int[20];        res1 = t.testSwitch(2);        for(int k = 0; k &lt; res1.length; k++)            System.out.println(res1[k]+&#39;\n&#39;);            &#125;&#125;</code></pre></li><li><p><a href="http://outofmemory.cn/code-snippet/2099/java-usage-FilenameFilter-shaixuan-file">java使用FilenameFilter筛选文件</a></p><ul><li><a href="https://stackoverflow.com/questions/19932962/use-of-filenamefilter">stackoverflow</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA的使用：提升看源码效率</title>
      <link href="/2019/10/09/IDEA%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/10/09/IDEA%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="IntelliJ-IDEA-常见文件类型的图标介绍"><a href="#IntelliJ-IDEA-常见文件类型的图标介绍" class="headerlink" title="IntelliJ IDEA 常见文件类型的图标介绍"></a>IntelliJ IDEA 常见文件类型的图标介绍</h3><p>参见博客: <a href="https://blog.csdn.net/qq_35246620/article/details/64157559">IntelliJ IDEA 常见文件类型的图标介绍</a></p><h3 id="IDEA中配置参数，运行main函数"><a href="#IDEA中配置参数，运行main函数" class="headerlink" title="IDEA中配置参数，运行main函数"></a>IDEA中配置参数，运行main函数</h3><p>对于java程序，编译（build）指令： <code>javac</code>，运行（run）指令： <code>java</code> ，需要安装 JDK（这里又有Oracle JDK 和 OpenJDK，自行百度区别和使用），JRE。</p><p>对于windows 配置 <code>JAVA_HOME</code>，<code>PATH</code>，<code>classpath</code> 的方法见：<a href="https://blog.csdn.net/haiki66/article/details/88758199">Java中JAVA_HOME, PATH,CLASSPATH的作用和配置值</a></p><p>IDEA下可以有两种运行程序的方法：</p><ol><li>最上方工具栏分别找到 <code>Build</code>  和 <code>Run</code>对程序进行编译，运行。使用这种方法时，如果main函数运行时需要传入参数，参数的配置方法为：鼠标指向最上面工具栏的：<code>Run</code> ，选中左键进入<code>Edit configurations</code>。如下图所示。其中<code>program argument1</code>处依次填入需要的参数。</li></ol><ul><li>这里我们可以留意到的是：<code>Main class</code> 的书写形式， main 函数所在的类，是以包名的形式呈现的。那么对于不同类中的 main 函数，通过修改 类名即可。这样简单的配置之后，我们就可以直接用 <code>Build</code> 和 <code>Run</code> 来处理程序啦~ 很多命令的处理过程，都由IDE进行</li></ul><p><img src="https://i.loli.net/2019/10/09/oLgrNqhYudD5pbT.jpg" alt="IDEA.JPG"></p><ol start="2"><li>在终端（terminal）下运行输入 <code>javac</code> 和 <code>java</code> 编译运行程序（也就是IDE帮我们做的一些命令）。<ul><li><code>javac -classpath &lt;lib&gt; -sourcepath &lt;src&gt; -d &lt;bin&gt;</code></li><li><code>java -classpath &lt;lib&gt;&lt;:/;&gt;&lt;bin&gt; &lt;main函数所在类&gt;</code></li><li>其中，凡是用 <code>&lt;&gt;</code>框起来的都是要根据自己的实际情况进行更改的。<ul><li><code>-classpath</code>也可以简写为 <code>-cp</code>，是用来加载外部包的，比如你写的项目里面，用到了一些jar 包，那么需要把这些jar包的路径告诉 javac 这个可执行程序，也就对应于 <code>&lt;lib&gt;</code>，比如我的这个项目，某些 jar 包的路径是 <code>./lib/</code>，表示当前项目的当前文件夹下的lib文件夹下。</li><li><code>-sourcepath</code> 需要输入的是当前项目所在的文件夹，查看当前项目所在路径可以试错，也可以自行百度。示例：<code>./src/</code></li><li><code>-d</code> 是指：编译之后生成的 <code>.class</code> 文件放在哪个文件夹下，这个的文件路径可以自己设置，一般在当前项目下，新建一个文件夹，如  <code>./bin</code> 或者 <code>./out</code> 。我们要知道的是，java 运行的都是 <code>.class</code> 文件。</li><li><code>javac</code> 和 <code>java</code> 中的  <code>&lt;lib&gt;&lt;bin&gt;</code> 都一样。需要注意的是，对于 <code>java</code> 命令中 &lt;&gt;<code>&lt;:/;&gt;</code> 是说，当在unix下使用此命令时，用冒号，在window下使用时，用分号。</li><li><code>&lt;main函数所在类&gt;</code> 就是方法 1 中提到的 以包名形式的包含main函数的类名。</li></ul></li></ul></li></ol><h3 id="IDEA中查看类继承关系"><a href="#IDEA中查看类继承关系" class="headerlink" title="IDEA中查看类继承关系"></a>IDEA中查看类继承关系</h3><p>鼠标点在类名上，右键，在复选框中找到 <code>Diagrams</code> —&gt; <code>show diagrams</code> ，则可以查看类的继承关系。</p><p><img src="https://i.loli.net/2019/10/10/EWPbBq7cZnfNDKe.png" alt="IDEA1.png"></p><h3 id="函数调用关系——SourceInsight"><a href="#函数调用关系——SourceInsight" class="headerlink" title="函数调用关系——SourceInsight"></a>函数调用关系——SourceInsight</h3><p>增：10月11在意外中发现了别人写的一篇博客，好仔细！推荐！</p><p>[C 源码阅读之函数(Function/Method)调用树图( Call Graph)及数据结构依赖图][<a href="http://blog.sina.com.cn/s/blog_6b6ab0890101qd9j.html]">http://blog.sina.com.cn/s/blog_6b6ab0890101qd9j.html]</a></p><p>这个有两种方式：</p><ol><li><p>鼠标点击需要查看的函数名，在上方的菜单栏查找一个图标，如下图所示，则会显示这个函数的调用关系。</p><p><img src="https://i.loli.net/2019/10/10/8LRf45onVOvhYju.png" alt="SourceInsight.png"></p></li><li><p>鼠标右键函数名，选择 <code>Show in Relation Window</code>，会出现和 1 一样的结果。</p><ol><li>看下图，左下角会有一些小的选择，按照箭头标注，最左边点击一下，会出现列表形式的函数调用关系，在第一列，是 <code>name</code> ，默认情况下，函数是以字母序排序的，如果想按照函数调用顺序，可以鼠标左键点一下 <code>name</code>，会以英文形式提示你，现在是以什么排序的。类似文件夹下，以创建时间，或者修改日期等排序那种。这个选择好之后，点击第二个箭头指的，显示出的关系图就是按照你选定的函数的出现方式。（升序，降序，出现顺序）</li><li> 接着就是调用关系是横着显示还是竖着显示；</li><li>再接着是设置。</li></ol></li></ol><p><img src="https://i.loli.net/2019/10/10/cZkgdznxXUWfowR.png" alt="SourceInsight1.png"></p><p><img src="https://i.loli.net/2019/10/10/ZKvNI78q164dm3H.png" alt="SourceInsight3.png"></p><p>还可以设置要查看的函数调用关系，是查看当前函数调用（calls）了哪些函数，调用关系显示几层。这里主要想提及的是 <code>View Relationship</code> 这里，这个选择直接决定了显示什么关系。可以看到，关系主要是用于 <code>Types（类型）、Functions（函数）、Variables（变量）、class（类）等</code> ， 需要注意的是，类的关系也可以展示，但是我更喜欢用 IDEA 的类继承关系。根据自己的需要，选择想要查看的关系图，如函数调用关系，那么要设置的是 <code>functions</code>，<code>Calls</code>表示查看这个函数开始调用了哪些，<code>calls and callers</code> 则表示此函数的调用 + 对此函数的调用。<code>reference </code> 表示引用。</p><p><img src="https://i.loli.net/2019/10/10/NibgmIKpLftDQcG.png" alt="SourceInsight4.png"></p><h3 id="IDEA中-显示函数的用法"><a href="#IDEA中-显示函数的用法" class="headerlink" title="IDEA中 显示函数的用法"></a>IDEA中 显示函数的用法</h3><p><code>Alt + F7</code>，下面会显示出哪里使用了这个函数。</p><h3 id="IDEA中-类中的函数及变量等概览"><a href="#IDEA中-类中的函数及变量等概览" class="headerlink" title="IDEA中 类中的函数及变量等概览"></a>IDEA中 类中的函数及变量等概览</h3><p><code>Alt + 7</code></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非暴力沟通摘录及观后感</title>
      <link href="/2019/10/06/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%E6%91%98%E5%BD%95%E5%8F%8A%E8%A7%82%E5%90%8E%E6%84%9F/"/>
      <url>/2019/10/06/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%E6%91%98%E5%BD%95%E5%8F%8A%E8%A7%82%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="chapter-1-—-让爱融入生活"><a href="#chapter-1-—-让爱融入生活" class="headerlink" title="chapter 1 — 让爱融入生活"></a>chapter 1 — 让爱融入生活</h3><blockquote><p>感激生活的赐予，而不贪心。</p></blockquote><p>对于一些事，是经历过的也好，期盼中的也好，总是想“如果怎样就好了”。会对已有的，不论好坏的结果有不满，会对未来未发生的，不论好坏的结果有不切实际的幻想。珍惜生活中得到的，就是最好的。</p><blockquote><p>虽然每个人的价值观和生活方式或许不同，但作为人却有着<strong>共同的感受和需要</strong>。这样，在发生矛盾和冲突的时候，运用非暴力沟通，我们将能专注于彼此的感受和需要，从而促进倾听、理解以及由衷的互助。</p></blockquote><p>举个很简单的例子，比如A喜欢B，并告诉了B，而B可能拒绝A，并且给A的理由是：我们不合适，我们三观有冲突，生活方式不一样等等；或者说A和B的交流不是很顺畅，A会和别人说，我和B三观不同，没什么好聊的。虽然这些都是需要考量的因素，也是可以理解的点。但是我还是很喜欢这句话，作为人，有着共同的感受和需要。不能因为一些先天的外界因素，限制了我们的发展，并片面化自己的交友或者生活。</p><blockquote><p>爱的能力取决于审美能力。</p></blockquote><p>有一双明察秋毫的眼睛太重要了。不管做啥事，都要擦亮你的眼睛。而“擦亮”却不是抹抹眼睛就可以的事，它需要我们培养一种审美能力。比如，如何让找到的男朋友，或者喜欢的男生不是渣男。在这一点上，我一直觉得自己是瞎子。但是在交朋友上，我感觉自己可以欣赏到各种美。</p><blockquote><p>非暴力指暴力消退后，自然流露的爱。</p></blockquote><blockquote><p>非暴力沟通的四个要素：</p><ol><li>观察</li><li>感受</li><li>需要</li><li>请求</li></ol></blockquote><p>对现状进行观察，表达自己的感受，了解是哪些需要（价值、愿望等）导致的需要，为了改善生活，提出请求。</p><p>对于别人的质疑，指责等，不要先想着如何去反驳，表达自己的感受，可以学着倾听，对于别人的问题，倾听其包含的情感和需要。通过问题，去了解对方的心灵和愤怒。让对方知道，我们确实是在感受着他们的感受。</p><h3 id="chapter-2-是什么蒙蔽了爱"><a href="#chapter-2-是什么蒙蔽了爱" class="headerlink" title="chapter 2 - 是什么蒙蔽了爱"></a>chapter 2 - 是什么蒙蔽了爱</h3><p><strong>道德评判</strong></p><blockquote><p>对他人的评价实际上反映了我们的需要和价值观。</p></blockquote><blockquote><p>分类和评判提倡的是暴力。</p></blockquote><blockquote><p>要是达不到自己的期待，我也会觉得自己有毛病。我一心想分析和确定错误的性质，而忽视自己和他人的需要。因此，如果女友想多一些体贴，那她就“太粘人了”。可是，如果我想多一些体贴，那她“冷漠得像个木头”。如果同事更关心细节，他就是“有强迫症”。反之，如果我更在乎细节，他就是“粗心大意”。</p></blockquote><blockquote><p>“暴力是不好的。杀人者是邪恶的。”然而，如果我们从小就学习爱的语言 ，我们将会直接说出我们的价值观，而不会指责他人。此时我们就会说:“对于使用暴力来解决问题，我很担心；我主张通过其他方式来解决冲突。”</p></blockquote><p><strong>进行比较</strong></p><blockquote><p>比较也是一种评判。</p></blockquote><p><strong>回避责任</strong></p><blockquote><p>我们可以用负责任的语言代替回避责任的语言。</p></blockquote><p>回避责任的语言包括：“我不得不”，“你让我”。在这个方面感觉自己做的还可以，因为性格的原因，其实很多事都是自己选择了之后做的。因为都会带有自己的目的性。比如，我要参加学生会，因为我想去组织活动，认识更多的人，最好是能遇见一个男朋友。但是我不想成为更高层管理负责的人，是因为我不想处理其中的社交关系。所有不得不做的事，而且已经做了的事，其背后一定是有满足自我的某种目的。所以，其实没什么不得不做的事。</p><blockquote><p>一旦意识不到我们是自己的主人，我们就成了危险人物。</p></blockquote><p>少一些唯唯诺诺，多一些果断和自己的想法。</p><p><strong>强人所难</strong></p><blockquote><p>长期以来，我们强调人性本恶以及通过教育来控制天性。这导致了我们对自己的感受和需要常常心存疑虑，以致不愿去体会自己的内心世界。</p></blockquote><blockquote><p>人们越是习惯于评定是非，他们也就越倾向于追随权威，来获得正确和错误的标准。一旦专注于自身的感受和需要，我们就不再是好努力和好属下。</p></blockquote><p>无需言，做自己。己所不欲，勿施于人。</p><h3 id="chapter-3-区分观察和评论"><a href="#chapter-3-区分观察和评论" class="headerlink" title="chapter 3 - 区分观察和评论"></a>chapter 3 - 区分观察和评论</h3><blockquote><p>不区分观察和评论，人们将倾向于听到批评。</p><p>不带评论的观察是人类智力的最高形式。</p></blockquote><p>观察是将事实描述出来，而评论会在事实的基础上加入个人情感。</p><h3 id="chapter-4-体会和表达感受"><a href="#chapter-4-体会和表达感受" class="headerlink" title="chapter 4 - 体会和表达感受"></a>chapter 4 - 体会和表达感受</h3><blockquote><p>示弱有助于解决冲突。</p></blockquote><blockquote><p>区分感受和自我评价。</p></blockquote><blockquote><p>为了清晰地表达感受，我们编制了以下的词汇表。<br>（1）下列词语可用来表达我们的需要得到满足时的感受:</p><p>兴奋，喜悦 ，欣喜， 甜蜜，精力充沛，兴高采烈<br>感激，感动，乐观，自信，振作，振奋，开心<br>高兴，快乐，愉快，幸福，陶醉，满足，欣慰，心旷神怡，喜出望外<br>平静，自在，舒适，放松，踏实，安全，温暖，放心，无忧无虑</p><p>（2）下列词语可用来表达我们的需要没有得到满足时的感受:</p><p>害怕，担心，焦虑，忧虑，着急，紧张，心神不宁，心烦意乱，忧伤，沮丧，灰心丧气，气馁，泄气，绝望，伤感，凄凉，悲伤，恼怒，愤怒，烦恼，苦恼，生气，厌烦，不满，不快，不耐烦，不高兴，震惊，失望，困惑，茫然，寂寞，孤独，郁闷，难过，悲观，沉重，麻木，精疲力尽，委靡不振，疲惫不堪，昏昏欲睡，无精打采，尴尬，惭愧，内疚妒忌，遗憾，不舒服</p></blockquote><p>不要总是你觉得，可以直接说出描述心情的形容词。</p><h3 id="chapter-5-感受的根源"><a href="#chapter-5-感受的根源" class="headerlink" title="chapter 5 - 感受的根源"></a>chapter 5 - 感受的根源</h3><blockquote><p>别人的行为可能会刺激我们，但并不是我们感受的根源。</p></blockquote><blockquote><p>非暴力沟通强调，感受的根源在于我们自身。我们的需要和期待，以及对他人言行的看法，导致了我们的感受。</p></blockquote><p>一般表达感受的形式是：他们做了XXX，我很XXX，因为我需要XXX。</p><blockquote><p>听到不中听的话时，我们可以有四种选择：1）责备自己；2）指责他人；3）体会自己的感受和需要；4）体会他人的感受和需要。</p></blockquote><blockquote><p>如果我们想利用他人的内疚，我们通常采取的办法是，把自己不快的感受归咎于对方。家长也许会和孩子说:“你成绩不好让爸爸妈妈伤透了心！”言下之意是，他们快乐或不快乐是孩子的行为造成的。看到父母的痛苦，孩子可能会感到内疚，并因此调整行为来迎合他们。遗憾的是，这种调整只是为了避免内疚，而非出自对学习的热爱。</p></blockquote><p>不要利用别人的内疚，把责任推到别人身上。因为，你只是得到了一时的妥协，而没有从根本上解决问题。</p><blockquote><p>批评往往暗含着期待。对别人的批评实际上间接表达了我们尚未满足的需要。</p></blockquote><p>之所以会将无法满足自己愿望的事归结给别人，是因为，自己有所期待，但是并未通过对他人的期待而被满足。比如国庆去看烟花，去了灯市口，而不是珠市口，没看到烟花的时候，内心是非常难过的，但是把这种难过归咎于给我们指路的人，刚开始不说清楚，我们都到了才说，因为只有这样的抱怨才能让我没有看到烟花这件事有一个解释。然而，可以表达的感受可以换成这样：我非常想看烟花，我去了他第一次给我们说的地点，我认为也可能会看到烟花，寻思着位置也差不多。</p><blockquote><p>如果我们不看重自己的需要，别人可能也不会。实际上，如果直接说出需要，获得积极回应的可能性就会增加。</p></blockquote><p>我累了，我想休息。而不是说自己今天干了什么什么一大堆没用的。</p><p>勇敢的表达自己的想法和需要，有时候就得牺牲别人的需要。</p><blockquote><p>为他人的情绪负责，牺牲自己迎合他人，代价实在很大。</p></blockquote><blockquote><p>对于大多数人来说，<strong>个人成长</strong>一般会经历三个阶段:（1）“情感的奴隶”—我们认为自己有义务使他人快乐；（2）“面目可憎”时期——此时，我们拒绝考虑他人的感受和需要；（3）“生活的主人”——我们意识到，虽然我们对自己的意愿、感受和行动负有完全的责任，但无法为他人负责。与此同时，我们还认识到，我们无法牺牲他人来满足自己的需要。</p></blockquote><blockquote><p>真诚待人比委屈求全更为可贵。如果别人感到不安，我们可以认真地倾听，但无须责备自己。</p></blockquote><h3 id="—随记—"><a href="#—随记—" class="headerlink" title="—随记—"></a>—随记—</h3><p>2019.10.8 - 今日学习速递 - 胡伟武老师的讲座摘录</p><p>我的感受：有的人视时间如金，而有的人却挥金如土。</p><blockquote><p>千里马的栅栏已经打开，不要眷恋原来的“草料”。</p><p>不以物喜，不以己悲；受辱不辩，闻谤不咎。</p><p>学而时习之，不亦乐乎。习是实践。</p><p>失败是成功之母，而学习是成功之父。</p><p>通过思考把握事物的简单性。</p><p>因戒生定，因定生惠。</p><p>成熟：当你取得成就不去说了，当受了委屈不去辩解。</p></blockquote><h3 id="chapter-6-请求帮助"><a href="#chapter-6-请求帮助" class="headerlink" title="chapter 6 - 请求帮助"></a>chapter 6 - 请求帮助</h3><p>今天看到的很多东西，都和自己息息相关，非常的受用，所以摘录了很多段，就不分开写了。</p><ul><li><p>不要总是提醒自己要避免出现什么，而是提醒自己主动做些什么。</p></li><li><p>我们提出的请求越具体越好。如果我们的意思含糊不清，别人就难以了解我们到底想要什么。此外，使用抽象的语言还会使我们无法深入了解自己。请求他人采取具体的行动将揭示我们的动机。</p></li><li><p>许多来向我求助的人后来发现，他们感到沮丧或灰心，很大程度上是因为他们不清楚自己对他人究竟有什么样的期待。</p></li><li><p>如果我们<strong>只是表达自己的感受</strong>，别人可能就不清楚我们想要什么。如果一个人<strong>提出了明确的请求，却没有提及感受和需要</strong>，也有能导致交流的困难。</p></li><li><p>就像那位乘火车去机场的先生，我们希望有人倾听并了解我们的处境。或者，我们期待的是如实的反馈—我们想了解他人的真实想法。当然，有时我们希望他人采取某种行动。对自己的认识越深刻，表达越清楚，我们就越可能得到称心的回应。</p></li><li><p>当对方给予反馈，表达我们的感激；如果对方不愿反馈，倾听他们的感受和需要。</p></li><li><p>了解他人的反应：</p><ul><li>对方此时此刻的感受</li><li>对方正在想什么</li><li>对方是否接受我们的请求</li></ul></li><li><p>参加集体讨论时，说清楚我们希望得到怎样的反馈，是至关重的。如果不清楚发言的目的，我们的讨论也许只是在浪费时间，而无满足任何人的需要。此外，如果不清楚发言者是否已经得到满意的答复，讨论就可能无目的地继续下去，而无法满足任何人的需要。</p><ul><li>“我不清楚你为什么要提到这篇文章。你是否可以告诉我们，你期待得到怎样的反馈呢？”这样的提醒也许就可以避免浪费宝贵的会议时间。</li></ul></li><li><p>如何区分命令和请求:请求没有得到满足时，提出请求的人如果批评和指责，那就是命令；如果想利用对方的内疚来达到目的，也是命令。</p></li><li><p>一旦人们认为我们是在强迫他们，他们就会不太想满足我们的愿望。</p></li><li><p>一旦人们相信我们看中彼此的感情，并能兼顾对方的需要，那么他们也就会相信我们所表达的愿望是请求而非命令。</p></li></ul><h3 id="chapter-7-用全身心倾听"><a href="#chapter-7-用全身心倾听" class="headerlink" title="chapter 7 - 用全身心倾听"></a>chapter 7 - 用全身心倾听</h3><p>今日份的依旧纯摘抄，让我想到了很多类似的场景。</p><p>比如舍友给我说：“我把我男朋友惹生气了，因为他有时候真的是太自信了”。我可能会急于表达自己的理解和关怀，回答：“没事的”，接着又觉得这样不行，又开始神补刀，“你下次不要这样说他啦，他也有自己的性格吧啦啦啦”。这样导致的后果就是舍友也不愿意和我继续分享她的感受了。学了这一章，我觉得这样说比较好：“你是有点讨厌他的自信？希望他能够多一点谦逊？”。  是这么个套路吗。。。问号.jpg。</p><ul><li>“尽管有种种相似之处，生活的每时每刻就像一个刚出生的婴儿，一张新的面孔，我们从未见过，也不可能再次见到。我们无法停留在过去，也无法预见我们的反应。我们需要不带成见地感受变化。我们需要用全身心去倾听。”</li><li>不要急着做什么，站在那里。</li><li>试图分析问题妨碍了我们与他人的联系。如果我们只关心别人说了什么，并考虑他的情况符合哪种理论，我们是在诊断人—我们并没有倾听他们。在非暴力沟通中，倾听他人意味着，放下已有的想法和判断，一心一意地体会他人。倾听的这种品质体现了它与理解以及同情之间的区别。</li><li>作家约瑟夫·坎伯（ Joseph Campbell）说道:“为了幸福，必须把‘别人怎么看我’这个问题放在一边。”一旦我们把所谓的批评和指责看作是来自他人的礼物—为处于痛苦中的人提供服务的机会，我们就会感到这种幸福。</li><li>联合国前秘书长汉马斯克德（ Dag Hammarskjold）曾经说道:“你越是留意自己内心的声音，就越能够听到别人的声音。”一旦我们能够敏锐地察觉并照顾自己的感受和需要，我们就有能力迅速调整好状态，来倾听他人如果做不到这一点，我们还有另外两种选择。<br>其中一种选择是大声地提出请求。不过，如果对方正处于激烈的情绪中，他也可能无法留意我们的感受和需要。这时，我们的另一种选择是，换一个环境。我们需要时间和间来调整状态，等平静下来了，再回来。</li></ul><h3 id="chapter-8-倾听的力量"><a href="#chapter-8-倾听的力量" class="headerlink" title="chapter 8 - 倾听的力量"></a>chapter 8 - 倾听的力量</h3><blockquote><p>非暴力沟通鼓励我们表达自己最深的感受和需要，因此，我们有时许会发现运用非暴力沟通是富有挑战性的。然而，通过倾听，我们将意识到他人的人性以及彼此的共通之处，这会使自我表达变得容易些。我们越是倾听他人语言背后的感受和需要，我们就越不怕与他们坦诚地沟通。我们最不愿意示弱的时候往往是因为担心失去控制想显得强硬的候。</p></blockquote><p>示弱有时候是一种人生智慧，尤其是我这样比较强势的女生。每个人都需要有台阶下，要有一种温和的心态和姿态去和别人交流，相处。</p><blockquote><p>绝望有时也许会给一个人带来灵感！<br>你和我们说，在一个生气的人面前，永远不要用‘不过’‘ “可是”，“但是”之类的词语。一开始，我很想为自己辩护，我想和他说，‘可是我们真的没房间’。幸好，在那时，我想起了那句话。我一直记得。</p></blockquote><p>说实话，从小和父母一起看那种刑侦片，或者谍战片，在电视屏幕里见识过太多人。有那种小偷，绑匪，毒贩子、毒枭等等，一直都很害怕电视中，绑架人质的事情发生在自己的身上。自己的长大，意味着电视上的画面，在自己身边，乃至自己身上发生的可能性都增加。在微博上会看到一些社会热点，有人突然拿着菜刀看向路人等等。对于这些恶意的事件，面对这些意外的伤害，我一直在思考，如果当事人是自己，该如何处理。看了这一章，我觉得，在一些极端情况下，我依然要相信人性的善，要倾听对方的感受和需要。有没有用我不知道，但我确定，如果鲁莽地挣扎，绝对没用。</p><blockquote><p>当别人说“不”的时候，我们常常会认为他们是在拒绝我们。有时，我们甚至还会觉得自己受到了伤害。然而如果我们能够体会他人的感受和需要，我们也许就会发现是什么使他们无法答应我们的请求。</p></blockquote><p>这让我想起了，我总是喜欢叫着别人和我一起做一些事，因为总觉得一个人有点孤单。但是我对于一起玩的人又很挑剔，所以我愿意叫着玩的也就那几个。有一次，我非常想请我的朋友和我一起去闲逛，但是当我一提出请求，她就拒绝了。当时我很生气，我觉得她已经和我关系不好了，她已经不再是以前那个时刻和我要好的朋友了。但是我什么也没说，她和我说，她早上6点下的火车，非常的劳累，一点也不想转悠了，只想在寝室休息。现在一想，是啊，她有自己的感受，我应该去理解她的感受，而不是因为她没有满足我的请求而迁怒于对方。还好，我没有做出伤害她的事。</p><blockquote><p>有的时候，谈话的气氛很沉闷。我们体会不到说话的人有怎样的感受和需要，也不知道他对我们有什么期待。这样的谈话是很累人的。它只是在浪费我们的时间，而无法帮助我们与他人加深联系。这种局面的出现往往是因为说话的人并不清楚自己的感受、需要和请求。怎么做才可以扭转这种局面，使谈话生动有趣呢？我的建议是，尽快提醒说话的人留意自己的感受和需要。等得越久，也就越难做到这一点。我们这样做并不是要以自我为中心，而是请求他人体会自身的状态。使谈话生动有趣的另一种方法是直接表达我们的愿望。</p></blockquote><p>少说废话，可能是现在的成年人必须要锻炼的一种素质。所以，为了向合格的成年人再迈向一步，要管住自己的嘴了。</p><h3 id="chapter-9-爱自己"><a href="#chapter-9-爱自己" class="headerlink" title="chapter 9 爱自己"></a>chapter 9 爱自己</h3><blockquote><p>主人公拒绝将他12岁的外甥交给儿童福利院。他郑重地说道:“我希望他准确无误地知道他是多么特殊的生命，要不，他在成长的过程中将会忽视这一点。我希望他保持清醒，并看到各种奇妙的可能。我希望他知道，一旦有机会，排除万难给世界一点触动是值得的。我还希望他知道为什么他是一个人，而不是一张椅子。</p></blockquote><blockquote><p>许多人陷于自我憎恨之中，而无法从失误中获益——失误揭示我们的局限性，并引导我们的成长。</p></blockquote><blockquote><p>即使我们有时通过严厉的自责“得到了教训”，我也会担心这种变化和学习的驱动力。我希望，我们的改变是出于对生命的爱，而不是出于羞愧或内疚这些具有负面影响的心理。</p></blockquote><blockquote><p>如果自我评价使我们羞愧并改变行为，我们也就允许自我憎恨来引导自己的成长和学习。羞愧是自我憎恨的一种形式，出于羞愧的行为不是自由而快乐的行为。即使我们试图更加友善和体贴，一旦人们意识到我们行为背后的羞愧或内疚，他们对这些行为的欣赏也就比不上那些只是出于爱的行为。</p></blockquote><blockquote><p>如果我们认为自己“应该”怎么样，在大多数的情况下，我们也就封闭了自我。因为“应该”意味着我们别无选择。这使我们感到无奈和沮丧。同时，又心有不甘，不愿屈服。<br>如果我们专注于需要是否到满足以及得到怎样的满足，我们就更有可能从自我评价中获益。</p></blockquote><blockquote><p>非暴力沟通鼓励我们直面人生的苦难:在遇到挫折时，充分体会人生的悲哀和内心的渴望。是的，感到遗憾是难免的。但它能帮助我们从经历中学习，而无须责备自己。我们意识到过去的行为违背了自己的需要及价值观，并允许这种觉察引发的情感充分流淌。一旦专注于尚未满足的需要，我们就会考虑如何满足它。反之，如果用苛刻的语言指责自己，我们不仅难以找到解决办法，而且容易陷于自我惩罚的痛苦中。</p></blockquote><h3 id="chapter-10-充分表达愤怒"><a href="#chapter-10-充分表达愤怒" class="headerlink" title="chapter 10 充分表达愤怒"></a>chapter 10 充分表达愤怒</h3><blockquote><p>我相信，人的行为总是服务于自身的需要及价值观—不论它是否能够实现目的，也不论我们事后是感到庆幸还是遗憾。</p></blockquote><blockquote><p>通过聆听自己的心声，我们就能发现心灵深处的需要。此时，我们就可以原谅自己。我们意识到，尽管过去的选择并不理想，但它也是为了实现内心的渴望。</p></blockquote><blockquote><p>爱惜自己的关键之一是同时包容那两个不同的“我”:一方面包容对过去的某种行为感到后悔的“我”，另一方面包容采取那种行为的我”。</p></blockquote><blockquote><p> 如果我不强调我与他人观念的不同，我就较容易接纳他们。特别是当我遇到一个有像他那样想法的人时，倾听他们的感受和需要，而不纠缠于他们的想法，我们的生活将会变得愉快得多。</p></blockquote><blockquote><p>于是，为了博得他人的喜爱，我们费尽心思、委曲求全。这是很可悲的。实际上，如果我们的行为只是出于对生命的爱，人们自然会心存感激。他们的感激也是在给我们确认:我们的行为有益于他们的生活。一旦如愿活出对生命的爱，我们所体会到的欢乐是他人的赞同永远无法给予的。</p></blockquote><blockquote><p>我确信，一旦生命的需要被忽视，我们的行动对社会来说极具危险，对个人来说则极为不幸。</p></blockquote><blockquote><p>做有乐趣的事情是可能的。我相信，我们越是投入服务生命的乐趣中———服务生命是唯一的目的，我们也就越爱自己。</p></blockquote><h3 id="chapter-11运用强制力避免伤害"><a href="#chapter-11运用强制力避免伤害" class="headerlink" title="chapter 11运用强制力避免伤害"></a>chapter 11运用强制力避免伤害</h3><blockquote><p>如果我不强调我与他人观念的不同，我就较容易接纳他们。特别是当我遇到一个有像他那样想法的人时，倾听他们的感受和需要，而不纠缠于他们的想法，我们的生活将会变得愉快得多。</p></blockquote><blockquote><p>如果在一个社会中，内疚被运用来控制人；那么，指责他人就容易成为一种习惯。同时，为了使这种手段奏效，我们可能就会认为一个人可以主导另一个人的情绪。</p></blockquote><blockquote><p>当我回想起那两天的经历时，我发现，我一开始就把第一个孩子看作是“被宠坏的孩子”。所以，他打到我时，我极为恼怒。我心里想:“这家伙太猖狂了！”我对第二个孩子的看法则不同，我把他看作是“软弱的孩子”。由于我比较担心这个孩子，当我的鼻子被他打伤时，我并没有责怪他。这段经历帮助我认识到，我生气的原因不在于别人做了什么，而在于我怎么看待对方及其行为。</p></blockquote><blockquote><p>如果人们认为自己的痛苦是由其他人造成的，并认为那些人应该受到谴责或惩罚，那么，就像这位年轻的囚犯那样，他们播下了暴力的种子。</p></blockquote><blockquote><p> 在受到指责时，绝大多数的人都无法把注意力放在对方的需要上。当然，指责他人有时可以使我们达到目的———出于害怕、内疚或惭愧，他们改变了自己的行为。<br>然而，以这样的方式来满足我们的需要，我们也是在使用暴力。为了解决眼前的问题，我们制造了新的问题。批评和指责使人倾向于自我保护并变得更有攻击性。这样，就长期而言，我们给自己增添了更多的麻烦。</p></blockquote><h3 id="chapter-12-重获生活的热情"><a href="#chapter-12-重获生活的热情" class="headerlink" title="chapter 12 重获生活的热情"></a>chapter 12 重获生活的热情</h3><h3 id="chapter-13-表达感激"><a href="#chapter-13-表达感激" class="headerlink" title="chapter 13 表达感激"></a>chapter 13 表达感激</h3><blockquote><p>以色列前总理 Golda Meir：“不要那么谦虚，因为你没有那么伟大。”</p></blockquote><blockquote><p> 在别人表达感激时，人们通常有两种截然不同的反应。一种是自我膨胀，相信我们比别人优越；一种是假谦虚，否定别人的欣赏，耸耸肩说：“哦，这没什么。”</p></blockquote><blockquote><p>指责别人是很容易的。人们常常觉得自己受到了指责，有时他们自己也同意，并开始恨自己—但这并不意味着他们会改变自己的行为。</p></blockquote><blockquote><p>一件值得做的事情即使做得不怎么样也是值得的。</p></blockquote><blockquote><p>在表达感激时，我们说出:（1）对我们有益的行为；（2）我们的哪些需要得到了满足；（3）我们的需要得到满足后，我们是什么样的心情。<br>当别人以这样的方式表达对我们的感激时我们可以与对方一起庆祝生命的美一既不自大，也不假谦虚。</p></blockquote><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>建议每次说话前都想想，多看看，多实践</p><p>附:非力沟通模式<br>1.诚实地表达自己，而不批评、指责<br>（1）观察<br>我所观察（看、听、回忆、想）到的有助于（或无助于）我的福<br>祉的具体行为:<br>“当我（看、听、想到我看到的/听到的）…<br>（2）感受<br>对于这些行为，我有什么样的感受（情感而非思想）<br>“我感到…<br>（3）需要<br>什么样的需要或价值（而非偏好或某种具体的行为）导致我那样的<br>感受:<br>“因为我需要/看重……”<br>（4）请求<br>清楚地请求（而非命令）那些能丰富我生命的具体行为，<br>“你是否愿意……？”<br>2.关切地倾听他人，而不解读为批评或指责<br>（1）观察<br>你所观察（看、听、回忆、想）到的有助于（或无助于）你的福<br>祉的具体行为:<br>“当你（看、听、想到你看到的/听<br>到的）<br>（2）感受<br>对于这些行为，你有什么样的感受（是情感而非思想）:<br>“你感到…吗？”<br>什么样的需要或价值（而非偏好或某种具体的行为）导致你那样的（3）需要<br>感受:<br>“因为你需要/看重…”<br>关切地倾听那些能丰富你生命的具体请求，而不解读为命令:<br>（4）请求<br>“所以，你想。。。 “</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具成长类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string-problems-easy</title>
      <link href="/2019/10/05/string-problems-easy/"/>
      <url>/2019/10/05/string-problems-easy/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h3 id="1108-Defanging-an-IP-Address"><a href="#1108-Defanging-an-IP-Address" class="headerlink" title="1108.Defanging an IP Address"></a>1108.Defanging an IP Address</h3><p><strong>题目描述：</strong></p><p>Given a valid (IPv4) IP <code>address</code>, return a defanged version of that IP address.</p><p>A <em>defanged IP address</em> replaces every period <code>&quot;.&quot;</code> with <code>&quot;[.]&quot;</code>.</p><p><strong>Example 1:</strong></p><pre><code>Input: address = &quot;1.1.1.1&quot;Output: &quot;1[.]1[.]1[.]1&quot;</code></pre><h4 id="solution1-遍历"><a href="#solution1-遍历" class="headerlink" title="solution1-遍历"></a>solution1-遍历</h4><ul><li>用一个新的串来记录结果，遍历原串，当遇到’.’时，结果串用”[.]”替代，否则用原串字符</li><li>时间：O(n),空间：O(n)</li><li>本来是想用string的库做，但是对于插入定位这件事就难倒我了。<ul><li>用iterator，用for循环去判断是否到结尾，但是只要插入元素，add.end()的iterator变了</li><li>用replace，也不行，insert 和 find 结合，编译总是显示 out of range，在codeblock上是没错的。</li></ul></li></ul><pre><code class="c++">class Solution &#123;public:    string defangIPaddr(string address) &#123;        string res = &quot;&quot;, str = &quot;[.]&quot;;        string::iterator it;        for(it = address.begin(); it != address.end(); it++)&#123;            if(*it == &#39;.&#39;)                res += str;            else                res += *it;        &#125;        return res;    &#125;&#125;;</code></pre><h3 id="709-To-Lower-Case"><a href="#709-To-Lower-Case" class="headerlink" title="709. To Lower Case"></a>709. To Lower Case</h3><p><strong>题目描述</strong>：</p><p>Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;Hello&quot;Output: &quot;hello&quot;</code></pre><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><ul><li>ascii码表：大写字母 ：65-90，小写字母：97-122</li></ul><pre><code class="C++">class Solution &#123;public:    string toLowerCase(string str) &#123;        int len = str.size();        for(int i = 0; i&lt; len; i++)&#123;            if(str[i] &lt;= 90 &amp;&amp; str[i] &gt;= 65)                str[i] += 32;        &#125;        return str;    &#125;&#125;;</code></pre><h3 id="804-Unique-Morse-Code-Words"><a href="#804-Unique-Morse-Code-Words" class="headerlink" title="804. Unique Morse Code Words"></a>804. Unique Morse Code Words</h3><p><strong>问题描述</strong></p><p>将字符串转换为摩尔斯电码表示，就是一种映射，返回的是结果中摩尔斯电码的不同的个数</p><p><strong>Example:</strong></p><pre><code>Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]Output: 2Explanation: The transformation of each word is:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;.</code></pre><h4 id="solution-集合set的使用"><a href="#solution-集合set的使用" class="headerlink" title="solution-集合set的使用"></a>solution-集合set的使用</h4><ul><li>看到那么长的映射，以为是考智力，找规律，直接放弃，看了别人的解法，不得不钦佩</li><li>每遍历一个单词，依次遍历其字符，并记录对应的国际摩尔斯电码，当一个单词遍历完，则拼接出单词对应的结果。把结果放入集合set中，因为unordered_set是无序的，比set快，且其中元素无重复。最后返回set集合的大小，就是不同的转换。</li><li>时间：O(n)，空间：O(2n)；n是单词个数</li></ul><pre><code class="C++">class Solution &#123;public:    int uniqueMorseRepresentations(vector&lt;string&gt;&amp; words) &#123;        vector&lt;string&gt;code&#123;&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;&#125;;        unordered_set&lt;string&gt;ret;//一提到找不同，首当其冲的就是集合                    for(string str : words)&#123;            string res = &quot;&quot;;            for(char c : str)&#123;                res += code[c - &#39;a&#39;];//这点很厉害，直接定位到数组中对应的元素            &#125;            ret.insert(res);        &#125;        return ret.size();    &#125;&#125;;</code></pre><h3 id="657-Robot-Return-to-Origin"><a href="#657-Robot-Return-to-Origin" class="headerlink" title="657. Robot Return to Origin"></a>657. Robot Return to Origin</h3><p><strong>题目描述：</strong></p><p>Valid moves are R (right), L (left), U (up), and D (down). If the robot  returns to the origin after it finishes all of its moves, return true.  Otherwise, return false.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;UD&quot;Output: true Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.</code></pre><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><ul><li>想要返回true，需要左右移动，上下移动的次数一样多</li></ul><pre><code class="C++">class Solution &#123;public:    bool judgeCircle(string moves) &#123;        int l = 0, u = 0;        for(char c : moves)&#123;            switch(c)&#123;                case &#39;L&#39;:l++;break;                case &#39;R&#39;:l--;break;                case &#39;U&#39;:u++;break;                case &#39;D&#39;:u--;break;            &#125;           &#125;        return l == u &amp;&amp; l == 0;            &#125;&#125;;</code></pre><h3 id="929-Unique-Email-Addresses"><a href="#929-Unique-Email-Addresses" class="headerlink" title="929. Unique Email Addresses"></a>929. Unique Email Addresses</h3><p><strong>题目描述</strong>：</p><p>For example, in <code>alice@leetcode.com</code>, <code>alice</code> is the local name, and <code>leetcode.com</code> is the domain name.</p><p>local name：如果有”.”，忽略，如果有”+”，第一个加号之后的都忽略，可用来过滤邮件（这两条规则对于domain name不适用）</p><p>返回能够收到邮件的不同地址个数。</p><p><strong>Example 1:</strong></p><pre><code>Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]Output: 2Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails</code></pre><h4 id="solution-遍历"><a href="#solution-遍历" class="headerlink" title="solution-遍历"></a>solution-遍历</h4><ul><li><p>将email地址分为local和doamin两部分处理，只有两部分都满足题目要求时，将处理的结果拼接成合法的地址，insert到set中，最后返回set中的地址个数。</p></li><li><p>时间：O(n)，n是email的个数；空间：O(n)</p></li><li><p>看别人比较快的代码，似乎domain部分不需要做判断</p></li></ul><pre><code class="C++">class Solution &#123;public:    int numUniqueEmails(vector&lt;string&gt;&amp; emails) &#123;        unordered_set&lt;string&gt;res; //用set存储唯一的地址                for(string email : emails)&#123;            int pos = email.find(&quot;@&quot;),len = email.size();            string ret1 = &quot;&quot;;                        string local(email,0,pos);            string domain(email,pos+1,len-pos);                        bool isLocal = checkLocal(local,ret1);            //bool isDomain = checkDomain(domain);            // &amp;&amp; isDomain            if(isLocal)&#123;                //cout&lt;&lt;ret1+&quot;@&quot;+domain&lt;&lt;endl;                 res.insert(ret1+&quot;@&quot;+domain);            &#125;                       &#125;        return res.size();            &#125;    bool checkLocal(string local, string &amp;ret1)&#123;        for(char c : local)&#123;            if(c == &#39;.&#39;)//点则跳过，                continue;            else if(c == &#39;+&#39;)//之后的都忽略                break;            else                ret1+=c;        &#125;        return true;    &#125;    //没看懂题目，domain里面原来可以有多个&#39;.&#39;    /*bool checkDomain(string domain)&#123;        for(char c : domain)&#123;            if((c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || c == &#39;.&#39;)//记得加等号！！！                continue;            else                return false;        &#125;        return true;    &#125;*/&#125;;</code></pre><h3 id="557-Reverse-Words-in-a-String-III"><a href="#557-Reverse-Words-in-a-String-III" class="headerlink" title="557. Reverse Words in a String III"></a>557. Reverse Words in a String III</h3><p><strong>题目描述</strong>：</p><p>Given a string, you need to reverse the order of characters in each  word within a sentence while still preserving whitespace and initial  word order.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;Let&#39;s take LeetCode contest&quot;Output: &quot;s&#39;teL ekat edoCteeL tsetnoc&quot;</code></pre><h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><pre><code class="C++">class Solution &#123;public:    string reverseWords(string s) &#123;        int len = s.size();        int beg = 0;        int pos = s.find(&quot; &quot;,0);//老年人的劝告，少用这种find空格的方式        while(pos != std::string::npos)&#123;            reverseWord(s,beg,pos-1);            beg = pos+1;            pos = s.find(&quot; &quot;,beg);        &#125;        reverseWord(s,beg,len-1);        return s;            &#125;    void reverseWord(string&amp; str,int beg, int en)&#123;        for(int i = beg,j = en; i &lt; j; i++,j--)&#123;            str[i] ^= str[j];            str[j] ^= str[i];            str[i] ^= str[j];        &#125;    &#125;&#125;;</code></pre><h3 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344. Reverse String"></a>344. Reverse String</h3><p>题目描述：</p><p>Write a function that reverses a string. The input string is given as an array of characters <code>char[]</code>.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>You may assume all the characters consist of <a href="https://en.wikipedia.org/wiki/ASCII#Printable_characters">printable ascii characters</a>.</p><p><strong>Example 1:</strong></p><pre><code>Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></pre><h4 id="solution1-按异或操作符实现元素交换"><a href="#solution1-按异或操作符实现元素交换" class="headerlink" title="solution1-按异或操作符实现元素交换"></a>solution1-按异或操作符实现元素交换</h4><ul><li>看运行时间，似乎也不是很有效</li><li>时间O(n)，空间O(1)</li><li>swap：和1的做法差不多，但是时间会少一些</li></ul><pre><code class="C++">class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        char tmp;        int len = s.size();        for(int i = 0; i &lt; len/2; i++)&#123;            tmp = s.at(i) ;            s.at(i) = s.at(len - i - 1);            s.at(len - i - 1) = tmp;        &#125;    &#125;&#125;;</code></pre><h4 id="solution2-用string的库函数-reverse"><a href="#solution2-用string的库函数-reverse" class="headerlink" title="solution2-用string的库函数.reverse"></a>solution2-用string的库函数.reverse</h4><pre><code class="C++">class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        reverse(s.begin(),s.end());    &#125;&#125;;</code></pre><h3 id="1170-Compare-Strings-by-Frequency-of-the-Smallest-Character"><a href="#1170-Compare-Strings-by-Frequency-of-the-Smallest-Character" class="headerlink" title="1170. Compare Strings by Frequency of the Smallest Character"></a>1170. Compare Strings by Frequency of the Smallest Character</h3><p><strong>题目描述</strong></p><p>Let’s define a function <code>f(s)</code> over a non-empty string <code>s</code>, which <strong>calculates the frequency of the smallest character</strong> in <code>s</code>. For example, if <code>s = &quot;dcce&quot;</code> then <code>f(s) = 2</code> because the smallest character is <code>&quot;c&quot;</code> and its frequency is 2.</p><p>Now, given string arrays <code>queries</code> and <code>words</code>, return an integer array <code>answer</code>, where each <code>answer[i]</code> is the number of words such that <code>f(queries[i])</code> &lt; <code>f(W)</code>, where <code>W</code> is a word in <code>words</code>.</p><p>answer的个数和queries的个数一样，值的范围是[0,w.size()];</p><p><strong>Example 2:</strong></p><pre><code>Input: queries = [&quot;bbb&quot;,&quot;cc&quot;], words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]Output: [1,2]Explanation: On the first query only f(&quot;bbb&quot;) &lt; f(&quot;aaaa&quot;). On the second query both f(&quot;aaa&quot;) and f(&quot;aaaa&quot;) are both &gt; f(&quot;cc&quot;).</code></pre><h4 id="solution-sort"><a href="#solution-sort" class="headerlink" title="solution-sort"></a>solution-sort</h4><ul><li>没有任何技术含量的，一步步按照人脑实现</li><li>先分别统计最小字符的个数，然后进行比较</li><li>时间：O(n^2)，n是字符的个数，空间：O(3n)，包括存储次数，以及结果的vector</li></ul><pre><code class="C++">class Solution &#123;public:    //计算每个字符串内最小的字符出现的次数        int numbers(string query)&#123;            int num1 = 1;            char tmp = query[0];            for(int i = 1; i&lt; query.size();i++)&#123;                if(query[i] == tmp)&#123;                    num1++;                &#125;else                    break;            &#125;            return num1;    &#125;        vector&lt;int&gt; numSmallerByFrequency(vector&lt;string&gt;&amp; queries, vector&lt;string&gt;&amp; words) &#123;                vector&lt;int&gt; q,w;            //分别计算queries和words中字符串的最小字符个数        for(string query:queries)&#123;            sort(query.begin(),query.end());             int numq = numbers(query);            q.push_back(numq);                    &#125;                    for(string word:words)&#123;            sort(word.begin(),word.end());                        int numw = numbers(word);             w.push_back(numw);        &#125;               //统计结果        //sort(q.begin(),q.end());//输出时不能改变原来的顺序        sort(w.begin(),w.end());            vector&lt;int&gt;res;        int lenw = w.size();        for(int numq : q)&#123;            int ret = 0;            for(int i = 0; i &lt; lenw; i++)&#123;                if(numq &lt; w[i])&#123;                    ret = lenw-i;                    break;                &#125;                                &#125;            res.push_back(ret);        &#125;        return res;    &#125;&#125;;</code></pre><h4 id="solution2-比较精巧，但是得仔细理解"><a href="#solution2-比较精巧，但是得仔细理解" class="headerlink" title="solution2-比较精巧，但是得仔细理解"></a>solution2-比较精巧，但是得仔细理解</h4><pre><code>class Solution &#123;public:    //用hash表的形式获取字符串的最小字符出现频率，这样就不需要对原串进行排序了    int getF(string s)&#123;        int f[26] = &#123;0,&#125;;        for(char c:s)&#123;            f[c-&#39;a&#39;]++;        &#125;        for(int i: f)&#123;            if(i &gt; 0)                return i;        &#125;        return 0;    &#125;        vector&lt;int&gt; numSmallerByFrequency(vector&lt;string&gt;&amp; queries, vector&lt;string&gt;&amp; words) &#123;        vector&lt;int&gt;fr(12,0);//用来统计words中，最小字符串的长度在1-10之间的个数        for(string word:words)&#123;            int f = getF(word);            fr[f]++;        &#125;        //从后向前统计，大于当前个数的最小字符串是多少个        for(int i = 9; i &gt;=0; i--)&#123;            fr[i] += fr[i+1];        &#125;                vector&lt;int&gt;res;        for(string query:queries)&#123;            int f = getF(query);            res.push_back(fr[f+1]);//fr必须是12，如果是11，当这里的f是10，那么访问fr[11]，需要的就是12个元素大小的空间        &#125;        return res;            &#125;&#125;;</code></pre><h3 id="824-Goat-Latin"><a href="#824-Goat-Latin" class="headerlink" title="824. Goat Latin"></a>824. Goat Latin</h3><p><strong>题目描述</strong></p><p>The rules of Goat Latin are as follows:</p><ul><li>If a word begins with a vowel (a, e, i, o, or u), append <code>&quot;ma&quot;</code> to the end of the word.<pre><code> For example, the word &#39;apple&#39; becomes &#39;applema&#39;.</code></pre></li><li>If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add <code>&quot;ma&quot;</code>.<pre><code> For example, the word `&quot;goat&quot;` becomes `&quot;oatgma&quot;`.</code></pre></li><li>Add one letter <code>&#39;a&#39;</code> to the end of each word per its word index in the sentence, starting with 1.<pre><code> For example, the first word gets `&quot;a&quot;` added to the end, the second word gets `&quot;aa&quot;` added to the end and so on.</code></pre></li></ul><p>Return the final sentence representing the conversion from <code>S</code> to Goat Latin. </p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;I speak Goat Latin&quot;Output: &quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot;</code></pre><h4 id="solution-string库函数使用，下标移动"><a href="#solution-string库函数使用，下标移动" class="headerlink" title="solution-string库函数使用，下标移动"></a>solution-string库函数使用，下标移动</h4><ul><li>主要思路：按照第一个字符是否为元音，分为两种处理方法<ul><li>是元音，直接在结尾添加ma</li><li>不是元音，将子串开头字符添加到结尾，删除开头字符，添加ma</li></ul></li><li>对于拼接好的单词，还需要根据这是第几个单词，在单词最后加入几个a，这个用cnt来记录当前处理的是第几个元素，生成cnt长度的新子串，添加在单词后即可。</li><li>时间：O(n)，n是单词的个数，空间：O(C)，C是a的个数</li></ul><pre><code class="C++">class Solution &#123;public:    void convert(string&amp; S,int beg, int pos)&#123;        switch(S[beg])&#123;                case &#39;a&#39;: case &#39;A&#39;:                case &#39;e&#39;: case &#39;E&#39;:                case &#39;i&#39;: case &#39;I&#39;:                case &#39;o&#39;: case &#39;O&#39;:                case &#39;u&#39;: case &#39;U&#39;:                    S.insert(pos,&quot;ma&quot;);                    break;                default:                    S.insert(pos,1,S[beg]);                    S.erase(beg,1);                    S.insert(pos,&quot;ma&quot;);                    break;                        &#125;    &#125;        string toGoatLatin(string S) &#123;        int pos = S.find(&quot; &quot;,0);        int beg = 0;        int cnt = 0;                while(pos!=std::string::npos )&#123;            cnt++;            convert(S,beg,pos);            pos = S.find(&quot; &quot;,pos);            string tmp(cnt,&#39;a&#39;);            S.insert(pos,tmp);                                beg = pos+cnt+1;            pos = S.find(&quot; &quot;,beg);        &#125;                cnt++;//处理最后一个元素                convert(S,beg,S.size());                int len = S.size();        string tmp(cnt,&#39;a&#39;);        S.insert(len,tmp);        return S;    &#125;&#125;;</code></pre><h3 id="521-Longest-Uncommon-Subsequence-I"><a href="#521-Longest-Uncommon-Subsequence-I" class="headerlink" title="521. Longest Uncommon Subsequence I"></a>521. Longest Uncommon Subsequence I</h3><p><strong>题目描述</strong></p><p>Given a group of two strings, you need to find the longest uncommon  subsequence of this group of two strings.<br>The longest uncommon subsequence is defined as the longest subsequence  of one of these strings and this subsequence should not be <strong>any</strong> subsequence of the other strings.</p><p>A <strong>subsequence</strong> is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty<br>string is a subsequence of any string.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;aba&quot;, &quot;cdc&quot;Output: 3Explanation: The longest uncommon subsequence is &quot;aba&quot; (or &quot;cdc&quot;), because &quot;aba&quot; is a subsequence of &quot;aba&quot;, but not a subsequence of any other strings in the group of two strings. </code></pre><h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h4><ul><li>看solution，完全是脑筋急转弯</li><li>按道理，要把两个串的所有子序列求出来，对比看有没有子序列才对吧？但是这种情况是指，有公共子序列。对于没有的情况，就是长度最长的串本身。</li><li>时间：O(1)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    int findLUSlength(string a, string b) &#123;        if(a == b)            return -1;        int len1 = a.size(),len2 = b.size();        return len1&gt;=len2?len1:len2;            &#125;&#125;;</code></pre><h3 id="917-Reverse-Only-Letters"><a href="#917-Reverse-Only-Letters" class="headerlink" title="917. Reverse Only Letters"></a>917. Reverse Only Letters</h3><p><strong>题目描述</strong></p><p>Given a string <code>S</code>, return the “reversed” string where all  characters that are not a letter stay in the same place, and all letters reverse their positions.</p><p><strong>Example 2:</strong></p><pre><code>Input: &quot;a-bC-dEf-ghIj&quot;Output: &quot;j-Ih-gfE-dCba&quot;</code></pre><h4 id="solution1-双指针遍历，交换"><a href="#solution1-双指针遍历，交换" class="headerlink" title="solution1-双指针遍历，交换"></a>solution1-双指针遍历，交换</h4><ul><li>最左，最右双指针遍历<ul><li>遇到非字母的，则跳过</li><li>只有当两个都是字母时交换；</li></ul></li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    string reverseOnlyLetters(string S) &#123;        int len = S.size();        int left = 0, right = len-1;        while(left &lt; right)&#123;            char l = S[left] ,r = S[right];            if(isLetter(l)  &amp;&amp; isLetter(r))&#123;                char tmp = S[left];                S[left] = S[right];                S[right] = tmp;                left++;                right--;            &#125;else if(!isLetter(l) &amp;&amp; !isLetter(r))&#123;                left++;                right--;            &#125;else if(!isLetter(l))                left++;            else                right--;        &#125;        return S;            &#125;    bool isLetter(char s)&#123;        if((s &gt;= &#39;a&#39; &amp;&amp; s &lt;= &#39;z&#39;) || (s &gt;=&#39;A&#39; &amp;&amp; s &lt;= &#39;Z&#39;) )            return true;        else             return false;    &#125;&#125;;</code></pre><h4 id="solution2-stack"><a href="#solution2-stack" class="headerlink" title="solution2-stack"></a>solution2-stack</h4><ul><li>看解答，发现还是很有意思的一个思路，因为需要逆序字符串，因此可以用栈，这道题目就是将字符串逆序输出，其他字符保持在原位置不变。</li><li>时间：O(2n),需要扫描两边原字符串，空间：O(n)，额外的stack及返回字符串</li></ul><pre><code class="C++">class Solution &#123;public:    bool isLetter(char s)&#123;        if((s &gt;= &#39;a&#39; &amp;&amp; s &lt;= &#39;z&#39;) || (s &gt;=&#39;A&#39; &amp;&amp; s &lt;= &#39;Z&#39;) )            return true;        else             return false;    &#125;        string reverseOnlyLetters(string S) &#123;        stack&lt;char&gt; tmp;        for(char c:S)&#123;            if(isLetter(c))                tmp.push(c);        &#125;        string res;        for(char c:S)&#123;            if(isLetter(c))&#123;                res.append(1,tmp.top());                tmp.pop();            &#125;else                res.append(1,c);              &#125;        return res;    &#125;&#125;;</code></pre><h3 id="788-Rotated-Digits"><a href="#788-Rotated-Digits" class="headerlink" title="788. Rotated Digits"></a>788. Rotated Digits</h3><p><strong>题目描述</strong></p><p>A number is valid if each digit remains a digit after rotation. 0, 1,  and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9  rotate to each other, and the rest of the numbers do not rotate to any  other number and become invalid.</p><p>Now given a positive number <code>N</code>, how many numbers X from <code>1</code> to <code>N</code> are good?</p><p><strong>Example</strong>:</p><pre><code>Input: 10Output: 4Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.</code></pre><h4 id="solution-dp记录表"><a href="#solution-dp记录表" class="headerlink" title="solution-dp记录表"></a>solution-dp记录表</h4><ul><li>本以为代码越敲，就会渐入佳境，结果却是：连题目都读不懂了呜呜呜</li><li>这道题乍得一看有点难，看了别人的解法才知道题目想表达的意思。</li><li>越来越大的数字都是由小数字组成的，那么通过读小数字是否为good num就可以判断大数是否为good</li><li>当数字为good时，必须包含2||5||6||9，同时可以包含0，1，8</li><li>只包含0，1，8 时只能说是valid的，不能是good的</li><li>当数字包含 3，4，7时，一定是invalid的</li><li>时间：O(n)，n是数字的个数，空间，O(n)</li></ul><pre><code class="C++">class Solution &#123;public:    int rotatedDigits(int N) &#123;        int dp[N+1] = &#123;0,&#125; ;        int cnt = 0;        for(int i = 0; i &lt;= N;i++)&#123;        if(i &lt; 10)&#123;            if(i == 0 || i == 1 || i == 8)                dp[i] = 1;            else if(i == 2 || i == 5 || i == 6 || i == 9)&#123;                       dp[i] = 2;                 cnt++;            &#125;        &#125;else&#123;            int a = dp[i/10], b = dp[i%10];            if(a == 1 &amp;&amp; b == 1)                dp[i] = 1;            else if(a &gt;= 1 &amp;&amp; b &gt;= 1)&#123;                dp[i] = 2;//说明这个数的组成是2，5，6，9，0，1，8                cnt++;                               &#125;                  &#125;        &#125;        return cnt;    &#125;&#125;;</code></pre><h3 id="696-Count-Binary-Substrings"><a href="#696-Count-Binary-Substrings" class="headerlink" title="696. Count Binary Substrings"></a>696. Count Binary Substrings</h3><p><strong>题目描述</strong></p><p>Give a string <code>s</code>, count the number of non-empty  (contiguous) substrings that have the same number of 0’s and 1’s, and  all the 0’s and all the 1’s in these substrings are grouped  consecutively.  </p><p>Substrings that occur multiple times are counted the number of times they occur.</p><p><strong>Example 2:</strong></p><pre><code>Input: &quot;10101&quot;Output: 4Explanation: There are 4 substrings: &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;01&quot; that have equal number of consecutive 1&#39;s and 0&#39;s.</code></pre><h4 id="solution-线性扫描"><a href="#solution-线性扫描" class="headerlink" title="solution-线性扫描"></a>solution-线性扫描</h4><ul><li>遇到相同的就加，遇到不同的就开始统计，看这种连续性是几个</li><li>相当于把1和0分成group</li><li>时间：O(n),空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    int countBinarySubstrings(string s) &#123;        int len = s.size();        int pre = 0,cur = 1, sum = 0;//pre是上一个group中相同元素的个数，cur是当前的，这就是相当于对0和1分组        for(int i = 1; i &lt; len; i++)&#123;            if(s[i] == s[i-1])&#123;                cur++;            &#125;else&#123;                sum += min(cur,pre);                pre = cur;                cur = 1;            &#125;                    &#125;        sum += min(cur,pre);        return sum;    &#125;&#125;;</code></pre><h3 id="937-Reorder-Data-in-Log-Files"><a href="#937-Reorder-Data-in-Log-Files" class="headerlink" title="937. Reorder Data in Log Files"></a>937. Reorder Data in Log Files</h3><p><strong>题目描述</strong></p><p>Reorder the logs so that all of the letter-logs come before any  digit-log.  The letter-logs are ordered lexicographically ignoring  identifier, with the identifier used in case of ties.  The digit-logs  should be put in their original order.</p><p>Return the final order of the logs.</p><p><strong>Example 1:</strong></p><pre><code>Input: logs = [&quot;dig1 8 1 5 1&quot;,&quot;let1 art can&quot;,&quot;dig2 3 6&quot;,&quot;let2 own kit dig&quot;,&quot;let3 art zero&quot;]Output: [&quot;let1 art can&quot;,&quot;let3 art zero&quot;,&quot;let2 own kit dig&quot;,&quot;dig1 8 1 5 1&quot;,&quot;dig2 3 6&quot;]</code></pre><h4 id="solution-stable-sort"><a href="#solution-stable-sort" class="headerlink" title="solution-stable_sort"></a>solution-stable_sort</h4><ul><li>通过对标识符后的第一个字符进行比较，得出是isalpha or isdigit</li><li>isalpha,则进入结果vector，否则，进入临时vector<ul><li>这样分开装的原因是，两者的排序要求不同，对于前者，则需要对标识符之外的串进行比较，而对于后者，则简单的排在前者后面就可以。</li></ul></li><li>比较花时间的地方就是：如何对vector中的字符串，去掉某部分后进行大小比较，用comparator，要注意的是：cmp函数写在类内需要用static关键字修饰，类外则可以不用。</li><li>时间：O(n)，n是字符串的个数，空间：O(n)，两部分用于存储字符串的vector</li></ul><pre><code>bool cmp(string str1, string str2)&#123;        int pos1 = str1.find(&#39; &#39;);        int pos2 = str2.find(&#39; &#39;);        string sa = str1.substr(pos1+1);        string sb = str2.substr(pos2+1);        if(sa.compare(sb) == 0)//如果除了标识符之外的地方相等，那么就要对标识符也做判断进行排序了            return str1 &lt; str2;        else            return sa &lt; sb;    &#125;class Solution &#123;public:    //很迷，就一个static搞了我半个小时,如果放在类内作为比较函数，则必须要加static    /*    static bool cmp(string str1, string str2)&#123;        int pos1 = str1.find(&#39; &#39;);        int pos2 = str2.find(&#39; &#39;);        return str1.substr(pos1+1) &lt; str2.substr(pos2+1);    &#125;    */    vector&lt;string&gt; reorderLogFiles(vector&lt;string&gt;&amp; logs) &#123;        vector&lt;string&gt;res;        vector&lt;string&gt;tmp;                for(string str:logs)&#123;            int pos = str.find(&#39; &#39;);//find还可以用来查找某个完整的单词呢·就是string了            if(isdigit(str[pos+1]))                tmp.push_back(str);            else                res.push_back(str);        &#125;        stable_sort(res.begin(),res.end(),cmp);//不仅要比较，对于后面都相等的，还需要保持原来的顺序         for(string s:tmp)&#123;            res.push_back(s);        &#125;        return res;    &#125;&#125;;</code></pre><h3 id="1071-Greatest-Common-Divisor-of-Strings"><a href="#1071-Greatest-Common-Divisor-of-Strings" class="headerlink" title="1071. Greatest Common Divisor of Strings"></a>1071. Greatest Common Divisor of Strings</h3><p>For strings <code>S</code> and <code>T</code>, we say “<code>T</code> divides <code>S</code>“ if and only if <code>S = T + ... + T</code>  (<code>T</code> concatenated with itself 1 or more times)</p><p>Return the largest string <code>X</code> such that <code>X</code> divides str1 and <code>X</code> divides str2.</p><h4 id="solution-gcd"><a href="#solution-gcd" class="headerlink" title="solution-gcd"></a>solution-gcd</h4><ul><li>就是两个整数的最大公约数的变形，还做了一个多小时。。。。蠢啊</li><li>自己写的代码也一眼难尽，丑陋！</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    string gcdOfStrings(string str1, string str2) &#123;        //使得较长串始终为第一个串,这tm都能写错，这谁顶得住？？        if(str1.size() &lt; str2.size())&#123;            string tmp = str2;            str2 = str1;            str1 = tmp;        &#125;        int len2 = str2.size();        //==0，表示两个字符串相等        //&gt;0，表示被比较字符串小        if(str1.compare(0,len2,str2) != 0)            return &quot;&quot;;                if(str2.empty())            return str1;                return gcdOfStrings(str2,str1.substr(len2));    &#125;&#125;;</code></pre><h4 id="solution-gcd-1"><a href="#solution-gcd-1" class="headerlink" title="solution-gcd"></a>solution-gcd</h4><ul><li>别人的解释，对于两个串，S1 = nT，S2 = mT，n&gt;m，S3 = (n-m)T = xT; S1 = xT, S2 = mT,…,直到S2为空，返回S1，因为S1始终是长一点的那个。</li></ul><pre><code class="C++">class Solution &#123;public:    string gcdOfStrings(string str1, string str2) &#123;        int len2 = str2.size();        if(str1.size() &lt; len2)            return gcdOfStrings(str2,str1);        if(str2.empty())            return str1;        if(str1.compare(0,len2,str2) != 0)            return &quot;&quot;;        return gcdOfStrings(str1.substr(len2),str2);//str2始终是短的那个，所以一直在后面    &#125;&#125;;</code></pre><h3 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. Roman to Integer</h3><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p><pre><code>Symbol       ValueI             1V             5X             10L             50C             100D             500M             1000</code></pre><p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><p><strong>Example 5:</strong></p><pre><code>Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</code></pre><ul><li>总的来说，解题思路是，结果是每一位的和，但是存在加完了前面的需要减去的情况，比如IV，对于这种特例，两种解决方案。</li></ul><h3 id="solution1-hash-map"><a href="#solution1-hash-map" class="headerlink" title="solution1-hash_map"></a>solution1-hash_map</h3><ul><li>从后向前遍历，如果s[i] &lt; s[i+1]，那么需要减去s[i]，否则加上就行。</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    int romanToInt(string s)&#123;        unordered_map&lt;char,int&gt; M = &#123;&#123;'I',1&#125;,                                     &#123;'V',5&#125;,                                     &#123;'X',10&#125;,                                     &#123;'L',50&#125;,                                     &#123;'C',100&#125;,                                     &#123;'D',500&#125;,                                     &#123;'M',1000&#125;&#125;;        int sum = M[s.back()];        for(int i = s.size() - 2; i &gt;= 0; i--)&#123;            if(M[s[i]] &lt; M[s[i+1]])                sum -= M[s[i]];            else                 sum += M[s[i]];        &#125;        return sum;    &#125;&#125;;</code></pre><h3 id="solution2"><a href="#solution2" class="headerlink" title="solution2-"></a>solution2-</h3><ul><li>先搜索字符串内有没有这类组合，有的话分别减去2，20，200，接着从前向后遍历，依次相加即可；因为加的过程中会多加</li><li>时间：O(n)，空间：O(2n)</li></ul><pre><code class="C++">class Solution &#123;public:    int romanToInt(string s) &#123;        int sum = 0;        if(s.find(&quot;IV&quot;,0) != string::npos) sum-=2;//原本是加4，但是后面遍历加的时候是先加了1，又加了5，就是多加了2        if(s.find(&quot;IX&quot;,0) != string::npos) sum-=2;        if(s.find(&quot;XL&quot;,0) != string::npos) sum-=20;        if(s.find(&quot;XC&quot;,0) != string::npos) sum-=20;        if(s.find(&quot;CD&quot;,0) != string::npos) sum-=200;        if(s.find(&quot;CM&quot;,0) != string::npos) sum-=200;                for(char c: s)&#123;            switch(c)&#123;                case &#39;I&#39;:sum+=1;break;                case &#39;V&#39;:sum+=5;break;                case &#39;X&#39;:sum+=10;break;                case &#39;L&#39;:sum+=50;break;                case &#39;C&#39;:sum+=100;break;                case &#39;D&#39;:sum+=500;break;                case &#39;M&#39;:sum+=1000;break;                                &#125;        &#125;        return sum;            &#125;&#125;;</code></pre><h3 id="520-Detect-Capital"><a href="#520-Detect-Capital" class="headerlink" title="520. Detect Capital"></a>520. Detect Capital</h3><p><strong>题目描述</strong></p><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p><p>We define the usage of capitals in a word to be right when one of the following cases holds:</p><ol><li>All letters in this word are capitals, like “USA”.</li><li>All letters in this word are not capitals, like “leetcode”.</li><li>Only the first letter in this word is capital, like “Google”.</li></ol><p> Otherwise, we define that this word doesn’t use capitals in a right way.  </p><h4 id="solution-4"><a href="#solution-4" class="headerlink" title="solution"></a>solution</h4><ul><li>字符串的前两位决定了接下来的字符串需要是大写还是小写才能合法，如果是大写，那么转入判断大写的函数，一旦发现小写就返回false，反之亦然。</li><li>注意要判断 word 只有一个字符的特例</li><li>时间：O(n)，空间：(1)</li></ul><pre><code class="C++">class Solution &#123;public:    bool detectCapitalUse(string word) &#123;        if(word.size() == 1)            return true;        if(word[0] &gt;= &#39;A&#39; &amp;&amp; word[0] &lt;= &#39;Z&#39;)&#123;            if(word[1] &gt;= &#39;A&#39; &amp;&amp; word[1] &lt;= &#39;Z&#39;)                return isUpper(word.substr(2));            else                 return isLower(word.substr(2));        &#125;        else             return isLower(word.substr(1));            &#125;    bool isUpper(string str)&#123;        for(char c:str)&#123;            if(c &lt; &#39;A&#39; || c &gt; &#39;Z&#39;)                return false;        &#125;        return true;    &#125;    bool isLower(string str)&#123;        for(char c:str)&#123;            if(c &lt; &#39;a&#39; || c &gt; &#39;z&#39;)                return false;        &#125;        return true;    &#125;&#125;;</code></pre><h3 id="606-Construct-String-from-Binary-Tree"><a href="#606-Construct-String-from-Binary-Tree" class="headerlink" title="606. Construct String from Binary Tree"></a>606. Construct String from Binary Tree</h3><p>You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.</p><p><strong>Example 2:</strong></p><pre><code>Input: Binary tree: [1,2,3,null,4]       1     /   \    2     3     \        4 Output: &quot;1(2()(4))(3)&quot;</code></pre><ul><li>需要注意的是，对于字符串使用“+”,则连续拼接的不能是两个常字符串，需要把整数转换为字符串<ul><li>在整数后面+””强制类型转换为字符串</li><li>to_string(整数)</li><li>ostringstre</li><li>sprintf等</li></ul></li></ul><h4 id="solution1-递归，先序遍历"><a href="#solution1-递归，先序遍历" class="headerlink" title="solution1-递归，先序遍历"></a>solution1-递归，先序遍历</h4><ul><li>每到一个节点，只考虑以这个节点为根的子树</li><li>三种情况<ul><li>左右孩子都没有，则返回当前值即可</li><li>有左孩子，但是没有右孩子，给左孩子加上括号，遍历左孩子即可</li><li>有左右孩子，给左孩子及右孩子加括号，分别遍历</li></ul></li><li>值得注意的是，没有单独考虑有右孩子，没左孩子的情况，这是因为，左孩子不管有没有，都不需要特殊处理，是需要加括号的，而右孩子没有的情况下，是没有括号的。</li></ul><pre><code class="C++">class Solution &#123;public:    string tree2str(TreeNode* t) &#123;        if(t == NULL)            return &quot;&quot;;        string str = to_string(t-&gt;val);//拼接的时候一直有问题，必须转成字符串？？？？？fuck，我的一个小时。。。                if((t-&gt;left) == NULL &amp;&amp; (t-&gt;right) == NULL)            return  str;         if((t-&gt;right) == NULL)            return str + &quot;(&quot; + tree2str(t-&gt;left) + &quot;)&quot;;        return str + &quot;(&quot; + tree2str(t-&gt;left) + &quot;)(&quot; + tree2str(t-&gt;right) + &quot;)&quot;;    &#125;&#125;;</code></pre><h4 id="solution2-stack-1"><a href="#solution2-stack-1" class="headerlink" title="solution2-stack"></a>solution2-stack</h4><ul><li>先序遍历，顺序为根，左，右</li><li>对每一个未访问的当前节点，设置为已访问，res+=”(“ + to_string(val)</li><li>对当前节点的左右孩子进行判断，还是三种情况：<ul><li>如果是有右孩子但是没左孩子，那么结果中直接加上”()”，不需要将元素入栈</li><li>如果有右孩子，右孩子入栈</li><li>如果有左孩子，左孩子入栈，这样的先后顺序使得左孩子可以先被访问</li></ul></li><li>每一步只处理一个节点，当前栈顶节点，被访问过则弹出，没被访问过则访问</li><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="C++">class Solution &#123;public:    string tree2str(TreeNode* t) &#123;        if(t == NULL)            return &quot;&quot;;        stack&lt;TreeNode*&gt; s;        set&lt;TreeNode*&gt; visited;        string res = &quot;&quot;;        s.push(t);                while(!s.empty())&#123;            t = s.top();            if(visited.find(t) != visited.end())&#123;                s.pop();                res+= &quot;)&quot;;                //cout&lt;&lt;res&lt;&lt;endl;            &#125;else&#123;                visited.insert(t);                res+=&quot;(&quot; + to_string(t-&gt;val);                if(t-&gt;left == NULL &amp;&amp; t-&gt;right != NULL)                    res+=&quot;()&quot;;                if(t-&gt;right != NULL)//先push右边，再push左边，这样就可以先访问左边，后右边                    s.push(t-&gt;right);                if(t-&gt;left != NULL)                    s.push(t-&gt;left);            &#125;        &#125;        return res.substr(1,res.size()-2);//为了通用性，给第一个元素也是加了左右括号，最后要去掉    &#125;            &#125;;</code></pre><h3 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383. Ransom Note"></a>383. Ransom Note</h3><p><strong>题目描述</strong></p><p>ransom note 可以被magazine 构造，就是看 magazine中拥有的字符，是否足够形成ransome note，不用管字母顺序</p><p><strong>example</strong></p><pre><code>canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</code></pre><h4 id="solution1-库函数调用"><a href="#solution1-库函数调用" class="headerlink" title="solution1-库函数调用"></a>solution1-库函数调用</h4><ul><li>有点类似原串中找子序列的感觉，依次比较就完事了，结果却是理解错题目了。。</li><li>不用管字母出现的次序</li><li>时间：O(n)，空间：O(1)，效率非常低</li></ul><pre><code class="C++">class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;           for(char c : ransomNote)&#123;            int pos = magazine.find(c);            if(pos != string::npos)                magazine.erase(pos,1);            else                return false;        &#125;        return true;    &#125;&#125;;</code></pre><h4 id="solution2-map-数组"><a href="#solution2-map-数组" class="headerlink" title="solution2-map\数组"></a>solution2-map\数组</h4><ul><li>对原串中有的字符进行映射，依次累加对应字符的次数</li><li>对匹配串中的字符进行映射，一旦字符对应次数小于=0，则说明没法匹配了，返回false</li></ul><pre><code class="C++">/*class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        unordered_map&lt;char,int&gt; maga(26);        for(char c: magazine)&#123;            maga[c]++;        &#125;        for(char c : ransomNote)&#123;            if(maga[c] &lt;= 0 )                return false;            maga[c]--;        &#125;        return true;    &#125;&#125;;*/class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        int maga[26] = &#123;0,&#125;;        for(char c: magazine)&#123;            maga[c-&#39;a&#39;]++;        &#125;        for(char c : ransomNote)&#123;            if(maga[c-&#39;a&#39;] &lt;= 0 )                return false;            maga[c-&#39;a&#39;]--;        &#125;        return true;    &#125;&#125;;</code></pre><h3 id="387-First-Unique-Character-in-a-String"><a href="#387-First-Unique-Character-in-a-String" class="headerlink" title="387. First Unique Character in a String"></a>387. First Unique Character in a String</h3><p><strong>题目描述</strong></p><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p><p><strong>example</strong></p><pre><code>s = &quot;loveleetcode&quot;,return 2.</code></pre><h4 id="solution-map"><a href="#solution-map" class="headerlink" title="solution-map"></a>solution-map</h4><ul><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="C++">class Solution &#123;public:    int firstUniqChar(string s) &#123;        int len = s.size();        int cnt[26] = &#123;0,&#125;;        for(char c:s)            cnt[c-&#39;a&#39;]++;        //因为要找出第一个单独出现的字符，那么遍历原串就可以是原来的顺序啊 ~~~你怎么这么笨，map仅仅作为一个查询的东西        for(int i = 0 ; i &lt; len; i++)&#123;            if(cnt[s[i]-&#39;a&#39;] == 1)                return i;        &#125;        return -1;    &#125;&#125;;</code></pre><h3 id="541-Reverse-String-II"><a href="#541-Reverse-String-II" class="headerlink" title="541. Reverse String II"></a>541. Reverse String II</h3><p><strong>题目描述</strong></p><p>Given a string and an integer k, you need to reverse the first k  characters for every 2k characters counting from the start of the string. </p><p>If there are less than k characters left, reverse all of them. </p><p>If there are less than 2k but greater than or equal to k characters,  then reverse the first k characters and left the other as original.</p><p><strong>Example:</strong></p><pre><code>Input: s = &quot;abcdefg&quot;, k = 2Output: &quot;bacdfeg&quot;</code></pre><h4 id="solution-5"><a href="#solution-5" class="headerlink" title="solution"></a>solution</h4><ul><li>将字符串按照2K分组（可能有余数，可能没有），对每个组内的前k个做逆转</li><li>对于最后一个不足2k的，单独处理<ul><li>有k个，逆转</li><li>不够k个，全逆转！！！仔细读题目谢谢！</li></ul></li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    string reverseStr(string s, int k) &#123;        int len = s.size();        if(len &lt; k)&#123;            reverse(s,0,len-1);//对于结束的点要注意            return s;        &#125;        //这种情况很容易忽略,都是不看题目的锅        if(len &lt; 2*k)&#123;            reverse(s,0,k-1);        &#125;                    //len至少是大于2k的        int cnt = len/(2*k);                int start = 0;        for(int i = 0; i &lt; cnt; i++)&#123;            start = 2*i*k;            reverse(s,start,start+k-1);        &#125;        start += 2*k;        if(len - start &gt;= k)            reverse(s,start,start+k-1);        if(len - start &lt; k)            reverse(s,start,len -1);                return s;    &#125;        void reverse(string&amp; s, int start, int en)&#123;        for(int i = start, j = en; i &lt; j; i++,j--)&#123;            s[i] ^= s[j];            s[j] ^= s[i];            s[i] ^= s[j];        &#125;    &#125;&#125;;</code></pre><h4 id="solution2-1"><a href="#solution2-1" class="headerlink" title="solution2"></a>solution2</h4><pre><code class="C++">class Solution &#123;public:    string reverseStr(string s, int k) &#123;        int start = 0;        int len = s.size();        while(start &lt; len)&#123;            if(start + k &lt; len)                reverse(s.begin()+start, s.begin()+start+k );            else                reverse(s.begin()+start,s.end());            start += k + k;         &#125;        return s;    &#125;&#125;;</code></pre><h3 id="345-Reverse-Vowels-of-a-String"><a href="#345-Reverse-Vowels-of-a-String" class="headerlink" title="345. Reverse Vowels of a String"></a>345. Reverse Vowels of a String</h3><p><strong>Example 1:</strong></p><pre><code>Input: &quot;hello&quot;Output: &quot;holle&quot;</code></pre><h4 id="solution-双指针"><a href="#solution-双指针" class="headerlink" title="solution- 双指针"></a>solution- 双指针</h4><ul><li>分别向前，向后扫描，交换元音字母</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    bool isVowel(char c)&#123;        if(c == &#39;a&#39; || c == &#39;A&#39;|| c == &#39;e&#39;|| c == &#39;E&#39;|| c == &#39;i&#39;|| c == &#39;I&#39;|| c == &#39;o&#39;|| c == &#39;O&#39; || c == &#39;u&#39; || c == &#39;U&#39;)            return true;        else            return false;    &#125;    string reverseVowels(string s) &#123;                int len = s.size();        int i = 0, j = len-1;        while(i &lt; j)&#123;            while(i &lt; j &amp;&amp; !isVowel(s[i]))&#123;                    i++;            &#125;             while(i &lt; j &amp;&amp; !isVowel(s[j]))&#123;                                  j--;            &#125;            if(i &lt; j)&#123;                cout&lt;&lt;s[i]&lt;&lt;&quot;:&quot;&lt;&lt;s[j]&lt;&lt;endl;                char tmp = s[i];                s[i] = s[j];                s[j] = tmp;                            &#125;            i++;            j--;                &#125;        return s;    &#125;  &#125;;</code></pre><h3 id="551-Student-Attendance-Record-I"><a href="#551-Student-Attendance-Record-I" class="headerlink" title="551. Student Attendance Record I"></a>551. Student Attendance Record I</h3><p><strong>题目描述</strong></p><p>You are given a string representing an attendance record for a student. The record only contains the following three characters:  </p><ol><li><strong>‘A’</strong> : Absent. </li><li><strong>‘L’</strong> : Late.</li><li> <strong>‘P’</strong> : Present. </li></ol><p> A student could be rewarded if his attendance record doesn’t contain <strong>more than one ‘A’ (absent)</strong> or <strong>more than two continuous ‘L’ (late)</strong>.    </p><h4 id="solution-统计"><a href="#solution-统计" class="headerlink" title="solution-统计"></a>solution-统计</h4><ul><li> 时间：O(n)，空间：O(1)</li><li>题目得仔细看，一不小心就写错了</li></ul><pre><code class="C++">class Solution &#123;public:    bool checkRecord(string s) &#123;        int len = s.size();        int cntA = 0;        for(int i = 0; i &lt; len; i++)&#123;            if(s[i] == &#39;A&#39;)                cntA++;        &#125;        if(cntA &gt; 1 || s.find(&quot;LLL&quot;) != string::npos)            return false;        else            return true;        &#125;&#125;;</code></pre><h4 id="solution2-if-else"><a href="#solution2-if-else" class="headerlink" title="solution2-if-else"></a>solution2-if-else</h4><ul><li>别人写的，还没有理解其妙处</li></ul><pre><code class="C++">class Solution &#123;public:    bool checkRecord(string s) &#123;        int l = 0, a = 0;        for(char c:s)&#123;            if(c == &#39;A&#39;)                a++;                        if(c == &#39;L&#39;)//为啥这里不可以用if else？c不是只能等于一个数？我知道了，对于连续的L，会一直计数，然后下面的if会判断是否已经到了不合格的时候，一旦不连续，则直接被置0，从头开始                l++;            else                l = 0;            if(a &gt; 1 || l &gt; 2)                return false;        &#125;        return true;    &#125;&#125;;</code></pre><h3 id="415-Add-Strings"><a href="#415-Add-Strings" class="headerlink" title="415. Add Strings"></a>415. Add Strings</h3><p><strong>题目描述</strong></p><p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as string, return the sum of <code>num1</code> and <code>num2</code></p><h4 id="solution-6"><a href="#solution-6" class="headerlink" title="solution"></a>solution</h4><ul><li>就是小学生加法，一步步加，比如 A+B，需要考虑A长度，B长度，以及进位</li><li>这么简单的题，也能耗个几天才做完，自己写的代码里有一半都有点冗余，所以直接放参考别人写的了</li><li>每次只需要考虑当前位的A[i],B[j],carry</li><li>时间：O(n)，空间：O(n)，n表示相加的数最长长度</li></ul><pre><code class="C++">class Solution &#123;public:    string addStrings(string num1, string num2) &#123;        string res = &quot;&quot;;            int sum = 0;        int i = num1.size()-1, j = num2.size()-1,carry = 0;        while(i &gt;= 0 || j &gt;= 0 || carry == 1)&#123;            int x = i&lt;0?0:num1[i]-&#39;0&#39;;            int y = j&lt;0?0:num2[j]-&#39;0&#39;;            sum = x+y+carry;            carry = sum/10;            res+=to_string(sum%10);            i--;            j--;        &#125;        reverse(res.begin(),res.end());        return res;    &#125;&#125;;</code></pre><h3 id="67-Add-Binary"><a href="#67-Add-Binary" class="headerlink" title="67. Add Binary"></a>67. Add Binary</h3><p><strong>题目描述</strong></p><p>Given two binary strings, return their sum (also a binary string).</p><p><strong>Example 2:</strong></p><pre><code>Input: a = &quot;1010&quot;, b = &quot;1011&quot;Output: &quot;10101&quot;</code></pre><h4 id="solution-类似string的加法"><a href="#solution-类似string的加法" class="headerlink" title="solution-类似string的加法"></a>solution-类似string的加法</h4><ul><li>需要考虑的就是a[i]，b[j]，carry</li></ul><pre><code class="C++">class Solution &#123;public:    string addBinary(string a, string b) &#123;        int i = a.size()-1,j = b.size()-1;        int carry = 0;        string res = &quot;&quot;;        while(i &gt;= 0 || j &gt;= 0 || carry == 1 )&#123;            int sum = carry;            if(i &gt;= 0)&#123;                sum += a[i]-&#39;0&#39;;                i--;            &#125;            if(j &gt;=0 )&#123;                sum += b[j]-&#39;0&#39;;                j--;            &#125;            res += to_string(sum%2);            carry = sum/2;         &#125;        reverse(res.begin(),res.end());        return res;           &#125;&#125;;</code></pre><h3 id="925-Long-Pressed-Name"><a href="#925-Long-Pressed-Name" class="headerlink" title="925. Long Pressed Name"></a>925. Long Pressed Name</h3><p><strong>题目描述</strong></p><p>name是真名字，typed是不小心有多打的，typed是不是真的多打的</p><h4 id="solution-7"><a href="#solution-7" class="headerlink" title="solution"></a>solution</h4><ul><li>因为typed中有长重复输入，那么如果它是name的长输入，长度一定是大于等于name的，如果两者是相等的，直接返回成功。</li><li>遍历typed，将typed中的连续相同字符用cnt表示为一个group</li><li>遍历name，依次探测typed中 group 的元素个数以及元素本身是否匹配</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    bool isLongPressedName(string name, string typed) &#123;        if(name == typed)            return true;                int len1= name.size(),len2 = typed.size();        if(len1 &gt; len2)            return false;                int i = 0, j = 0;        while(i &lt; len1 &amp;&amp; j &lt; len2)&#123;            if(name[i] != typed[j])                return false;            i++;            j++;            int cnt = 0;            int typeTmp = typed[j-1],nameTmp = name[i-1];            while((typed[j] == typeTmp ) &amp;&amp; (j &lt; len2))&#123;                cnt++;                j++;            &#125;            while((name[i] == nameTmp) &amp;&amp; (i &lt; len1))&#123;                if(cnt &gt; 0)&#123;                    cnt--;                    i++;                &#125;else                    return false;            &#125;        &#125;        return i == len1 &amp;&amp; j == len2;    &#125;&#125;;</code></pre><h3 id="819-Most-Common-Word"><a href="#819-Most-Common-Word" class="headerlink" title="819. Most Common Word"></a>819. Most Common Word</h3><p><strong>题目描述</strong></p><p>Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. </p><p>Words in the list of banned words are given in lowercase, and free of  punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.</p><p><strong>Example:</strong></p><pre><code>Input: paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;banned = [&quot;hit&quot;]Output: &quot;ball&quot;</code></pre><h4 id="solution-8"><a href="#solution-8" class="headerlink" title="solution"></a>solution</h4><ul><li>做题之前先想清楚再做，每次都是，要不做一半，发现理解错题意了，要不就是做到最后，越做越乱</li><li>新语法：sstringstream，map的make_pair</li><li>思路就是：<ul><li>首先把paragraph做处理，把其他punctuation都变为“ ”，在这个过程中，把大写都转换为小写。因为在banned中的单词都是小写。这里要注意的是，把逗号之类的转换为空格，加上本来就存在的空格，会出现两个空格的清空，用string的find空格，会出错！！！</li><li>遍历段落中的单词，记录出现次数最多并且不再banned中的<ul><li>这里的一个技巧点，并不是总需要一步一步向下走，像这种一边查看是否在banned中，一边就可以去比较出现次数，出现次数一旦是最多的，就可以记录，而不是先将所有的单词出现次数记录一遍，然后再去遍历这个次数，找出最多</li></ul></li></ul></li><li>因为用到了在banned中find的操作，因此将vector转换为set了</li><li>要返回的是string，这个string的次数还要出现最多，因此选用map作为存储中间结果的数据结构</li><li>时间：O(n+m),空间：O(n+m)，n和m分别为para和banned的大小</li></ul><pre><code class="C++">class Solution &#123;public:    string mostCommonWord(string para, vector&lt;string&gt;&amp; banned) &#123;        unordered_set&lt;string&gt;s(banned.begin(),banned.end());        unordered_map&lt;string,int&gt;mymap;        int len = para.size();        for(char &amp;c : para)            c = isalpha(c)?tolower(c):&#39; &#39;;               pair&lt;string,int&gt; res(&quot;&quot;,0);        istringstream iss(para);        string word;       while(iss &gt;&gt; word)&#123;            if((s.find(word) == s.end()) &amp;&amp; (++mymap[word] &gt; res.second))                res = make_pair(word,mymap[word]);        &#125;               return res.first;    &#125;&#125;;</code></pre><h3 id="443-String-Compression"><a href="#443-String-Compression" class="headerlink" title="443. String Compression"></a>443. String Compression</h3><p><strong>Example 1:</strong></p><pre><code>Input:[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]Output:Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]Explanation:&quot;aa&quot; is replaced by &quot;a2&quot;. &quot;bb&quot; is replaced by &quot;b2&quot;. &quot;ccc&quot; is replaced by &quot;c3&quot;.</code></pre><h4 id="solution-9"><a href="#solution-9" class="headerlink" title="solution"></a>solution</h4><ul><li>思路比较简单，但是有点难写</li><li>考虑两种情况<ul><li>连续出现的字符，首先定位一个字符，接着一直向后扫描</li><li>相邻两个字符不一致（这里比较时用的是：当前字符和下一个字符）/已经到了字符末尾<ul><li>记录当前字符，记录当前字符出现的次数</li></ul></li></ul></li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    int compress(vector&lt;char&gt;&amp; chars) &#123;        int len = chars.size();                int cur = 0, newIndex = 0;//cur：当前比较的字符，newIndex：是新记录的vector，因为新的结果大小 &lt;= 原vector，因此可以一边遍历重复使用，最后返回index        for(int i = 0; i&lt; len; i++)&#123;            if(i+1 == len || chars[i] != chars[i+1])&#123;                chars[newIndex++] = chars[i];                                 //记录当前重复字符出现的次数，对于只出现一次的，则没有这步                if(cur &lt; i)&#123;                    string cnt = to_string(i-cur+1);                    for(char c: cnt)                        chars[newIndex++] = c;                &#125;                              cur = i+1;            &#125;        &#125;        return newIndex;         &#125;&#125;;</code></pre><h3 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h3><p><strong>题目描述</strong></p><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><h4 id="solution2-辅助栈"><a href="#solution2-辅助栈" class="headerlink" title="solution2-辅助栈"></a>solution2-辅助栈</h4><ul><li>如果是左括号，进栈，如果是右括号，匹配栈顶是否为对应的左括号</li><li>时间：O(n)，空间：O(n)-辅助栈</li></ul><pre><code class="C++">class Solution &#123;public:    bool isValid(string s) &#123;        stack&lt;char&gt;ch;        for(int i = 0; i &lt; s.size(); i++)&#123;            if(s[i] == &#39;(&#39; || s[i] == &#39;&#123;&#39; || s[i] == &#39;[&#39;)                ch.push(s[i]);            else&#123;                if(ch.empty()) return false;//这个很重要，要弹出，首先就要判断栈是否为空                if(s[i] == &#39;)&#39; &amp;&amp; ch.top() != &#39;(&#39;)                    return false;                if(s[i] == &#39;&#125;&#39; &amp;&amp; ch.top() != &#39;&#123;&#39;)                    return false;                if(s[i] == &#39;]&#39; &amp;&amp; ch.top() != &#39;[&#39;)                    return false;                                ch.pop();            &#125;               &#125;        return ch.empty();             &#125;&#125;;</code></pre><h3 id="434-Number-of-Segments-in-a-String"><a href="#434-Number-of-Segments-in-a-String" class="headerlink" title="434. Number of Segments in a String"></a>434. Number of Segments in a String</h3><p><strong>题目描述</strong></p><p>Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.</p><p><strong>Example:</strong></p><pre><code>Input: &quot;Hello, my name is John&quot;Output: 5</code></pre><h4 id="solution-查找空格-错误"><a href="#solution-查找空格-错误" class="headerlink" title="solution-查找空格-错误"></a>solution-查找空格-错误</h4><ul><li>这道题就是在考察各种特殊情况<ul><li>结尾有没有空格</li><li>字符串为空</li><li>只有一个字符串</li></ul></li><li>事实证明我写的这个不行，突然想到了前几天用到的istringstream</li></ul><pre><code class="C++">class Solution &#123;public:    int countSegments(string s) &#123;        if(s.empty())            return 0;        int cnt = 0;        istringstream ss(s);        string w;        while(ss&gt;&gt;w)&#123;            cnt++;        &#125;        return cnt;      &#125;&#125;;</code></pre><h3 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125. Valid Palindrome"></a>125. Valid Palindrome</h3><p><strong>题目描述</strong></p><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;A man, a plan, a canal: Panama&quot;Output: true</code></pre><h4 id="solution1"><a href="#solution1" class="headerlink" title="solution1"></a>solution1</h4><ul><li>对原字符串进行处理，注意题目的意思包括字符和数字</li><li>判断是否为回文</li><li>时间：O(n),空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    bool isPalindrome(string s) &#123;        if(s.empty())            return true;                int len = s.size();        for(int i = 0; i &lt; len; i++)&#123;            char c = s[i];            //s[i] = isalpha(c)?tolower(s[i]):&#39;&#39;;//&#39; &#39;不知道为啥不能在这里放                        if(isalpha(c))                s[i] = tolower(c);            else if(isdigit(c))&#123;                continue;            &#125;            else                s[i] = &#39; &#39;;                          &#125;                 int k = 0, j = len-1;                 while(k &lt; j)&#123;            while(s[k] == &#39; &#39; &amp;&amp; k &lt; j)  k++;                          while(s[j] == &#39; &#39; &amp;&amp; k &lt; j)  j--;                            if(s[k] != s[j])                return false;            k++;            j--;//一定要记得在这里更新循环值        &#125;       return true;            &#125;&#125;;</code></pre><h4 id="solution2-2"><a href="#solution2-2" class="headerlink" title="solution2"></a>solution2</h4><ul><li>isnumalp()：既可以判断是否为数字，又可以判断是否为字母</li><li>transform()：对大小写的转换</li></ul><pre><code class="C++">class Solution &#123;public:    bool isPalindrome(string s) &#123;        if(s.empty())            return true;        transform(s.begin(),s.end(),s.begin(),::tolower);                int i = 0, j = s.size()-1;        while(i &lt; j)&#123;            bool flag1 = isAlphaNumeric(s[i]), flag2 = isAlphaNumeric(s[j]);                        if(flag1 &amp;&amp; flag2)&#123;                if(s[i] == s[j])&#123;                    i++;                    j--;                &#125;else                    return false;                                &#125;else if(flag1)&#123;                j--;            &#125;else if(flag2)&#123;                i++;            &#125;else&#123;                i++;                j--;            &#125;        &#125;        return true;           &#125;    bool isAlphaNumeric(char c)&#123;        if((c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) ||(c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;))            return true;        else            return false;    &#125;&#125;;</code></pre><h3 id="680-Valid-Palindrome-II"><a href="#680-Valid-Palindrome-II" class="headerlink" title="680. Valid Palindrome II"></a>680. Valid Palindrome II</h3><p> <strong>题目描述</strong></p><p>Given a non-empty string <code>s</code>, you may delete <strong>at most</strong> one character.  Judge whether you can make it a palindrome. </p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;abca&quot;Output: True</code></pre><h4 id="solution-10"><a href="#solution-10" class="headerlink" title="solution"></a>solution</h4><ul><li><p>回文就是正着反着读出来都一样</p></li><li><p>出栈读取和原字符串一样，这里的区别是，可以有一次机会，某个字符可以不是回文</p></li><li><p>这里有个问题就是，在遍历过程中，当两个字符不一致的时候，到达是哪一个字符向前走一个，因此，想到了递归</p></li><li><p>不断地缩小问题，双指针，一个从前往后，一个从后往前，每次比较两个字符   - 如果相等，则缩小范围</p><ul><li>如果不相等，则向左或者向右缩小范围 </li></ul></li><li><p>时间：O(n)，空间：O(n)</p></li></ul><pre><code class="C++">class Solution &#123;public:    bool isEqual(string s, int beg, int en)&#123;         //cout&lt;&lt;s.substr(beg,en-beg+1)&lt;&lt;endl;        /* // 内存超了        if(beg &gt; en)            return true;        if(s[beg] == s[en])            return isEqual(s, beg+1, en-1);        else            return false;                      */         for(int i = beg, j = en; i &lt; j ; i++, j--)&#123;            if(s[i] != s[j])                return false;        &#125;        return true;                     &#125;        bool validPalindrome(string s) &#123;        int len = s.size();        int beg = 0, en = len-1;                while(beg &lt;= en)&#123;            if(s[beg] != s[en])&#123;                return (isEqual(s,beg+1,en)) || (isEqual(s,beg,en-1));            &#125;                beg++;            en--;        &#125;                return true;           &#125;&#125;;</code></pre><h3 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28. Implement strStr()"></a>28. Implement strStr()</h3><p><strong>题目描述</strong></p><p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p><p><strong>Example 1:</strong></p><pre><code>Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2</code></pre><p><strong>solution</strong></p><pre><code class="C++">class Solution &#123;public:    int strStr(string haystack, string needle) &#123;        if(needle.empty() || haystack == needle)            return 0;        int len1 = haystack.size(),len2= needle.size();        if( len1 &lt; len2 )            return -1;        int pos = haystack.find(needle,0);        if(pos != string::npos)            return pos;        else            return -1;        &#125;&#125;;</code></pre><h3 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h3><p><strong>题目描述</strong></p><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p><p><strong>Example 1:</strong></p><pre><code>Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;</code></pre><h4 id="solution-11"><a href="#solution-11" class="headerlink" title="solution"></a>solution</h4><ul><li>依次遍历vector，依次比较每个单词对应的元素,用set中元素是unique的特性来存储相同元素</li><li>时间：有一个排序的过程，O(Nlog(N))?，双层循环：O(n*N)，n是最短字符串的长度，N是vector的大小</li><li>空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    static bool cmp(const string&amp; s1, const string&amp; s2)&#123;        return s1.size() &lt; s2.size();    &#125;    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;        int vLen = strs.size();        if(strs.empty())            return &quot;&quot;;                if( vLen == 1)            return strs[0];                sort(strs.begin(),strs.end(),cmp);//表示最长公共前缀是最短的那个字符串,直接用sort是对字符本身的排序，而这里需要的是对字符串的长度进行排序        int sLen = strs[0].size();        //cout&lt;&lt;sLen&lt;&lt;endl;                        for(int i = 0; i&lt; sLen; i++)&#123;            char tmp = strs[0][i];            for(int j = 1; j &lt; vLen; j++)&#123;                if(strs[j][i] != tmp)                    return strs[0].substr(0,i);;            &#125;         &#125;                return strs[0];            &#125;&#125;;</code></pre><h3 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a>58. Length of Last Word</h3><p><strong>题目描述</strong></p><p>Given a string <em>s</em> consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word in the string.</p><h4 id="solution-12"><a href="#solution-12" class="headerlink" title="solution"></a>solution</h4><ul><li>看别人的代码，总有一种胜读十年书的感觉</li><li>时间：O(n)，空间：O(1)</li><li>note:isblank()</li><li>让别人的智慧来熏陶一下自己，自己的代码就放在后面来激励一下自己吧</li></ul><pre><code class="C++">class Solution &#123;public:    int lengthOfLastWord(string s) &#123;        if(s.empty())            return 0;        int i = s.size()-1;        while(i &gt;= 0 &amp;&amp; isblank(s[i]))            i--;        int len = 0;        while(i &gt;= 0 &amp;&amp; !isblank(s[i]))&#123;            len++;            i--;        &#125;        return len;    &#125;&#125;;</code></pre><pre><code class="c++">class Solution &#123;public:    int lengthOfLastWord(string s) &#123;        if(s.empty())            return 0;        int len = s.size();        int i = len-1;        while(i &gt;= 0 &amp;&amp; s[i] == &#39; &#39;) i--;        if(i &lt; 0)            return 0;                int start = i;        while(i &gt;= 0)&#123;            if(s[i] == &#39; &#39;)//这里是统计最后一个单词的停止地方                return start - i;        &#125;            i--;        return start - i;    &#125;&#125;;</code></pre><h3 id="686-Repeated-String-Match"><a href="#686-Repeated-String-Match" class="headerlink" title="686. Repeated String Match"></a>686. Repeated String Match</h3><p><strong>题目描述</strong></p><p>Given two strings A and B, find the minimum number of times A has to  be repeated such that B is a substring of it. If no such solution,  return -1.</p><p>For example, with A = “abcd” and B = “cdabcdab”.</p><p>Return 3, because by repeating A three times (“abcdabcdabcd”), B is a  substring of it; and B is not a substring of A repeated two times  (“abcdabcd”).</p><h4 id="solution-13"><a href="#solution-13" class="headerlink" title="solution"></a>solution</h4><ul><li>B是A*k的子串，求最小的k</li><li>首先肯定需要A的长度大于等于B，之后比较B是否包含在A内</li><li>当长度是k时不包含，则再加一个A如果还不包含，那指定不包含了</li><li>时间：O(n)，空间：O(n)：n是字符的个数</li></ul><pre><code class="c++">class Solution &#123;public:    int repeatedStringMatch(string A, string B) &#123;        if(A.find(B) != string::npos)            return 1;                int time = 1;        string resA = A;        while(resA.size() &lt; B.size())&#123;            resA += A;//这里不能是A的自加，因为A变化后，下次加的是其新值            time++;        &#125;        int pos1 = resA.find(B);        if(pos1 != string::npos)            return time;                resA += A;        int pos2 = resA.find(B);        if(pos2 != string::npos)            return time+1;                return -1;    &#125;&#125;;</code></pre><h3 id="859-Buddy-Strings"><a href="#859-Buddy-Strings" class="headerlink" title="859. Buddy Strings"></a>859. Buddy Strings</h3><p><strong>题目描述</strong></p><p>Given two strings <code>A</code> and <code>B</code> of lowercase letters, return <code>true</code> if and only if we can swap two letters in <code>A</code> so that the result equals <code>B</code>.</p><p><strong>Example 1:</strong></p><pre><code>Input: A = &quot;ab&quot;, B = &quot;ba&quot;Output: trueInput: A = &quot;aa&quot;, B = &quot;aa&quot;Output: true</code></pre><h4 id="solution1-遍历-1"><a href="#solution1-遍历-1" class="headerlink" title="solution1-遍历"></a>solution1-遍历</h4><ul><li>A、B的长度不等，那么一定不可能相等</li><li>A、B长度为2，A[1] == B[0] &amp;&amp; A[0] == B[1]</li><li>如果两者都相等，除非有个元素是重复出现过，否则也不可以。</li><li>主要思路是：依次比较A和B的每个元素，如果第一次不相等，则记录位置，等到第二次不相等的时候，看A，B不相等的元素是否和第一次不相等位置的元素正好匹配</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    bool buddyStrings(string A, string B) &#123;        int lenA = A.size(), lenB = B.size();        if(lenA != lenB)            return false;        if(lenA == 2)            return (A[1] == B[0]) &amp;&amp; (A[0] == B[1]);        if(A == B)            return hasDup(A);//对于相等的A和B，当且仅当A有重复元素时，可以交换相同元素，否则，不可以                    int i = 0,first = 0;//first记录第一次不一致的位置        bool flag = false,flag1 = false;//flag为true时表示已经有过不一致,flag1为true表示有过第二次不一致，而且已经有过一次交换的机会了，不能再有不一致了        while(i &lt; lenA)&#123;            if(A[i] == B[i])&#123;                i++;            &#125;else if(flag)&#123;                if(!flag1  &amp;&amp; A[first] == B[i] &amp;&amp; B[first] == A[i])&#123;                     i++;                     flag1 = true;                &#125;else                    return false;            &#125;else&#123;                flag = true;                first = i;                i++;            &#125;        &#125;        return true;;       &#125;        bool hasDup(string s)&#123;        int len = s.size();        for(int i = 0; i &lt; len-1; i++)&#123;            if(s.find(s[i],i+1) != string::npos)                return true;        &#125;        return false;    &#125;   &#125;;</code></pre><h4 id="solution2-利用额外空间"><a href="#solution2-利用额外空间" class="headerlink" title="solution2-利用额外空间"></a>solution2-利用额外空间</h4><ul><li>主要的不同就是<ul><li>对于相同的两个字符串，判断是否有重复元素，用了set</li><li>对于不同的元素位置的记录，使用了vector</li></ul></li><li>时间：O(n)，都是一遍扫描，空间：O(n)：用到了set，vector</li></ul><pre><code class="C++">class Solution &#123;public:    bool buddyStrings(string A, string B) &#123;        int lenA = A.size(), lenB = B.size();        if(lenA != lenB)            return false;        //这里我第一个想到的就是set，但是不知道怎么用，看了别人写的，简直太机智了        if(A == B)&#123;            if(set&lt;char&gt;(A.begin(), A.end()).size() &lt; A.size())                 return true;//这里只判断了有重复元素的情况        &#125;        vector&lt;int&gt; index;        int i = 0;         while(i &lt; lenA)&#123;            if(A[i] != B[i])                index.push_back(i);            i++;        &#125;        //size == 2这点是判断没有重复元素的情况        return (index.size()==2) &amp;&amp; (A[index[0]] == B[index[1]]) &amp;&amp; (A[index[1]] == B[index[0]]);    &#125;&#125;; </code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my first article</title>
      <link href="/2019/10/03/my-first-article/"/>
      <url>/2019/10/03/my-first-article/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么使用-hexo-框架搭建个人博客？"><a href="#为什么使用-hexo-框架搭建个人博客？" class="headerlink" title="为什么使用 hexo 框架搭建个人博客？"></a>为什么使用 hexo 框架搭建个人博客？</h3><p>&emsp; 正如“点击头像”后的 Why Blog 中所说，想拥有一个可以做个人学习成长记录的博客网站。</p><p>&emsp; 跟着网上的教程，用 jeklly 搭建博客时，是直接在 github 上操作，fork 了别人的模板，因为懂的太少，发现别人的 demo 总是修改不干净，也不知道别人做了一些什么样的人性化设置，就很难受。放弃了…看到了hexo搭建教程，十一国庆节放假用了一天试了一下，成功！<br>ps：还是要找靠谱的博客，非常感谢开源和分享知识的大家！</p><h3 id="当前效果是如何展示的？"><a href="#当前效果是如何展示的？" class="headerlink" title="当前效果是如何展示的？"></a>当前效果是如何展示的？</h3><ul><li><p>本博客使用了 Hexo，它是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></li><li><p>本博客使用了<a href="https://github.com/yelog/hexo-theme-3-hexo">叶落阔提供的 hexo theme</a>（即 3-hexo），来渲染网页内容。themes 相当于整个框架中可插拔的配置。</p></li><li><p>配置都写在 _config.yml 中。hexo init 后的文件夹称作 hexo 项目的根目录；各个 theme 目录下也有一个当前主题的 _config.yml。</p></li><li><p>参考 <a href="https://www.cnblogs.com/shwee/p/11421156.html">洪卫的博客</a>： 1. 安装必要的软件，如 git, npm, nodejs, hexo 等；2. 生成 hexo 框架的必要代码；3. 启动本地服务器查看效果。此时的效果是 themes 文件夹下默认的 landscape 展示。4. 安装 hexo：<code>npm install -g hexo-cli</code></p></li><li><p>参考<a href="https://github.com/yelog/hexo-theme-3-hexo">开源的 3-hexo</a>，将 3-hexo clone 到 themes 文件夹下，再次启动本地服务器查看效果。此时的效果都是demo，里面涉及了很多原作者的个人配置，如用户名等。</p></li><li><p>参考<a href="http://yelog.org/2017/03/23/3-hexo-instruction/">3-hexo 的使用说明</a> 配置 hexo 根目录&amp; theme 下的 _config.yml。可以写简单的demo.md 去看看各种配置的效果。</p></li><li><p>参考<a href="https://www.cnblogs.com/shwee/p/11421156.html">洪卫的博客</a>，将 hexo 部署到GitHub。就可以在xx.github.io 上看到了 用github pages 托管的网页。</p></li><li><p>使用 hexo d 上传部署到 github 的其实是 hexo 编译后的文件，是用来生成网页的，不包含源文件。也就是上传的是在本地目录里自动生成的.deploy_git里面。但是为了备份源文件（即各种.md文档）以及多终端协同使用笔记，参考<a href="https://www.zhihu.com/question/21193762/answer/489124966">直上云霄的回答</a>，用一个新的分支管理源文件，做备份。而 hexo 项目的根目录下的 _config.yml 中 deploy 配置的分支是master。因此 hexo d 时 master 分支会自动变。要同步源文件分支需要手动git<br>add 等进行管理。</p></li></ul><h3 id="博客生成与部署"><a href="#博客生成与部署" class="headerlink" title="博客生成与部署"></a>博客生成与部署</h3><ul><li>首先生成： <code>hexo g </code>，然后在本地预览 <code>hexo s</code>，最后部署在github上<code>hexo d</code></li><li>这是我的第一篇博客，为什么用 npm i hexo-deployer-git 不能生成一个放图片的文件夹呢？</li></ul><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><ul><li><p>对于一些配置，需要在最上面标识，包括 categories，tags等</p><ul><li>比如公式的使用，在每篇文档开头设置mathjax： $v_i$</li></ul></li><li><p>上传图片，用图床,sm.ms，国内网络原因，可以使用<a href="https://smms.app/">https://smms.app/</a></p></li></ul><pre><code class="C++">#include&lt;iostream&gt;using namespace std;int main()&#123;    return 0;&#125;</code></pre><blockquote><p>从小的 demo 开始，一步步累加。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> problem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList-problems-easy</title>
      <link href="/2019/08/28/LinkedList-problems-easy/"/>
      <url>/2019/08/28/LinkedList-problems-easy/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><pre><code class="c++">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */</code></pre><h3 id="876-Middle-of-the-Linked-List"><a href="#876-Middle-of-the-Linked-List" class="headerlink" title="876.Middle of the Linked List"></a>876.Middle of the Linked List</h3><p><strong>题目描述：</strong></p><p>Given a non-empty, singly linked list with head node head, return a middle node of linked list.<br>If there are two middle nodes, return the second middle node.</p><p><strong>Example</strong> :</p><pre><code>Input: [1,2,3,4,5,6]Output: Node 4 from this list (Serialization: [4,5,6])Since the list has two middle nodes with values 3 and 4, we return the second one.</code></pre><h4 id="Solution-1-遍历"><a href="#Solution-1-遍历" class="headerlink" title="Solution 1-遍历"></a>Solution 1-遍历</h4><ul><li>将链表遍历一遍，得到链表的长度，求出中间节点的位置，重新从头开始遍历，输出中间节点。</li></ul><p>时间：O(2n)，空间O(1)？</p><pre><code class="c++">class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        if(head == NULL)            return NULL;        ListNode* tmp = head;        int cnt = 0;        while(tmp != NULL)&#123;            cnt++;            tmp = tmp-&gt;next;        &#125;        int i = cnt/2;        tmp = head;        while(i != 0)&#123;            tmp = tmp-&gt;next;            i--;        &#125;        return tmp;    &#125;&#125;;</code></pre><h4 id="Solution-2-快慢指针"><a href="#Solution-2-快慢指针" class="headerlink" title="Solution 2-快慢指针"></a>Solution 2-快慢指针</h4><ul><li>这个本来是想到了，但是自己不知道为什么演算错了。。。要考虑奇偶个数的情况；</li></ul><p>时间：O(n/2)，空间O(1)-快慢指针</p><pre><code class="c++">class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        if(head == NULL)            return NULL;        ListNode* slow = head, *fast = head;                //快指针比慢指针快一倍的速度，不是两个。。。        while(slow-&gt;next != NULL &amp;&amp; fast-&gt;next != NULL)&#123;            //奇数个元素            if(fast-&gt;next-&gt;next != NULL)&#123;                fast = fast-&gt;next-&gt;next;                slow = slow-&gt;next;            &#125;else&#123;                //返回方法一                fast = fast-&gt;next;                slow = slow-&gt;next;                //return slow-&gt;next;  //返回方法二            &#125;        &#125;        return slow;    &#125;&#125;;</code></pre><h4 id="Solution-3-辅助数组"><a href="#Solution-3-辅助数组" class="headerlink" title="Solution 3-辅助数组"></a>Solution 3-辅助数组</h4><ul><li><p>使用数组把所有元素放进去，按照数组随机存取的特性，直接定位到元素，这样就不是原来链接起来的链表了,用空间换时间。</p></li><li><p>时间O(n)，空间O(n)-vec用的空间</p></li></ul><pre><code class="c++">class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        if(head == NULL)            return NULL;        vector&lt;ListNode*&gt;vec&#123;head&#125;;//注意初始化是&#123;&#125;，不是[]                ListNode* cur = vec.back();        while(cur-&gt;next != NULL)&#123;            vec.push_back(cur-&gt;next);            cur = cur-&gt;next;                    &#125;        return vec[vec.size()/2];//相对于第一种的优点就是考虑到了数组的随机访问快    &#125;&#125;;</code></pre><h3 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h3><p><strong>题目描述：</strong></p><p>Reverse a singly linked list.</p><p><strong>Example:</strong></p><pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><h4 id="solution1-迭代"><a href="#solution1-迭代" class="headerlink" title="solution1-迭代"></a>solution1-迭代</h4><ul><li>主要目的是不要让链表断了，用三个指针分别表示当前节点，前一个，后一个.</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="c++">class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if(head == NULL)            return NULL;                ListNode *cur=NULL,*pre=NULL,*post=NULL;        cur=head;        while(cur!=NULL)   //要注意判断条件        &#123;            post=cur-&gt;next;            cur-&gt;next=pre;            pre=cur;            cur=post;        &#125;             return pre;            &#125;&#125;;//这个和上面的差不多，根本不是递归，就是迭代吧/*class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if(head == NULL)            return NULL;                ListNode *cur=NULL,*pre=NULL,*post=NULL;        cur=head;        return reverse(pre,cur,post);    &#125;    ListNode* reverse(ListNode* pre, ListNode* cur, ListNode* post)&#123;        if(cur == NULL)            return pre;        post = cur-&gt;next;        cur-&gt;next = pre;        pre  = cur;        return reverse(pre,post,post);    &#125;&#125;;*/</code></pre><h4 id="Solution2-递归"><a href="#Solution2-递归" class="headerlink" title="Solution2-递归"></a>Solution2-递归</h4><ul><li>主要是要理解递归。边界条件，cur == NULL则链表是空的，cur-&gt;next == NULL意味着链表已经到最后一个节点了，那么这个节点是新的head，开始返回。</li><li>递归时会为每个参数变量压栈，返回后就是当时的cur，那么cur的next是逆转的节点，这个节点的next就是cur。思路参考<a href="https://www.youtube.com/watch?v=MRe3UsRadKw">https://www.youtube.com/watch?v=MRe3UsRadKw</a></li><li>做的时候难点在于：指针的理解，<code>**</code>的理解及传参，以及如何改变head指针。</li><li>时间：O(n)，空间：O(n)-因为递归而使用的栈空间    </li></ul><pre><code class="c++">class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if(head == NULL)            return NULL;                ListNode *cur = head;        reverse(cur,&amp;head);        return head;    &#125;     void reverse(ListNode* cur,ListNode** head)&#123;         if(cur-&gt;next == NULL)&#123;             *head = cur;             return ;         &#125;         reverse(cur-&gt;next,head);         cur-&gt;next-&gt;next = cur;         cur-&gt;next = NULL;     &#125;&#125;;</code></pre><h3 id="237-Delete-Node-in-a-Linked-List"><a href="#237-Delete-Node-in-a-Linked-List" class="headerlink" title="237.Delete Node in a Linked List"></a>237.Delete Node in a Linked List</h3><p><strong>题目描述：</strong></p><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p><p>Given linked list – head = [4,5,1,9], which looks like following:</p><p><img src="https://assets.leetcode.com/uploads/2018/12/28/237_example.png" alt="img"></p><p><strong>Example 1:</strong></p><pre><code>Input: head = [4,5,1,9], node = 5Output: [4,1,9]Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</code></pre><h4 id="solution-值替换"><a href="#solution-值替换" class="headerlink" title="solution-值替换"></a>solution-值替换</h4><ul><li>因为尾节点不为空：所以可以不删除当前节点，而是删除后一个节点。把给定当前节点，想要找到要删除节点的前一个节点，只能从头遍历;</li><li>将后一个节点的值赋值给当前节点，并让当前节点指向下下个节点，从而删除下个节点</li><li>如果要删除尾节点元素，那么就不能这样做，必须给head，从头向后遍历。</li></ul><pre><code class="c++">class Solution &#123;public:    void deleteNode(ListNode* node) &#123;        /*        node-&gt;val = node-&gt;next-&gt;val;        ListNode* tmp = node-&gt;next;        node-&gt;next =  node-&gt;next-&gt;next;        delete(tmp);   //还是应该把这个指针释放掉，不然会内存泄漏，但不这样写也能通过    */        auto next = node-&gt;next;//直接操作指针        *node = *next;        delete next;       &#125;&#125;;</code></pre><h3 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21.Merge Two Sorted Lists"></a>21.Merge Two Sorted Lists</h3><p><strong>题目描述：</strong></p><p>Merge two sorted linked lists and return it as a new list. The new  list should be made by splicing together the nodes of the first two  lists.</p><p><strong>Example:</strong> </p><pre><code>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><h4 id="solution1-迭代-1"><a href="#solution1-迭代-1" class="headerlink" title="solution1-迭代"></a>solution1-迭代</h4><ul><li>面对list的问题，可以尝试一个dummyHead，避免对特殊情况的处理</li></ul><pre><code class="c++">class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        ListNode *pNewHead = NULL; //合并后新的头结点        ListNode *pTail = NULL;      //不断连接新节点的尾节点                ListNode *pl1 = l1, *pl2 = l2;                if(l1 == NULL)   //对于特殊情况：两个链表为空做判断，都为空时这句话就可以捕获到            return l2;        else if(l2 == NULL)            return l1;        else&#123;            if((l1-&gt;val) &lt; (l2-&gt;val))&#123;                pNewHead = l1;                l1 = l1-&gt;next;            &#125;else&#123;                pNewHead = l2;                l2 = l2-&gt;next;            &#125;            &#125;                pTail = pNewHead;        while(l1 != NULL &amp;&amp; l2 !=NULL)&#123;            if((l1-&gt;val) &lt; (l2-&gt;val))&#123;                pTail-&gt;next = l1;                pTail = pTail-&gt;next;                l1 = l1-&gt;next;            &#125;else&#123;                pTail-&gt;next = l2;                pTail = pTail-&gt;next;                l2 = l2-&gt;next;            &#125;                 &#125;                //对于两个链表不一样长的情况做处理 ，因为是直接在链表本身上做连接，不是新创建一条链表，所以这里剩下的节点只需要一个指针指向即可，不需要遍历连接。        if(l1 != NULL)&#123;            pTail-&gt;next = l1;        &#125;        if(l2 != NULL)&#123;            pTail-&gt;next = l2;        &#125;                    return pNewHead;     &#125;    &#125;;</code></pre><h4 id="solution2-递归"><a href="#solution2-递归" class="headerlink" title="solution2-递归"></a>solution2-递归</h4><p>因为在递归调用的过程当中，系统为每一层的返回点、局部量等开辟了栈来存储，因此递归次数过多容易造成栈溢出。所以选择递归时要慎重。思路看代码吧~</p><pre><code class="c++">class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        if(l1 == NULL)            return l2;        if(l2 == NULL)            return l1;                if((l1-&gt;val) &lt; (l2-&gt;val))&#123;            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);            return l1; //就是cur节点，一直指向当前链表的尾节点        &#125;else&#123;            l2-&gt;next = mergeTwoLists(l1,l2-&gt;next);            return l2;        &#125;                        &#125;&#125;;</code></pre><h3 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83.Remove Duplicates from Sorted List"></a>83.Remove Duplicates from Sorted List</h3><p><strong>题目描述：</strong></p><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p><p><strong>Example 1:</strong></p><pre><code>Input: 1-&gt;1-&gt;2Output: 1-&gt;2</code></pre><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><ul><li>看清楚题目，不要求把重复的所有元素都删除</li><li>cur表示当前节点，依次和下一个节点比较，如果值一样，则与下一个节点比较，并每次删除一个值一样的节点</li><li>时间：O(n)，必须从头遍历到尾，空间：O(1)</li></ul><pre><code class="c++">class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if(head == NULL)            return NULL;        ListNode* cur = head;       // ListNode* tmp = NULL;        while(cur)&#123;            while(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)&#123;               // tmp = cur-&gt;next;                cur-&gt;next = cur-&gt;next-&gt;next;                //delete(tmp);            &#125;            cur = cur-&gt;next;        &#125;        return head;    &#125;&#125;;</code></pre><h3 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141.Linked List Cycle"></a>141.Linked List Cycle</h3><p><strong>题目描述</strong></p><p>Given a linked list, determine if it has a cycle in it.</p><p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p><p><strong>Example 1:</strong></p><pre><code>Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where tail connects to the second node.</code></pre><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><h4 id="solution1—快慢指针"><a href="#solution1—快慢指针" class="headerlink" title="solution1—快慢指针"></a>solution1—快慢指针</h4><ul><li>第一种解法就是快慢指针，而且只需要O(1)空间，O(n)时间，但是奇怪的是，我因为指针指向原因，错了三次？</li></ul><pre><code class="c++">class Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        if(head == NULL || head-&gt;next == NULL)            return false;                ListNode* slow = head, *fast = head-&gt;next;        while(fast != slow)&#123;            if(fast == NULL || fast-&gt;next == NULL)&#123;                return false;            &#125;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;        &#125;        return true;    &#125;</code></pre><h4 id="solution2-辅助集合"><a href="#solution2-辅助集合" class="headerlink" title="solution2-辅助集合"></a>solution2-辅助集合</h4><ul><li>检查某个节点是否被第二次访问，使用hash表，查看当前元素在hash表中是否存在，则需要find函数(set)</li><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="c++">class Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        if(head == NULL || head-&gt;next == NULL)            return false;                ListNode* tmp = head;        set&lt;ListNode*&gt;mySet;        mySet.insert(tmp);        tmp = tmp-&gt;next;                while(tmp != NULL)&#123;            if(mySet.find(tmp) == mySet.end())&#123;                mySet.insert(tmp);                tmp = tmp-&gt;next;            &#125;else                return true;        &#125;        return false;    &#125;&#125;;</code></pre><h3 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234.Palindrome Linked List"></a>234.Palindrome Linked List</h3><p><strong>题目描述</strong></p><p>Given a singly linked list, determine if it is a palindrome.</p><p>回文是指：正向和反向读取得到的是一样的</p><p><strong>Example 1:</strong></p><pre><code>Input: 1-&gt;2Output: false</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: 1-&gt;2-&gt;2-&gt;1Output: true</code></pre><h4 id="solution1-辅助栈"><a href="#solution1-辅助栈" class="headerlink" title="solution1-辅助栈"></a>solution1-辅助栈</h4><ul><li>遍历链表，使用栈存储，再次遍历链表，和出栈的元素比较</li><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="c++">class Solution &#123;public:    bool isPalindrome(ListNode* head) &#123;        if(head == NULL || head-&gt;next == NULL)            return true;                stack&lt;int&gt;node;        ListNode* tmp = head;        while(tmp != NULL)&#123;            node.push(tmp-&gt;val);            tmp = tmp-&gt;next;        &#125;        tmp = head;        while(tmp != NULL)&#123;            int v = node.top();            if(tmp-&gt;val != v)                return false;            node.pop();            tmp = tmp-&gt;next;        &#125;                    return true;    &#125;</code></pre><h4 id="solution2-递归-1"><a href="#solution2-递归-1" class="headerlink" title="solution2-递归"></a>solution2-递归</h4><ul><li>边界条件：cur == NULL，返回true</li><li>用一个指针指在链表头；递归不断执行，到了链表结尾，然后出栈，不断返回，表头指针不断往前走，也是一个后面和前面比较的过程。但是我在想，怎么能让它比较到中间的时候就停止呢？</li><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="c++">class Solution &#123;public:    ListNode* temp ;        bool isPalindrome(ListNode* head) &#123;        if(head == NULL || head-&gt;next == NULL)            return true;        temp = head;        return check(head);    &#125;    bool check(ListNode* p)&#123;        if(p == NULL)            return true;        bool isPal = check(p-&gt;next) &amp; (p-&gt;val == temp-&gt;val);        temp = temp-&gt;next;                return isPal;     &#125;&#125;;</code></pre><h3 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="203.Remove Linked List Elements"></a>203.Remove Linked List Elements</h3><p><strong>题目描述</strong></p><p>Remove all elements from a linked list of integers that have value <strong>val</strong>.</p><p><strong>Example:</strong></p><pre><code>Input:  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6Output: 1-&gt;2-&gt;3-&gt;4-&gt;5</code></pre><h4 id="solution-遍历"><a href="#solution-遍历" class="headerlink" title="solution-遍历"></a>solution-遍历</h4><ul><li>删除具有相同值的元素。因为要删除，所以需要记录当前元素的上一个，才能把指针连接到下一个<br>为了处理头结点，引入dummyHead。或者直接，用cur-&gt;next和值做比较</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        if(head == NULL)            return NULL ;        ListNode* dummyHead = new ListNode(0);        dummyHead-&gt;next = head;        ListNode* pre = dummyHead, *cur = head;                while(cur != NULL)&#123;            if(cur-&gt;val == val)&#123;                pre-&gt;next = cur-&gt;next;                cur = pre-&gt;next;            &#125;else&#123;                pre = cur;                cur = cur-&gt;next;                            &#125;                 &#125;        return dummyHead-&gt;next;                    &#125;&#125;;</code></pre><h3 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160.Intersection of Two Linked Lists"></a>160.Intersection of Two Linked Lists</h3><p><strong>题目描述</strong></p><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" alt="img"></p><p>begin to intersect at node c1.</p><h4 id="solution1-求长度"><a href="#solution1-求长度" class="headerlink" title="solution1-求长度"></a>solution1-求长度</h4><ul><li>求出两个链表的长度，因为两个链表可能不一样长，则让长的那个先走几步，然后两个一起走，去比较是否有一致的节点</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="c++">class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        if(headA == NULL || headB == NULL)            return NULL;        //查询链表长度        ListNode* p1 = headA, *p2 = headB;        int lenA = 0, lenB = 0;        while(p1 != NULL)&#123;            lenA++;            p1 = p1-&gt;next;        &#125;        while(p2 != NULL)&#123;            lenB++;            p2 = p2-&gt;next;        &#125;        //将长的那个链表定位到与短链表一样长的地方        p1 = headA, p2 = headB;        int step = (lenA&gt;lenB)?(lenA-lenB):(lenB-lenA);        if(lenA &gt;= lenB)&#123;            while(step)&#123;                p1 = p1-&gt;next;                step--;            &#125;        &#125;else&#123;            while(step)&#123;                p2 = p2-&gt;next;                step--;            &#125;        &#125;        //开始同时遍历并比较两个链表的节点        while(p1 != NULL &amp;&amp; p2 != NULL)&#123;            if(p1 != p2)&#123;//判断的是节点是否相同，不是节点的值                p1 = p1-&gt;next;                p2 = p2-&gt;next;            &#125;            else                return p1;          &#125;        return NULL;            &#125;&#125;;</code></pre><h4 id="solution2—辅助栈"><a href="#solution2—辅助栈" class="headerlink" title="solution2—辅助栈"></a>solution2—辅助栈</h4><ul><li>如果有交集，那么倒着遍历时第一个不一样的节点就是分岔处。</li><li>顺序遍历，将元素分别存储在辅助的栈中。依次从栈中弹出元素比较</li><li>时间：O(n)，空间：O(n)</li><li>没写。。。</li></ul><h4 id="solution3-链表粘合"><a href="#solution3-链表粘合" class="headerlink" title="solution3-链表粘合"></a>solution3-链表粘合</h4><pre><code class="c++">class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        if(headA == NULL || headB == NULL)            return NULL;        ListNode *p1 = headA, *p2 = headB;        //只有拼接后的两条链都遍历完，才结束        while(p1 != NULL &amp;&amp; p2 != NULL &amp;&amp; p1 != p2)&#123;            p1 = p1-&gt;next;            p2 = p2-&gt;next;            if(p1 == p2)                return p1;            if(p1 == NULL)  p1 = headB;            if(p2 == NULL)  p2 = headA;        &#125;        return p1;//p1 == p2 的情况是两条链的公共节点是第一个的时候，不会执行while里面的语句，否则，在有前缀节点的情况下，一定是在循环内找到交点。如果没有交点，则p1是返回NULL    &#125;&#125;;</code></pre><h3 id="707-Design-Linked-List"><a href="#707-Design-Linked-List" class="headerlink" title="707. Design Linked List"></a>707. Design Linked List</h3><p><strong>题目描述：</strong></p><p>Design your implementation of the linked list. You can choose to use  the singly linked list or the doubly linked list. A node in a  singly linked list should have two attributes: <code>val</code> and <code>next</code>. <code>val</code> is the value of the current node, and <code>next</code> is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute <code>prev</code> to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p><p>Implement these functions in your linked list class:</p><ul><li>get(index) : Get the value of the <code>index</code>-th node in the linked list. If the index is invalid, return <code>-1</code>.</li><li>addAtHead(val) : Add a node of value <code>val</code> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li><li>addAtTail(val) : Append a node of value <code>val</code> to the last element of the linked list.</li><li>addAtIndex(index, val) : Add a node of value <code>val</code> before the <code>index</code>-th node in the linked list. If <code>index</code> equals to  the length of linked list, the node will be appended to the end of  linked list. If index is greater than the length, the node will not be  inserted. If index is negative, the node will be inserted at the head of  the list.</li><li>deleteAtIndex(index) : Delete the <code>index</code>-th node in the linked list, if the index is valid.</li></ul><p><strong>Example</strong>:</p><p><strong>Note:</strong></p><ul><li>All values will be in the range of <code>[1, 1000]</code>.</li><li>The number of operations will be in the range of <code>[1, 1000]</code>.</li><li>Please do not use the built-in LinkedList library.</li></ul><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>这道题对我来说最大的挑战不是思路，是C++语法的问题。<br>首先是不知道在类里面怎么去声明一个节点的类型，一个是不知道构造函数怎么用了，汗。。。<br>别人的思路的一个亮点：因为题目中要求了使用了头、尾，还有index的合法与不合法，所以设置三个全局变量head,tail,len, 在更新节点数量的时候要记着把len值做改变。</p><pre><code class="c++">class MyLinkedList &#123;private:    struct ListNode&#123;        int val;        ListNode* next;        ListNode(int v):val(v),next(NULL)&#123;&#125;    &#125;;    ListNode* head;    ListNode* tail;    int len ;    public:    /** Initialize your data structure here. */    MyLinkedList() &#123;        head = NULL;        tail = NULL;        len = 0;    &#125;        /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */    int get(int index) &#123;        if(index &gt;= len || index &lt; 0)            return -1;        ListNode* p  = head;            for(int i = 0;i &lt; index; i++)&#123;            p = p-&gt;next;        &#125;        return p-&gt;val;           &#125;    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */    void addAtHead(int val) &#123;        ListNode* newHead = new ListNode(val);        newHead-&gt;next = head;        head = newHead;        if(len == 0)            tail = newHead;        ++len;    &#125;        /** Append a node of value val to the last element of the linked list. */    void addAtTail(int val) &#123;        ListNode* newTail = new ListNode(val);        if(len == 0)&#123;            head = newTail;            tail = newTail;        &#125;                    tail-&gt;next = newTail;        tail = newTail;        newTail-&gt;next = NULL;        ++len;    &#125;        /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */    void addAtIndex(int index, int val) &#123;        if(index == len)            addAtTail(val);        else if(index &gt; len)            return ;        else if(index &lt;= 0)            addAtHead(val);        else&#123;            ListNode* p = head;            ListNode* newNode = new ListNode(val);            //找到要插入index的前一个节点，这样直接操作前一个节点的指向即可，所以是index-1，删除同理            for(int i = 0; i &lt; index-1;i++)&#123;                p = p-&gt;next;            &#125;            newNode-&gt;next = p-&gt;next;            p-&gt;next = newNode;            ++len;        &#125;                        &#125;        /** Delete the index-th node in the linked list, if the index is valid. */    void deleteAtIndex(int index) &#123;        if(index &lt; 0 || index &gt;= len)            return ;                ListNode* tmp = NULL;//用来做delete操作，在OJ中，我发现不用delete也可以，但是为了养成好习惯，建议始终把不要的节点delete掉，以免内存泄漏                //如果删除头节点,删除完就可以return了        if(index == 0)&#123;            tmp = head;            head = head-&gt;next;            delete tmp;            --len;            return;        &#125;        ListNode* p = head;        for(int i = 0; i &lt; index-1; i++)&#123;            p = p-&gt;next;        &#125;        //删除尾节点        if(index == len-1)            tail = p;                tmp = p-&gt;next;        p-&gt;next = p-&gt;next-&gt;next;        delete tmp;                --len;    &#125;&#125;;/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linkedList </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack-problems-easy</title>
      <link href="/2019/08/23/stack-problems-easy/"/>
      <url>/2019/08/23/stack-problems-easy/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h3 id="1021-Remove-Outermost-Parentheses"><a href="#1021-Remove-Outermost-Parentheses" class="headerlink" title="1021.Remove Outermost Parentheses"></a>1021.Remove Outermost Parentheses</h3><p>题目描述太复杂的情况下看看给的case就大概知道题意了</p><p><strong>Example 2:</strong></p><pre><code>Input: &quot;(()())(())(()(()))&quot;Output: &quot;()()()()(())&quot;Explanation: The input string is &quot;(()())(())(()(()))&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;.After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;.</code></pre><h4 id="solution1-记录左括号个数，分割primitive串"><a href="#solution1-记录左括号个数，分割primitive串" class="headerlink" title="solution1-记录左括号个数，分割primitive串"></a>solution1-记录左括号个数，分割primitive串</h4><ul><li>因为是一道和栈相关的题目，所以第一反应就是使用栈，比如”(()())(())”，设定一个全局遍历s0(“()”)；遇到”(“进栈，遇到”)”时，栈顶的匹配”(“出栈；如果此时栈为空，那么说明最后出栈的那对是外层括号，不计入最终的结果，直接开始遍历下一个元素。否则，res+=s0; 这种方法很闹心的一个地方是，对于”(()(()))”没法做。</li><li>另一种解法就是现在的解法，抛开stack，用string的知识来做。为的是找到最外层的括号，那么就从左向右遍历字符串，并用cnt记录当前左括号的个数，如果有匹配的右括号，则cnt–，有左括号时cnt++，当cnt==0时，即表示当前的右括号是外层括号，那么就把这个外层括号剥去，中间的加入res，那么此时有了待加入字符串的结束为止，还需要一个起始位置，则用start来表示，相当于字符串的截取。每次有了新的子串，start则初始化为新的起始位置。</li><li>时间O(n)，空间：O(n)——存储结果</li></ul><pre><code class="C++">class Solution &#123;public:    string removeOuterParentheses(string S) &#123;        int len = S.size();        string res = &quot;&quot;;             int cnt = 1;//记录左括号的个数，当有右括号与左括号匹配时，减一        int start = 0;//整个串被分为多个primative的串，记录每次新primative串的开始位置              for(int i = 1; i &lt; len;i++)&#123;            if(S[i] == &#39;(&#39;)&#123;                cnt++;            &#125;else&#123;                cnt--;            &#125;                         if(cnt == 0)&#123;                if(i - start &gt;1)&#123;                    string tmp(S.begin()+start+1,S.begin()+i);                    res += tmp;                &#125;                start = i+1;            &#125;        &#125;        return res;          &#125;&#125;;</code></pre><h4 id="solution2"><a href="#solution2" class="headerlink" title="solution2-"></a>solution2-</h4><ul><li>别人的解法，和上面的思路差不多，但是只用open去记录当前的字符是否是结果的一部分。<br>（我的比这个看起来复杂，主要是被题目给的example引导着做复杂了。即先找出整个大括号包含的字符串，再去除外面的那层，看这个解法，完全可以边走边判断）</li><li>open的数值意义：当前没有匹配的左括号的个数，左括号时加，右括号时减</li><li>如果open&gt;0 &amp;&amp; c == ‘(‘，那么加入res，open++</li><li>如果c == ‘)’ &amp;&amp; open &gt;1，那么加入res，open–；大于1的目的是把最外层的去掉</li><li>时间：O(n)，空间：O(n)——存储结果</li></ul><pre><code class="c++">class Solution &#123;public:    string removeOuterParentheses(string S) &#123;        int open = 0;        string res = &quot;&quot;;        for(char c:S)&#123;            if(c == &#39;(&#39; &amp;&amp; open++ &gt; 0) res += c; //最外面的左括号跳过            if(c == &#39;)&#39; &amp;&amp; open-- &gt; 1 ) res += c;                   &#125;        return res;    &#125;&#125;;</code></pre><h3 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047.Remove All Adjacent Duplicates In String"></a>1047.Remove All Adjacent Duplicates In String</h3><p><strong>题目描述</strong></p><p>Given a string <code>S</code> of lowercase letters, a <em>duplicate removal</em> consists of choosing two adjacent and equal letters, and removing them.</p><p>We repeatedly make duplicate removals on S until we no longer can.</p><p>Return the final string after all such duplicate removals have been made.  It is guaranteed the answer is unique.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;abbaca&quot;Output: &quot;ca&quot;Explanation: For example, in &quot;abbaca&quot; we could remove &quot;bb&quot; since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is &quot;aaca&quot;, of which only &quot;aa&quot; is possible, so the final string is &quot;ca&quot;.</code></pre><h4 id="solution1-反向遍历，栈"><a href="#solution1-反向遍历，栈" class="headerlink" title="solution1-反向遍历，栈"></a>solution1-反向遍历，栈</h4><ul><li>每次将压入的元素和栈顶元素比较，如果一致就是重复，则新元素不入栈，栈顶元素出栈，这样可以很好的把中间有其他相同元素隔开的多个相同元素找出来。</li><li>反向遍历只是为了正向输出结果</li><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="c++">class Solution &#123;public:    string removeDuplicates(string S) &#123;        stack&lt;char&gt;s;        int len = S.size();        string res = &quot;&quot;;                for(int i = len-1; i &gt;= 0 ; i--)&#123;            if(!s.empty())&#123;                if(s.top() == S[i])&#123;                    s.pop();                &#125;else&#123;                    s.push(S[i]);                &#125;            &#125;else&#123;                s.push(S[i]);            &#125;             &#125;        while(!s.empty())&#123;            res += s.top();            s.pop();        &#125;           return res;       &#125;</code></pre><h4 id="solution2-用string变相作为栈"><a href="#solution2-用string变相作为栈" class="headerlink" title="solution2-用string变相作为栈"></a>solution2-用string变相作为栈</h4><ul><li>这种写法，应该对string中的方法有充足的了解</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    string removeDuplicates(string S) &#123;        string res = &quot;&quot;;        for(char c : S)&#123;            if(res.size() &amp;&amp; res.back() == c)                 res.pop_back();//凡是涉及到删除元素的操作，都要首先判断是否有元素            else                res.push_back(c);           &#125;        return res;    &#125;&#125;;</code></pre><h3 id="682-Baseball-Game"><a href="#682-Baseball-Game" class="headerlink" title="682.Baseball Game"></a>682.Baseball Game</h3><ul><li>“C”表示无效前一轮分数，“D”表示将前一轮有效分数乘2作为本轮分数，“+”表示将前两轮的分数之和作为本轮分数。</li></ul><p><strong>Example 1:</strong></p><pre><code>Input: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]Output: 30Explanation: Round 1: You could get 5 points. The sum is: 5.Round 2: You could get 2 points. The sum is: 7.Operation 1: The round 2&#39;s data was invalid. The sum is: 5.  Round 3: You could get 10 points (the round 2&#39;s data has been removed). The sum is: 15.Round 4: You could get 5 + 10 = 15 points. The sum is: 30.</code></pre><h4 id="solution-辅助栈，字符串处理"><a href="#solution-辅助栈，字符串处理" class="headerlink" title="solution-辅助栈，字符串处理"></a>solution-辅助栈，字符串处理</h4><ul><li>完全按照人脑思维，对每个字符可能的情况进行判断</li><li>需要注意的就是，输入是一个字符串的数组，即数组中每个元素为字符串，当score为整数，且位数多于两位，则需要一个个遍历，算出字符串对应的整数。手动的算了。这里要注意有负数的情况。</li><li>时间：O(n)，空间：O(2)——一个辅助栈</li></ul><pre><code class="C++">class Solution &#123;public:    int calPoints(vector&lt;string&gt;&amp; ops) &#123;        stack&lt;int&gt;score;                for(string s : ops)&#123;            char c = s[0];                        if(c == &#39;C&#39;)&#123;                score.pop();            &#125;else if(c == &#39;D&#39;)&#123;                int tmp = score.top();                score.push(tmp*2);            &#125;else if(c == &#39;+&#39;)&#123;                int tmp1 = score.top();                score.pop();                int cur = tmp1 + score.top();                score.push(tmp1);                score.push(cur);            &#125;else&#123;                int num = 0;                bool flag = false;//是否为负数                for(char c : s)&#123;                    if(c == &#39;-&#39;)&#123;                        flag = true;                        continue;                    &#125;                    int val = c - &#39;0&#39;;                    num = num*10 + val;                &#125;                if(flag)                    score.push(-num);                else                     score.push(num);            &#125;         &#125;        int sum = 0;        while(!score.empty())&#123;            sum += score.top();            score.pop();        &#125;        return sum;    &#125;</code></pre><h4 id="solution2-vector"><a href="#solution2-vector" class="headerlink" title="solution2-vector"></a>solution2-vector</h4><ul><li>我简直就是一个被残害的少年，为什么想不开总是用stack，既不能随机访问，还得控制顺序</li><li>语法：STL 算法求和<ul><li>int sum = accumulate(score.begin(),score.end(),10);//以10为基础开始加</li><li>string sum = accumulate(v.begin() , v.end() , string(“ “));将字符串连接起来</li></ul></li><li>找到了一个C++11里面字符串转整数的操作stoi(s,0,10)——将s从第0位开始，转换成10进制数。</li><li>判断是否为数字：isdigit()</li></ul><pre><code class="C++">class Solution &#123;public:    int calPoints(vector&lt;string&gt;&amp; ops) &#123;        vector&lt;int&gt;score;        int index = 0;        for(string s : ops)&#123;            if(isdigit(s[0]) || s[0] == &#39;-&#39;)&#123;               score.push_back(stoi(s));                            &#125;else if(s == &quot;+&quot;)&#123;                score.push_back(score[index]+score[index-1]);            &#125;else if(s == &quot;D&quot;)&#123;                score.push_back(score[index]*2);            &#125;else&#123;                score.pop_back();            &#125;        index = score.size()-1;        &#125;        return accumulate(score.begin(),score.end(),0);            &#125;&#125;;</code></pre><h3 id="844-Backspace-String-Compare"><a href="#844-Backspace-String-Compare" class="headerlink" title="844.Backspace String Compare"></a>844.Backspace String Compare</h3><p><strong>题目描述</strong></p><p>Given two strings <code>S</code> and <code>T</code>, return if they are equal when both are typed into empty text editors. <code>#</code> means a backspace character.</p><p><strong>Example :</strong></p><pre><code>Input: S = &quot;ab##&quot;, T = &quot;c#d#&quot;Output: trueExplanation: Both S and T become &quot;&quot;.Input: S = &quot;a#c&quot;, T = &quot;b&quot;Output: falseExplanation: S becomes &quot;c&quot; while T becomes &quot;b&quot;.</code></pre><h4 id="solution1-辅助栈"><a href="#solution1-辅助栈" class="headerlink" title="solution1-辅助栈"></a>solution1-辅助栈</h4><ul><li>想先比较一下两个字符串的大小，但是不行，因为如果一个比另一个多个#，也返回true；比如”ab##””c#d##”;</li><li>最朴素的做法就是用两个辅助栈,当遇到’#’且栈不为空时就pop，否则入栈，然后从栈中依次弹出元素，比较是否相等，最后还要判断栈内有没有剩余元素 。</li><li>时间O(n)，空间O(n)</li></ul><pre><code class="C++">class Solution &#123;public:    bool backspaceCompare(string S, string T) &#123;        stack&lt;char&gt; s;        stack&lt;char&gt; t;                for(int i = 0; i &lt; S.size(); i++)&#123;            if(S[i] == &#39;#&#39;)&#123;                if(!s.empty())&#123;                    s.pop();                &#125;            &#125;else                s.push(S[i]);                          &#125;                for(int j = 0; j&lt; T.size(); j++)&#123;            if(T[j] == &#39;#&#39;)&#123;                if(!t.empty())                    t.pop();            &#125;else                t.push(T[j]);                        &#125;        while(!s.empty() &amp;&amp; !t.empty())&#123;            if(s.top() != t.top())                return false;            s.pop();            t.pop();        &#125;        if(!s.empty() || !t.empty())            return false;//一个栈内元素比另一个的多        return true;    &#125;</code></pre><h4 id="solution2-双指针"><a href="#solution2-双指针" class="headerlink" title="solution2-双指针"></a>solution2-双指针</h4><ul><li>从后向前遍历，用count记录出现过的‘#’</li><li>如果count &gt; 0 &amp;&amp; 当前是一个非‘#’，说明可以对这个进行删除，count–；</li><li>如果当前是 ‘#’，则count++</li><li>否则比较两个元素，如果不相等，则false</li><li>测试用例需要考虑‘#’对的位置，最开头，中间，结尾，两个字符串长度不一样。能想出这种做法，并且把边界条件控制的很好的人，也是绝了。</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">/*class Solution &#123;public:    bool backspaceCompare(string S, string T) &#123;        stack&lt;char&gt; s;        stack&lt;char&gt; t;        int lens = S.size();        int lent = T.size();        for(int i = 0; i &lt; lens; i++)&#123;            if(S[i] == &#39;#&#39;)&#123;                if(!s.empty())&#123;                    s.pop();                &#125;            &#125;else                s.push(S[i]);                          &#125;                for(int j = 0; j&lt; lent; j++)&#123;            if(T[j] == &#39;#&#39;)&#123;                if(!t.empty())                    t.pop();            &#125;else                t.push(T[j]);                        &#125;        while(!s.empty() &amp;&amp; !t.empty())&#123;            if(s.top() != t.top())                return false;            s.pop();            t.pop();        &#125;        if(!s.empty() || !t.empty())            return false;//一个栈内元素比另一个的多        return true;    &#125;&#125;;*/class Solution &#123;public:    bool backspaceCompare(string S, string T) &#123;        int i = S.size()-1;        int j = T.size()-1;        int countS = 0,countT = 0;                //存在两个字符串不一样长的情况        while(i &gt;= 0 || j &gt;= 0)&#123;            while(i &gt;= 0 &amp;&amp; (S[i] == &#39;#&#39; || countS &gt; 0))&#123;                if(S[i] == &#39;#&#39;)&#123;                    countS++;                &#125;else&#123;                    countS--;                &#125;                i--;            &#125;            while(j &gt;=0 &amp;&amp; (T[j] == &#39;#&#39; || countT &gt; 0))&#123;                if(T[j] == &#39;#&#39;)&#123;                    countT++;                &#125;else&#123;                    countT--;                &#125;                j--;            &#125;                        if(i &lt; 0 || j &lt; 0)                return i == j;                            if(S[i] != T[j])                return false;            else&#123;                 i--;                 j--;            &#125;                   &#125;               return i == j;    &#125;&#125;;</code></pre><h3 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232.Implement Queue using Stacks"></a>232.Implement Queue using Stacks</h3><pre><code class="C++">class MyQueue &#123;public:    stack&lt;int&gt;s1;    stack&lt;int&gt;s2;            /** Initialize your data structure here. */    MyQueue() &#123;&#125;        /** Push element x to the back of queue. */    void push(int x) &#123;        s1.push(x);    &#125;        /** Removes the element from in front of queue and returns that element. */    int pop() &#123;        while(!s1.empty())&#123;            s2.push(s1.top());            s1.pop();         &#125;        int res = s2.top();        s2.pop();        while(!s2.empty())&#123;            s1.push(s2.top());            s2.pop();        &#125;          return res;       &#125;        /** Get the front element. */    int peek() &#123;        while(!s1.empty())&#123;            s2.push(s1.top());            s1.pop();         &#125;        int res = s2.top();        while(!s2.empty())&#123;            s1.push(s2.top());            s2.pop();        &#125;          return res;       &#125;        /** Returns whether the queue is empty. */    bool empty() &#123;        if(s1.empty())            return true;        else            return false;    &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */</code></pre><h3 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225.Implement Stack using Queues"></a>225.Implement Stack using Queues</h3><pre><code class="C++">class MyStack &#123;public:    queue&lt;int&gt;q;    /** Initialize your data structure here. */    MyStack() &#123;&#125;        /** Push element x onto stack. */    void push(int x) &#123;        q.push(x);    &#125;        /** Removes the element on top of the stack and returns that element. */    int pop() &#123;        int res = q.back();        int len = q.size();        queue&lt;int&gt;tmp;        while(len &gt; 1)&#123;            tmp.push(q.front());            q.pop();            len--;        &#125;        q.pop();        while(!tmp.empty())&#123;            q.push(tmp.front());            tmp.pop();        &#125;        return res;    &#125;        /** Get the top element. */    int top() &#123;        return q.back();    &#125;        /** Returns whether the stack is empty. */    bool empty() &#123;        return q.empty();    &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */</code></pre><h3 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155.Min Stack"></a>155.Min Stack</h3><pre><code class="c++">/*solution- 用一个全局变量来保存最小值，这样可以在常数时间内返回最小值- 在push(),pop()时，更新minElenm*/class MinStack &#123;public:    int minElem = 0x7fffffff;    stack&lt;int&gt; s;    /** initialize your data structure here. */    MinStack() &#123;    &#125;        void push(int x) &#123;        s.push(x);        if(x &lt; minElem)            minElem = x;    &#125;        void pop() &#123;        int x = s.top();        s.pop();        if(x == minElem)&#123;            minElem = 0x7fffffff;            stack&lt;int&gt; tmp;            while(!s.empty())&#123;                int t = s.top();                s.pop();                tmp.push(t);                                if(t &lt; minElem)&#123;                    minElem = t;                &#125;            &#125;            while(!tmp.empty())&#123;                s.push(tmp.top());                tmp.pop();            &#125;                    &#125;            &#125;        int top() &#123;        return s.top();    &#125;        int getMin() &#123;        return minElem;    &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */</code></pre><h3 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20.Valid Parentheses"></a>20.Valid Parentheses</h3><p><strong>题目描述</strong></p><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;([)]&quot;Output: false</code></pre><h4 id="错！solution1-cnt统计左括号个数"><a href="#错！solution1-cnt统计左括号个数" class="headerlink" title="错！solution1-cnt统计左括号个数"></a>错！solution1-cnt统计左括号个数</h4><ul><li>用cnt计数，分别表示三种括号的左括号个数，当有右括号时，cnt–，左括号时，cnt++。但是”({)”这种，无法正确判断。——只能用于只有一种括号的情况</li><li>时间：O(n)，空间：O(1)</li></ul><h4 id="solution2-辅助栈"><a href="#solution2-辅助栈" class="headerlink" title="solution2-辅助栈"></a>solution2-辅助栈</h4><ul><li>如果是左括号，进栈，如果是右括号，匹配栈顶是否为对应的左括号</li><li>时间：O(n)，空间：O(n)-辅助栈</li></ul><pre><code class="c++">class Solution &#123;public:    bool isValid(string s) &#123;        stack&lt;char&gt;ch;        for(int i = 0; i &lt; s.size(); i++)&#123;            if(s[i] == &#39;(&#39; || s[i] == &#39;&#123;&#39; || s[i] == &#39;[&#39;)                ch.push(s[i]);            else&#123;                if(ch.empty()) return false;//这个很重要，要弹出，首先就要判断栈是否为空                if(s[i] == &#39;)&#39; &amp;&amp; ch.top() != &#39;(&#39;)                    return false;                if(s[i] == &#39;&#125;&#39; &amp;&amp; ch.top() != &#39;&#123;&#39;)                    return false;                if(s[i] == &#39;]&#39; &amp;&amp; ch.top() != &#39;[&#39;)                    return false;                                ch.pop();            &#125;               &#125;        return ch.empty();             &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
