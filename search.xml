<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>gccVSg++</title>
      <link href="/2022/02/14/gccVSg/"/>
      <url>/2022/02/14/gccVSg/</url>
      
        <content type="html"><![CDATA[<p>gcc 和 g++ 的区别</p><ul><li><a href="https://blog.csdn.net/tjcwt2011/article/details/103410446">https://blog.csdn.net/tjcwt2011/article/details/103410446</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>regex</title>
      <link href="/2022/02/13/regex/"/>
      <url>/2022/02/13/regex/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>正则表达式是你所定义的模式模板 （pattern template），Linux工具可以用它来过滤文本。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>Linux中的不同应用程序可能会用不同类型的正则表达式。</p><p>正则表达式是通过正则表达式引擎 （regular expression engine）实现的。</p><p>正则表达式引擎是一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配。</p><p>在Linux中，有两种流行的正则表达式引擎：</p><ol><li>POSIX基础正则表达式（basic regular expression，BRE）引擎。 <ul><li>大多数Linux工具都至少符合POSIX BRE引擎规范，能够识别该规范定义的所有模式符号。</li><li>有些工具（比如sed编辑器）只符合了BRE引擎规范的子集。这是出于速度方面的考虑导致的，因为<strong>sed编辑器希望能尽可能快地处理数据流中的文本</strong>）。</li></ul></li><li>POSIX扩展正则表达式（extended regular expression，ERE）引擎。<ul><li>gawk程序用ERE引擎来处理它的正则表达式模式。</li></ul></li></ol><h1 id="BRE"><a href="#BRE" class="headerlink" title="BRE"></a>BRE</h1><h2 id="文本字符"><a href="#文本字符" class="headerlink" title="文本字符"></a>文本字符</h2><p>最基本的BRE模式是匹配数据流中的文本字符。</p><pre><code>$ echo &quot;This is a test&quot; | sed -n &#39;/test/p$ echo &quot;This is a test&quot; | gawk &#39;/test/&#123;print $0&#125;&#39;This is a test”</code></pre><ul><li>正则表达式并不关心模式在数据流中的位置。它也不关心模式出现了多少次。一旦正则表达式匹配了文本字符串中任意位置上的模式，它就会将该字符串传回Linux工具。</li><li>正则表达式模式都区分大小写。</li><li>可以在正则表达式中使用空格和数字。<ul><li>如果你在正则表达式中定义了空格，那么它必须出现在数据流中。甚至可以创建匹配多个连续空格的正则表达式模式。<code>$ sed -n &#39;/  /p&#39; data1</code></li></ul></li></ul><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p><code>.*[]^$&#123;&#125;\+?|()</code></p><p>如果要用某个特殊字符作为文本字符，就必须转义——用反斜线（\） 。</p><ul><li>要使用正斜线，也需要进行转义。</li></ul><h2 id="锚字符"><a href="#锚字符" class="headerlink" title="锚字符"></a>锚字符</h2><ol><li><p>脱字符（<code>^</code>）<strong>定义从数据流中文本行的行首开始的模式</strong>。如果模式出现在行首之外的位置，正则表达式模式则无法匹配。要用脱字符，就必须将它放在正则表达式中指定的模式前面。</p><pre><code>$ echo &quot;Books are great&quot; | sed -n &#39;/^Book/p&#39;Books are great</code></pre><ul><li>脱字符会在每个由换行符决定的新数据行的行首检查模式。只要模式出现在新行的行首，脱字符就能够发现它。</li><li>如果你将脱字符放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了。</li><li>如果指定正则表达式模式时只用了脱字符，就不需要用反斜线来转义。</li><li>但如果你在模式中先指定了脱字符，随后还有其他一些文本，那么你必须在脱字符前用转义字符。？</li></ul></li><li><p>特殊字符美元符（<code>$</code>）定义了<strong>行尾锚点</strong>。将这个特殊字符放在文本模式之后来指明数据行必须以该文本模式结尾。 <code>$ echo &quot;This is a good book&quot; | sed -n &#39;/book$/p</code></p></li><li><p>两种字符组合<br>在一些常见情况下，可以在同一行中将行首锚点和行尾锚点组合在一起使用。比如<strong>过滤出数据流中的空白行。</strong> <code>$ sed &#39;/^$/d&#39; data5</code></p></li></ol><h2 id="点号字符"><a href="#点号字符" class="headerlink" title="点号字符"></a>点号字符</h2><p>点号用来匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字符的位置没有字符，那么模式就不成立。<code>$ sed -n &#39;/.at/p&#39; data6</code></p><h2 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h2><p>使用方括号来定义一个字符组。方括号中包含所有你希望出现在该字符组中的字符。相对于点字符，能限定待匹配的字母。<br>如果字符组中的某个字符出现在了数据流中，那它就匹配了该模式。</p><ul><li>字符组中必须有个字符来匹配相应的位置。<code>$ echo &quot;Yes&quot; | sed -n &#39;/[Yy]es/p&#39;</code></li><li>字符组不必只含有字母，也可以在其中使用数字。 <code>$ sed -n &#39;/[0123]/p&#39; data7</code></li></ul><h3 id="排除型字符组"><a href="#排除型字符组" class="headerlink" title="排除型字符组"></a>排除型字符组</h3><p>在正则表达式模式中，也可以反转字符组的作用。可以寻找组中没有的字符，而不是去寻找组中含有的字符。要这么做的话，只要在字符组的开头加个脱字符。</p><pre><code>$ sed -n &#39;/[^ch]at/p&#39; data6This test is at line four.</code></pre><h2 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h2><p>可以用单破折线符号在字符组中表示字符区间。</p><ul><li>只需要指定区间的第一个字符、单破折线以及区间的最后一个字符就行了。</li><li>还可以在单个字符组指定多个不连续的区间。<pre><code>$ sed -n &#39;/^[0-9][0-9][0-9][0-9][0-9]$/p&#39; data8 // 数字$ sed -n &#39;/[c-h]at/p&#39; data6  // 字母$ sed -n &#39;/[a-ch-m]at/p&#39; data6</code></pre></li></ul><h2 id="特殊的字符组"><a href="#特殊的字符组" class="headerlink" title="特殊的字符组"></a>特殊的字符组</h2><p><img src="https://s2.loli.net/2022/02/14/xt6AMXLDSKrhinB.png" alt="BRE.png"></p><h2 id="星号"><a href="#星号" class="headerlink" title="星号"></a>星号</h2><p>在字符后面放置星号表明该字符必须在匹配模式的文本中出现<strong>0次或多次</strong>。</p><p>点号特殊字符和星号特殊字符组合起来。<strong>这个组合能够匹配任意数量的任意字符</strong>。它通常用在数据流中两个可能相邻或不相邻的文本字符串之间。</p><h1 id="扩展正则表达式-ERE"><a href="#扩展正则表达式-ERE" class="headerlink" title="扩展正则表达式 ERE"></a>扩展正则表达式 ERE</h1><p>POSIX ERE模式包括了一些可供Linux应用和工具使用的额外符号。<strong>gawk程序能够识别ERE模式，但sed编辑器不能。</strong></p><p>警告记住，sed编辑器和gawk程序的正则表达式引擎之间是有区别的。gawk程序可以使用大多数扩展正则表达式模式符号，并且能提供一些额外过滤功能，而这些功能都是sed编辑器所不具备的。但正因为如此，<strong>gawk程序在处理数据流时通常才比较慢</strong>。</p><h2 id="问号"><a href="#问号" class="headerlink" title="问号"></a>问号</h2><p>问号表明前面的字符<strong>可以出现0次或1次，但只限于此</strong>。它不会匹配多次出现的字符。</p><p>与星号一样，你可以将问号和字符组一起使用。<code>$ echo &quot;bt&quot; | gawk &#39;/b[ae]?t/&#123;print $0&#125;</code></p><h2 id="加号"><a href="#加号" class="headerlink" title="加号"></a>加号</h2><p>加号表明前面的字符<strong>可以出现1次或多次，但必须至少出现1次</strong>。如果该字符没有出现，那么模式就不会匹配。</p><h2 id="花括号"><a href="#花括号" class="headerlink" title="花括号"></a>花括号</h2><p>ERE中的花括号允许你<strong>为可重复的正则表达式指定一个上限</strong>。这通常称为<strong>间隔 （interval）</strong>。可以用两种格式来指定区间。</p><ul><li>m ：正则表达式准确出现m 次。</li><li>m, n ：正则表达式至少出现m 次，至多n 次。</li><li>默认情况下，gawk程序不会识别正则表达式间隔。必须指定gawk程序的–re-interval 命令行选项才能识别正则表达式间隔。</li></ul><pre><code>$ echo &quot;bet&quot; | gawk --re-interval &#39;/be&#123;1,2&#125;t/&#123;print $0&#125;&#39;bet$ echo &quot;bat&quot; | gawk --re-interval &#39;/b[ae]&#123;1,2&#125;t/&#123;print $0&#125;&#39;bat</code></pre><h2 id="管道符号"><a href="#管道符号" class="headerlink" title="管道符号"></a>管道符号</h2><p>管道符号允许你在检查数据流时，用逻辑OR 方式指定正则表达式引擎要用的两个或多个模式。如果任何一个模式匹配了数据流文本，文本就通过测试。如果没有模式匹配，则数据流文本匹配失败。</p><p><code>$ echo &quot;The cat is asleep&quot; | gawk &#39;/cat|dog/&#123;print $0&#125;</code></p><h2 id="表达式分组"><a href="#表达式分组" class="headerlink" title="表达式分组"></a>表达式分组</h2><p>正则表达式模式也可以用圆括号进行分组。当你将正则表达式模式分组时，该组会被视为一个标准字符。可以像对普通字符一样给该组使用特殊字符。</p><pre><code>$ echo &quot;Saturday&quot; | gawk &#39;/Sat(urday)?/&#123;print $0&#125;&#39;Saturday</code></pre><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><pre><code>#!/bin/bashgawk --re-interval &#39;/^\(?[2-9][0-9]&#123;2&#125;\)?(| |-|\.)[0-9]&#123;3&#125;( |-|\. )[0-9]&#123;4&#125;/&#123;print $0&#125;&#39;echo &quot;317-555-1234&quot; | ./isphone</code></pre><h1 id="引用-参考"><a href="#引用-参考" class="headerlink" title="引用/参考"></a>引用/参考</h1><p>摘录来自: [美] Richard Blum. “Linux命令行与shell脚本编程大全（第3版）。” Apple Books. </p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chore</title>
      <link href="/2022/02/08/chore/"/>
      <url>/2022/02/08/chore/</url>
      
        <content type="html"><![CDATA[<p> todo</p><ul><li><p> 开发时先写总逻辑，再加日志，监控之类的，以防太多日志代码搞混</p></li><li><p>公司各种服务说明文档都提供了http请求的例子，但是对http请求的构成不熟悉，不仅限制了对已有例子实操，也阻碍了在业务代码中使用和开发。</p><ul><li>get 和 post：<ul><li> <a href="https://www.zhihu.com/question/28586791">https://www.zhihu.com/question/28586791</a></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sed</title>
      <link href="/2022/01/10/sed/"/>
      <url>/2022/01/10/sed/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><p>shell脚本最常见的一个用途就是<strong>处理文本文件。检查日志文件、读取配置文件、处理数据元素</strong>，shell脚本可以帮助我们将文本文件中各种数据的日常处理任务自动化。但仅靠shell脚本命令来处理文本文件的内容有点勉为其难。</p><p>如果<u>想在shell脚本中处理任何类型的数据</u>，你得熟悉Linux中的sed和gawk工具。这两个工具能够极大简化需要进行的数据处理任务。</p><h1 id="sed-编辑器简介"><a href="#sed-编辑器简介" class="headerlink" title="sed 编辑器简介"></a>sed 编辑器简介</h1><ul><li><strong>sed编辑器</strong>被称作流编辑器 （stream editor），流编辑器会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。</li><li>在交互式文本编辑器中（比如vim），你可以用键盘命令来交互式地插入、删除或替换数据中的文本。</li></ul><p>sed编辑器可以<strong>根据命令来处理数据流中的数据</strong>，这些命令要么从命令行中输入，要么存储在一个命令文本文件中。在流编辑器<strong>将所有命令与一行数据匹配完毕后，它会读取下一行数据并重复这个过程。</strong>在流编辑器处理完流中的所有数据行后，它就会终止。</p><p>sed编辑器会执行下列操作：</p><ol><li>一次从输入中读取一行数据。</li><li>根据所提供的编辑器命令匹配数据。</li><li>按照命令修改流中的数据。</li><li>将新的数据输出到STDOUT 。</li></ol><h2 id="sed-命令"><a href="#sed-命令" class="headerlink" title="sed 命令"></a>sed 命令</h2><p>格式：<code>sed options script file</code></p><ul><li>options 选项允许你修改sed 命令的行为<ul><li><code>-e script</code>：在处理输入时，将script 中指定的命令添加到已有的命令中</li><li><code>-f file</code>：在处理输入时，将file 中指定的命令添加到已有的命令中</li><li><code>-n</code>：不产生命令输出，使用print 命令来完成输出</li><li><code>-i</code>：就地修改</li></ul></li><li>script 参数指定了应用于流数据上的单个命令。如果需要用多个命令，要么使用 <code>-e</code> 选项在命令行中指定，要么使用 <code>-f</code> 选项在单独的文件中指定。</li><li>file 参数表示要处理的数据文件？</li></ul><ol><li><p>在命令行定义编辑器命令：<code>$ echo &quot;This is a test&quot; | sed &#39;s/test/big test/&#39;</code></p><ul><li>默认情况下，sed编辑器会将指定的命令应用到STDIN 输入流上。这样你可以直接将数据通过管道输入sed编辑器处理。</li><li>sed编辑器并不会修改文本文件的数据。它只会将修改后的数据发送到STDOUT。</li></ul></li><li><p>在命令行使用多个编辑器命令：<code>$ sed -e &#39;s/brown/green/; s/dog/cat/&#39; data1.txt</code></p><ul><li>命令之间必须用分号隔开，并且在命令末尾和分号之间不能有空格。</li><li>也可以用bash shell中的次提示符来分隔命令。只要输入第一个<strong>单引号标示出sed程序脚本的起始</strong>（sed编辑器命令列表），bash会继续提示你输入更多命令，直到输入了标示结束的单引号。要在封尾单引号所在行结束命令。bash shell一旦发现了封尾的单引号，就会执行命令。<pre><code>$ sed -e &#39;&gt; s/brown/green/&gt; s/fox/elephant/&gt; s/dog/cat/&#39; data1.txt</code></pre></li></ul></li><li><p>从文件中读取编辑器命令：<code>$ sed -f script1.sed data1.txt</code></p></li></ol><h1 id="script"><a href="#script" class="headerlink" title="script"></a>script</h1><h2 id="s-（substitute）命令"><a href="#s-（substitute）命令" class="headerlink" title="s （substitute）命令"></a><code>s （substitute）命令</code></h2><p>用斜线间指定的第二个文本字符串来替换第一个文本字符串模式。</p><h3 id="替换标记"><a href="#替换标记" class="headerlink" title="替换标记"></a>替换标记</h3><ul><li>默认情况下它只替换每行中出现的第一处。要让替换命令能够替换一行中不同地方出现的文本必须使用替换标记 （substitution flag）。替换标记会在替换命令字符串之后设置。<code>s/pattern/replacement/flags</code></li><li>数字，表明新文本将替换第几处模式匹配的地方；</li><li>g ，表明新文本将会替换所有匹配的文本；</li><li>p ，表明匹配所在行的内容要打印出来；和 -n 搭配使用，只输出被替换命令修改过的行。</li><li>w file ，将替换的结果写到文件中。<code>sed &#39;s/test/trial/w test.txt&#39; data5.txt</code></li></ul><h3 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h3><ul><li>正斜线通常用作字符串分隔符，因而如果它出现在了模式文本中的话，必须用反斜线来转义。<code>$ sed &#39;s/\/bin\/bash/\/bin\/csh/&#39; /etc/passwd</code></li><li>要解决这个问题，sed编辑器允许选择其他字符来作为替换命令中的字符串分隔符：<code>$ sed &#39;s!/bin/bash!/bin/csh!&#39; /etc/passwd</code>。感叹号被用作字符串分隔符，这样路径名就更容易阅读和理解了。</li></ul><h2 id="使用地址"><a href="#使用地址" class="headerlink" title="使用地址"></a>使用地址</h2><p>默认情况下，在sed编辑器中使用的命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须用行寻址 （line addressing）。</p><h3 id="以数字形式表示行区间"><a href="#以数字形式表示行区间" class="headerlink" title="以数字形式表示行区间"></a>以数字形式表示行区间</h3><ol><li><p>在命令中指定的地址可以是单个行号：<code>$ sed &#39;2s/dog/cat/&#39; data1.txt</code></p></li><li><p>用起始行号、逗号以及结尾行号指定的一定区间范围内的行：<code>$ sed &#39;2,3s/dog/cat/&#39; data1.txt</code></p><ul><li>如果想将命令作用到文本中从某行开始的所有行，可以用特殊地址——<strong>美元符</strong>。</li></ul></li></ol><p><strong>在单行上执行多条命令，可以用花括号将多条命令组合在一起</strong>。sed编辑器会处理地址行处列出的每条命令。也可以置地址区间。</p><pre><code>$ sed &#39;2&#123;&gt; s/fox/elephant/&gt; s/dog/cat/&gt; &#125;&#39; data1.txt</code></pre><h4 id="用文本模式来过滤出行"><a href="#用文本模式来过滤出行" class="headerlink" title="用文本模式来过滤出行"></a>用文本模式来过滤出行</h4><p>sed编辑器允许指定文本模式来过滤出命令要作用的行。<code>/pattern/command</code>，例如 <code>$ sed &#39;/Samantha/s/bash/csh/&#39; /etc/passwd</code></p><h2 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h2><p>与替换命令使用方式类似，它会删除匹配指定寻址模式的所有行。使用该命令时要特别小心，如果你忘记加入寻址模式的话，流中的所有文本行都会被删除。</p><pre><code>$ sed &#39;d&#39; data1.txt  // 删除所有行$ sed &#39;3d&#39; data1.txt  // 删除指定的第二行$ sed &#39;2,3d&#39; data1.txt  // 删除区间 2-3 行$ sed &#39;/pattern/d&#39; data1.txt // 删除匹配pattern的所有行$ sed &#39;/pattern1/,/pattern2/d&#39; data1.txt // 删除指定行之间的所有行，包括指定行。你指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能。- 如果 pattern1 在 pattern2 之后再次出现，则删除功能会再次打开，删除后面的所有行。- 如果 pattern2 不存在，同理，也会删除 pattern1 后的所有行</code></pre><h2 id="插入和附加文本"><a href="#插入和附加文本" class="headerlink" title="插入和附加文本"></a>插入和附加文本</h2><ul><li><code>插入（insert ）命令（i ）</code>会在指定行前增加一个新行；</li><li><code>附加（append ）命令（a ）</code>会在指定行后增加一个新行。</li></ul><p>它们不能在单个命令行上使用，比如只插入一行时，可以在一条命令行上操作；但是当插入两行时，就得以两行的形式表示，且新行最后用反斜线。</p><pre><code>sed &#39;[address]command\new line\new line\new line&#39; </code></pre><p>你必须指定是要将行插入还是附加到另一行。可以匹配一个数字行号或文本模式，但不能用地址区间。这合乎逻辑，因为你只能将文本插入或附加到单个行的前面或后面，而不是行区间的前面或后面。<br>如果你有一个多行数据流，想要将新行附加到数据流的末尾，只要用代表数据最后一行的美元符就可以了：<code>$ sed &#39;$a\line&#39; data.txt</code></p><h2 id="修改行"><a href="#修改行" class="headerlink" title="修改行"></a>修改行</h2><p>与插入和附加文本类似</p><pre><code>$ sed &#39;3c\&gt; This is a changed line of text.&#39; data6.txt// 用 pattern$ sed &#39;/pattern/c\&gt; This is a changed line of text.&#39; data6.txt// 用区间寻址会替换这两行$ sed &#39;2,3c\&gt; This is a new line of text.&#39; data6.txt</code></pre><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p><code>[address]y/inchars/outchars/</code></p><ul><li>转换（transform ）命令（y ）对inchars 和outchars 值进行一对一的映射。inchars 中的第一个字符会被转换为outchars 中的第一个字符，第二个字符会被转换成outchars 中的第二个字符。这个映射过程会一直持续到处理完指定字符。如果inchars 和outchars 的长度不同，则sed编辑器会产生一条错误消息。</li><li>转换命令是一个全局命令，也就是说，它会文本行中找到的所有指定字符自动进行转换，而不会考虑它们出现的位置。同理，你无法限定只转换在特定地方出现的字符。<pre><code>$ echo &quot;This 1 is 2 is 3 hah&quot; | sed &#39;y/123/456/&#39;This 4 is 5 is 6 hah$</code></pre></li></ul><h2 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h2><h3 id="p-命令"><a href="#p-命令" class="headerlink" title="p 命令"></a>p 命令</h3><pre><code>$ echo &quot;this is a test&quot; | sed &#39;p‘ // 单纯打印文本$ sed -n &#39;/number 3/p&#39; data6.txt // 打印匹配到 number 3 的行，txt文本内容全部都会打印，但是匹配行会出现两次$ sed -n &#39;2,3p&#39; data6.txt // 区间行打印多次</code></pre><h3 id="命令：打印行号"><a href="#命令：打印行号" class="headerlink" title="= 命令：打印行号"></a>= 命令：打印行号</h3><pre><code>$ sed -n &#39;/number 4/&#123;&gt; =&gt; p&gt; &#125;&#39; data6.txt4This is line number 4.</code></pre><h3 id="列出（list-）命令（l-）"><a href="#列出（list-）命令（l-）" class="headerlink" title="列出（list ）命令（l ）"></a>列出（list ）命令（l ）</h3><p>打印数据流中的文本和不可打印的ASCII字符。“任何不可打印字符要么在其八进制值前加一个反斜线，要么使用标准C风格的命名法（用于常见的不可打印字符），比如\t ，来代表制表符。</p><pre><code>$ cat data9.txtThis    line    contains        tabs.$$ sed -n &#39;l&#39; data9.txtThis\tline\tcontains\ttabs.$$</code></pre><h2 id="使用sed处理文件"><a href="#使用sed处理文件" class="headerlink" title="使用sed处理文件"></a>使用sed处理文件</h2><h3 id="w-命令：向文件中写入行"><a href="#w-命令：向文件中写入行" class="headerlink" title="w 命令：向文件中写入行"></a>w 命令：向文件中写入行</h3><p><code>[address]w filename</code></p><ul><li>filename 可以使用相对路径或绝对路径，但不管是哪种，运行sed编辑器的用户都必须有文件的写权限。</li><li>地址可以是sed中支持的任意类型的寻址方式，例如单个行号、文本模式、行区间或文本模式。</li><li>src 是命令之外的file，dst 是 filename，即把 file 的内容写入 filename。命令里指定的行和位置针对的是 src 源文件。</li></ul><p>如果要根据一些公用的文本值从主文件中创建一份数据文件，比如下面的邮件列表中的，那么w 命令会非常好用。</p><pre><code>$ cat data11.txtBlum, R       BrowncoatMcGuiness, A  AllianceBresnahan, C  BrowncoatHarken, C     Alliance$$ sed -n &#39;/Browncoat/w Browncoats.txt&#39; data11.txt // sed编辑器会只将包含文本模式的数据行写入目标文件。$$ cat Browncoats.txtBlum, R       BrowncoatBresnahan, C  Browncoat$</code></pre><h3 id="r命令：从文件中读取行"><a href="#r命令：从文件中读取行" class="headerlink" title="r命令：从文件中读取行"></a>r命令：从文件中读取行</h3><p>读取（read ）命令（r ）允许你将一个独立文件中的数据插入到数据流中。</p><p>读取命令的格式如下：<code>[address]r filename</code></p><ul><li>filename 参数指定了数据文件的绝对路径或相对路径。你在<strong>读取命令中使用地址区间，只能指定单独一个行号或文本模式地址。</strong></li><li>sed编辑器会将文件中的所有文本行插入到指定地址后。</li><li>要在数据流的末尾添加文本，只需用美元符地址符就行了。</li><li>从filename中读取行，写入外面的 f。</li></ul><p>读命令和删除命令配合使用：利用另一个文件中的数据来替换文件中的占位文本。<br>举例来说，假定你有一份套用信件保存在文本文件中：</p><pre><code>$ cat notice.stdWould the following people:LISTplease report to the ship&#39;s captain.$</code></pre><p>套用信件将<strong>通用占位文本LIST 放在人物名单的位置</strong>。要在占位文本后插入名单，只需读取命令就行了。但这样的话，占位文本仍然会留在输出中。要删除占位文本的话，你可以用删除命令。结果如下：</p><pre><code>$ sed &#39;/LIST/&#123;&gt; r data11.txt&gt; d&gt; &#125;&#39; notice.stdWould the following people:Blum, R       BrowncoatMcGuiness, A  AllianceBresnahan, C  BrowncoatHarken, C     Allianceplease report to the ship&#39;s captain.$</code></pre><p>r 命令是：读别人，写入我；w 命令是：读我，写别人。</p><h2 id="参考-引用"><a href="#参考-引用" class="headerlink" title="参考/引用"></a>参考/引用</h2><p>摘录来自: [美] Richard Blum. “Linux命令行与shell脚本编程大全（第3版）。” Apple Books. </p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk</title>
      <link href="/2022/01/10/awk/"/>
      <url>/2022/01/10/awk/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="awk-编辑器简介"><a href="#awk-编辑器简介" class="headerlink" title="awk 编辑器简介"></a>awk 编辑器简介</h1><p><a href="https://blog.csdn.net/gechangli7/article/details/51547641">awk、gawk、nawk、mawk的简单介绍</a></p><p>gawk程序是Unix中的原始awk程序的GNU版本。gawk程序让流编辑迈上了一个新的台阶，<strong>它提供了一种编程语言而不只是编辑器命令</strong>。在gawk编程语言中，你可以做下面的事情：</p><ol><li>定义变量来保存数据；</li><li>使用算术和字符串操作符来处理数据；</li><li>使用结构化编程概念（比如if-then 语句和循环）来为数据处理增加处理逻辑；</li><li>通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告。”</li></ol><h1 id="awk-命令"><a href="#awk-命令" class="headerlink" title="awk 命令"></a>awk 命令</h1><p>gawk程序的基本格式如下：<code>gawk options program file</code></p><h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2><ul><li><code>-F fs</code>：指定行中划分数据字段的字段分隔符</li><li><code>-f file</code>：从指定的文件中读取程序</li><li><code>-v var=value</code>：定义gawk程序中的一个变量及其默认值</li><li><code>-mf N</code>：指定要处理的数据文件中的最大字段数</li><li><code>-mr N</code>：指定数据文件中的最大数据行数</li><li><code>-W keyword</code>：指定gawk的兼容模式或警告等级</li></ul><h2 id="program-file"><a href="#program-file" class="headerlink" title="program file"></a>program file</h2><ol><li>gawk程序脚本用一对花括号来定义。你必须将脚本命令放到两个花括号（{} ）中。</li><li>由于 <strong>gawk 命令行</strong>假定脚本是单个文本字符串，你还必须将脚本放到单引号中。</li></ol><pre><code>$ gawk &#39;&#123;print &quot;Hello World!&quot;&#125;&#39;This is a testHello World!helloHello World!This is another testHello World!# 要终止这个gawk程序，你必须表明数据流已经结束了。bash shell提供了一个组合键来生成EOF（End-of-File）字符。Ctrl+D组合键会在bash中产生一个EOF字符。这个组合键能够终止该gawk程序并返回到命令行界面提示符下。</code></pre><h2 id="使用数据字段变量"><a href="#使用数据字段变量" class="headerlink" title="使用数据字段变量"></a>使用数据字段变量</h2><p>gawk的主要特性之一是其处理文本文件中数据的能力。它会<strong>自动给一行中的每个数据元素（一列）分配一个变量</strong>。</p><p>默认情况下，gawk会将如下变量分配给它在文本行中发现的数据字段：<code>$0</code> 代表整个文本行；<code>$1</code> 代表文本行中的第1个数据字段；<code>$n</code> 代表文本行中的第 n 个数据字段</p><p>在文本行中，每个数据字段都是通过<strong>字段分隔符</strong>划分的。gawk在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。<strong>gawk中默认的字段分隔符是任意的空白字符（例如空格或制表符）</strong>。</p><h2 id="在程序脚本中使用多个命令"><a href="#在程序脚本中使用多个命令" class="headerlink" title="在程序脚本中使用多个命令"></a>在程序脚本中使用多个命令</h2><ol><li><p>在命令行上的程序脚本中使用多条命令，只要在命令之间放个分号即可。</p></li><li><p>也可以用次提示符一次一行地输入程序脚本命令。（不用分号）</p></li></ol><h2 id="从文件中读取程序"><a href="#从文件中读取程序" class="headerlink" title="从文件中读取程序"></a>从文件中读取程序</h2><pre><code>$ cat script3.gawk&#123;text = &quot;&#39;s home directory is &quot;print $1 text $6&#125;$$ gawk -F: -f script3.gawk /etc/passwd”# script3.gawk 程序脚本定义了一个变量来保存 print 命令中用到的文本字符串。注意，gawk程序在引用变量值时并未像shell脚本一样使用美元符。</code></pre><h2 id="在处理数据前-后运行脚本"><a href="#在处理数据前-后运行脚本" class="headerlink" title="在处理数据前/后运行脚本"></a>在处理数据前/后运行脚本</h2><p>gawk在读取数据前执行 BEGIN 关键字后指定的程序脚本。END 关键字允许你指定一个程序脚本，gawk会在读完数据后执行它。</p><p>如果在命令行里输入 BEGIN/END ，则需要将整个命令加单引号</p><pre><code>$ cat script4.gawkBEGIN &#123;print &quot;The latest list of users and shells&quot;print &quot; UserID \t Shell&quot;print &quot;-------- \t -------&quot;FS=&quot;:&quot;   # 特殊变量，是定义字段分隔符的另一种方法。这样就不用依靠脚本用户在命令行选项中定义字段分隔符了。&#125;&#123;print $1 &quot;     \t &quot;  $7&#125;END &#123;print &quot;This concludes the listing&quot;&#125;$ gawk -f script4.gawk /etc/passwd</code></pre><h1 id="引用-参考"><a href="#引用-参考" class="headerlink" title="引用/参考"></a>引用/参考</h1><p>摘录来自: [美] Richard Blum. “Linux命令行与shell脚本编程大全（第3版）。” Apple Books. </p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grep</title>
      <link href="/2022/01/06/grep/"/>
      <url>/2022/01/06/grep/</url>
      
        <content type="html"><![CDATA[<h1 id="grep：输出匹配模式的行"><a href="#grep：输出匹配模式的行" class="headerlink" title="grep：输出匹配模式的行"></a>grep：输出匹配模式的行</h1><p>grep 命令的命令行格式如下： <code>grep [option...] [patterns] [file...]</code></p><ul><li>grep 命令会在<strong>输入</strong>或<strong>指定的文件中</strong>查找包含匹配<u>指定模式</u>的字符的行。grep 的输出就是包含了匹配模式的行。无法在文本中匹配 newline 字符。</li><li>option 和 file 参数可以有 0/多个。patterns 参数包含 1/多个以新行分割的模式，当 options 是 <code>-e patterns</code> 或 <code>-f file</code>时，新行被忽略。</li><li>file 为 - 时，表示标准输出；如果没有指定 input，grep 搜索这个工作目录。</li></ul><p>默认情况下，grep 命令用基本的Unix风格正则表达式来匹配模式。Unix风格正则表达式采用特殊字符来定义怎样查找匹配的模式。</p><p>常用下面四个，具体见 options 部分</p><ul><li><code>-v</code></li><li><code>-n</code></li><li><code>-c</code></li><li><code>-e</code></li></ul><h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2><h3 id="grep-程序的信息"><a href="#grep-程序的信息" class="headerlink" title="grep 程序的信息"></a>grep 程序的信息</h3><ul><li><code>--help</code></li><li><code>-V</code> / <code>--version</code></li></ul><h3 id="匹配控制"><a href="#匹配控制" class="headerlink" title="匹配控制"></a>匹配控制</h3><ul><li><code>-e patterns</code> / <code>--regexp=patterns</code> ：匹配某些模式中的一个或多个</li><li><code>-f file</code> / <code>--file=file</code>：匹配文件中的模式</li><li><code>-i</code> / <code>-y</code> \ <code>--ignore-case</code>：忽略文件和匹配中的大小写</li><li><code>--no-ignore-case</code>：不忽略大小写</li><li><code>-v</code> / <code>--invert-match</code>：不匹配的行</li><li><code>-w</code> / <code>--word-regexp</code>：匹配包含整个单词的行</li><li><code>-x</code> / <code>--line-regexp</code>：匹配包含整个行的行</li></ul><h3 id="输出控制"><a href="#输出控制" class="headerlink" title="输出控制"></a>输出控制</h3><ul><li><code>-c</code> / <code>--count</code>：不输出具体行，输出行数</li><li><code>--color[=WHEN]</code> / <code>--colour[=WHEN]</code>：对选中的数据高亮</li><li><code>-L</code> / <code>--files-without-match</code>：输出匹配行所在文件的名字，匹配到第一次出现就返回</li><li><code>-m num</code> / <code>--max-count=num</code>：只搜索前 m 行</li><li><code>-o</code> / <code>--only-matching</code>：只输出匹配行的匹配的部分，每个匹配一行输出</li><li><code>-q</code> / <code>--quiet / --silent</code>：不向标准输出输出。如果搜索到匹配，马上返回 0 状态码，如果有错误，也马上返回。同 -s / –no-messages。</li></ul><h3 id="输出行前缀控制"><a href="#输出行前缀控制" class="headerlink" title="输出行前缀控制"></a>输出行前缀控制</h3><ul><li><code>-b</code> / <code>--byte-offset</code></li><li><code>-H</code> / <code>--with-filename</code>：输出匹配时，前缀输出文件名</li><li><code>-h</code> / <code>--no-filename</code>：当输入只有一个文件时，不输出文件名</li><li><code>--label=LABEL</code> </li><li><code>-n</code> / <code>--line-number</code>：输出匹配所在的行数</li><li><code>-T</code> / <code>--initial-tab</code>：输出前缀时，以tab形式展示</li><li><code> -Z</code> / <code>--null</code></li></ul><h3 id="上下文行的控制"><a href="#上下文行的控制" class="headerlink" title="上下文行的控制"></a>上下文行的控制</h3><p>Context lines 是接近匹配行的非匹配行。</p><ul><li><code>-A num</code> \ <code>--after-context=num</code>：输出匹配行后 num 行</li><li><code>-B num</code> \ <code>--before-context=num</code>：输出匹配行前 num 行</li><li><code>-C num</code> \ <code>-num \ --context=num</code>：输出匹配行前，后 num 行</li><li><code>--group-separator=string</code></li><li><code> --no-group-separator</code></li></ul><p>“alias grep=’grep –color=auto”</p><p>有四种 grep 的变种，通过 options 控制：</p><ul><li><code>-G</code> / <code>--basic-regexp</code>：默认的（BRE：basic regular expressions）</li><li><code>-E</code> / <code>--extended-regexp</code>：支持POSI，将匹配模式解释为扩展的正则匹配表达式 （EREs）</li><li><code>-F</code> / <code>--fixed-strings</code>：egrep 命令支持POSIX扩展正则表达式。POSIX扩展正则表达式含有更多的可以用来指定匹配模式的字符。</li><li><code>-P</code> / <code>--prel-regexp</code> ：fgrep 支持将匹配模式指定为用换行符分隔的一列固定长度的字符串。这样就可以把这列字符串放到一个文件中，然后在fgrep 命令中用其在一个大型文件中搜索字符串了。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>部分摘录来自: [美] Richard Blum. “Linux命令行与shell脚本编程大全（第3版）。” Apple Books.</li><li>部分翻译自 <code>info grep</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python</title>
      <link href="/2019/12/24/python/"/>
      <url>/2019/12/24/python/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://foofish.net/python-function-args.html">Python 函数中，参数是传值，还是传引用？</a><ul><li>传的是对象！因为有即时获取验证码的繁琐操作，所以存在印象笔记了</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊ERC20</title>
      <link href="/2019/12/23/%E4%BB%A5%E5%A4%AA%E5%9D%8AERC20/"/>
      <url>/2019/12/23/%E4%BB%A5%E5%A4%AA%E5%9D%8AERC20/</url>
      
        <content type="html"><![CDATA[<ul><li>译文：<a href="https://mp.weixin.qq.com/s?__biz=MzIwODA3NDI5MA==&mid=2652525287&idx=1&sn=4e8409169abb97a7ba36471cece34ad3&chksm=8ce651babb91d8ac9c6a69f25344981a11d29e799940dbce953b0b43cdb6ea65f64ec508b842&scene=21#wechat_redirect">2017-理解ERC-20 token合约-以太坊爱好者</a> <ul><li>原文：<a href="https://www.wealdtech.com/articles/understanding-erc20-token-contracts/">2017-Understanding ERC-20 token contracts-Jim McDonald</a></li></ul></li></ul><p>从这篇文章中可知，ERC20 就是一个记录 &lt;地址，资产&gt; 的键值存储数据库。所有的 存 token、取 token 操作相当于在记录里面的增/删/改一条记录。</p><ul><li><a href="https://www.jianshu.com/p/4002a5212885">2018-教你如何一步步创建ERC20代币-Pony小马</a></li></ul><p>这篇文章实践为例，构建简单的 ERC20 代币，介绍了ERC20的标准接口并做了实现和部署。</p><ul><li>译文：<a href="https://mp.weixin.qq.com/s/foM1QWvsqGTdHxHTmjczsw">2017-代币支付的以太坊智能服务-以太坊爱好者</a><ul><li>原文：<a href="https://www.wealdtech.com/articles/ethereum-smart-service-payment-with-tokens/">2017-Ethereum smart service payment with tokens-Jim McDonald</a></li></ul></li></ul><p>这篇文章主要以伪代码的形式，说明了外部服务如何使用 token 作为一种支付方式。以图文并茂的方式告诉我们几个函数的适用场景。包括 ：<code>approve()</code>，<code>transfer()</code>，<code>transferFrom()</code>，<code>approveAndCall()</code>，<code>receiveApproval()</code>，<code>transferAndCall()</code>，<code>tokenFallback()</code>。</p><ul><li><p><a href="https://dev.to/jklepatch/the-2-ways-to-transfer-erc20-tokens-in-solidity-3h40">The 2 ways to transfer ERC20 Tokens in Solidity</a></p><ul><li><p>transfer() (simple transfers)</p><ul><li>Import the ERC20 token<ul><li><code>import  &quot;github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol&quot;;</code></li></ul></li><li>Import the address of the token</li></ul></li><li><p>Call transfer()</p></li></ul></li><li><p>transferFrom() (delegated transfer)</p><ul><li>Import the ERC20 token</li><li>Import the address of the token</li><li>Call approve()</li><li>Call transferFrom()</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> solidity </tag>
            
            <tag> 智能合约 </tag>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊-Transaction</title>
      <link href="/2019/12/22/%E4%BB%A5%E5%A4%AA%E5%9D%8A-Transaction/"/>
      <url>/2019/12/22/%E4%BB%A5%E5%A4%AA%E5%9D%8A-Transaction/</url>
      
        <content type="html"><![CDATA[<ul><li>本文主要参考（并根据自己的理解进行思路的梳理）<ul><li><a href="https://blog.csdn.net/TurkeyCock/article/details/80485391">以太坊交易源码分析</a></li><li><a href="https://blog.csdn.net/yzpbright/article/details/83538362s">GoLand导入并编译以太坊源码go-ethereum</a></li><li><a href="https://ethereum.iethpay.com/how-to-sign-and-hash-tx.html">交易签名以及哈希值的计算</a></li></ul></li></ul><h2 id="交易定义"><a href="#交易定义" class="headerlink" title="交易定义"></a>交易定义</h2><ul><li>由 <code>EOA（externally owned account）</code>生成的，签过名的消息</li><li>万事始于交易。交易可触发以太坊（全局的单个状态机）状态的转换，调用智能合约在 <code>EVM</code> 中的执行</li></ul><h2 id="交易基本流程"><a href="#交易基本流程" class="headerlink" title="交易基本流程"></a>交易基本流程</h2><ul><li><p>发起交易：指定目标地址和交易金额，以及需要的 gas/gaslimit，还可以填充 data 字段</p></li><li><p>交易签名：使用账户私钥对交易（实际是交易的 hash）进行签名</p></li><li><p>提交交易：把交易加入到交易缓冲池 txpool 中（会先对交易签名进行验证）</p></li><li><p>广播交易：通知 EVM 执行，同时把交易信息广播给其他结点</p></li></ul><p><img src="https://i.loli.net/2019/12/22/MBHsouZ8PK6AGip.png" alt="transaction-execute.jpg"></p><h3 id="交易处理入口函数"><a href="#交易处理入口函数" class="headerlink" title="交易处理入口函数"></a>交易处理入口函数</h3><p>用户通过 <code>JSON RPC</code> 发起 <code>eth_sendTransaction</code> 请求，最终会调用 <code>PublicTransactionPoolAPI</code> 的实现，代码位于<code> internal/ethapi/api.go</code>。</p><p>首先根据 <code>from</code> 地址查找到对应的 <code>wallet</code>。根据参数值去设置默认值，比如 <code>amount</code> <code>gasPrice</code>  <code>nonce</code> 字段可以没有输入。还会检查 <code>data</code> 和 <code>input</code> 是否重复输入，并且不相等。对参数值进行检查，如果是创建合约，检查 <code>data</code>是否为空。</p><p>接着主要做了以下3件事：</p><ul><li><p>通过 <code>SendTxArgs.toTransaction() </code>创建交易</p></li><li><p>通过<code>Wallet.SignTx()</code>对交易进行签名。Wallet是一个接口，具体实现在 keyStoreWallet 中。</p></li><li><p>通过<code>submitTransaction()</code>提交交易</p></li></ul><pre><code class="go">// SendTransaction creates a transaction for the given argument, sign it and submit it to the// transaction pool.func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error) &#123;    // Look up the wallet containing the requested signer    account := accounts.Account&#123;Address: args.From&#125;    wallet, err := s.b.AccountManager().Find(account)    if err != nil &#123;        return common.Hash&#123;&#125;, err    &#125;    if args.Nonce == nil &#123;        // Hold the addresse&#39;s mutex around signing to prevent concurrent assignment of the same nonce to multiple accounts.        s.nonceLock.LockAddr(args.From)        defer s.nonceLock.UnlockAddr(args.From)    &#125;    // Set some sanity defaults and terminate on failure    if err := args.setDefaults(ctx, s.b); err != nil &#123;        return common.Hash&#123;&#125;, err    &#125;    // Assemble the transaction and sign with the wallet    tx := args.toTransaction() //*****    signed, err := wallet.SignTx(account, tx, s.b.ChainConfig().ChainID)//*****    if err != nil &#123;        return common.Hash&#123;&#125;, err    &#125;    return SubmitTransaction(ctx, s.b, signed)//*****&#125;</code></pre><h3 id="创建交易实例"><a href="#创建交易实例" class="headerlink" title="创建交易实例"></a>创建交易实例</h3><p>首先处理输入参数的 <code>input/data</code> 字段，推荐用 <code>input</code>，<code>data</code> 是为了向后兼容。</p><p>如果目标地址为空的话，表示这是一个创建智能合约的交易，调用 <code>NewContractCreation()</code>。否则说明这是一个普通交易，调用 <code>NewTransaction()</code>。不管调用哪个，最终都会生成一个Transaction实例，处理函数是一样的，只是 <code>to</code> 参数有没有值的区别，transaction 类型字段见下。</p><pre><code class="go">//代码位于internal/ethapi/api.gofunc (args *SendTxArgs) toTransaction() *types.Transaction &#123;    var input []byte    if args.Input != nil &#123;        input = *args.Input    &#125; else if args.Data != nil &#123;        input = *args.Data    &#125;    if args.To == nil &#123;        return types.NewContractCreation(uint64(*args.Nonce), (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input)    &#125;    return types.NewTransaction(uint64(*args.Nonce), *args.To, (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input)&#125;</code></pre><h4 id="SendTxArgs-结构"><a href="#SendTxArgs-结构" class="headerlink" title="SendTxArgs 结构"></a>SendTxArgs 结构</h4><p>和 <code>JSON</code> 字段相应的，包括了地址、gas、金额这些交易信息，<code>nonce</code> 是一个随账户交易次数自增的数字，一般会在默认设置中自动获取填充。交易还可以携带一些额外数据，存放在 <code>data</code> <strong>或者</strong> <code>input</code> 字段中。</p><pre><code class="go">//代码位于internal/ethapi/api.go// SendTxArgs represents the arguments to sumbit a new transaction into the transaction pool.type SendTxArgs struct &#123;    From     common.Address  `json:&quot;from&quot;`    To       *common.Address `json:&quot;to&quot;`    Gas      *hexutil.Uint64 `json:&quot;gas&quot;`    GasPrice *hexutil.Big    `json:&quot;gasPrice&quot;`    Value    *hexutil.Big    `json:&quot;value&quot;`    Nonce    *hexutil.Uint64 `json:&quot;nonce&quot;`    // We accept &quot;data&quot; and &quot;input&quot; for backwards-compatibility reasons. &quot;input&quot; is the newer name and should be preferred by clients.    Data  *hexutil.Bytes `json:&quot;data&quot;`    Input *hexutil.Bytes `json:&quot;input&quot;`&#125;</code></pre><h4 id="transaction类型"><a href="#transaction类型" class="headerlink" title="transaction类型"></a>transaction类型</h4><p>主要就是包含了一个 <code>txdata</code> 类型的字段，其他3个都是缓存。</p><pre><code class="go">// 代码位于 core/types/transaction.gotype Transaction struct &#123;    data txdata    // caches    hash atomic.Value    size atomic.Value    from atomic.Value&#125;</code></pre><h4 id="txdata-类型"><a href="#txdata-类型" class="headerlink" title="txdata 类型"></a>txdata 类型</h4><p>相对于输入参数中的字段，多了 <code>V、R、S</code> 和 <code>hash</code> 4 个字段，少了 <code>from</code> 字段。&lt;v,r,s&gt;是签名后才能得到的，现在生成的交易实例中不包含。</p><p> 其他节点收到交易时，通过 &lt;v,r,s&gt; 及 消息hash 计算出 <code>from</code> 字段，参见 <strong>交易签名</strong> 部分。</p><pre><code class="go">// 代码位于 core/types/transaction.gotype txdata struct &#123;    AccountNonce uint64          `json:&quot;nonce&quot;    gencodec:&quot;required&quot;`    Price        *big.Int        `json:&quot;gasPrice&quot; gencodec:&quot;required&quot;`    GasLimit     uint64          `json:&quot;gas&quot;      gencodec:&quot;required&quot;`    Recipient    *common.Address `json:&quot;to&quot;       rlp:&quot;nil&quot;` // nil means contract creation    Amount       *big.Int        `json:&quot;value&quot;    gencodec:&quot;required&quot;`    Payload      []byte          `json:&quot;input&quot;    gencodec:&quot;required&quot;`    // Signature values    V *big.Int `json:&quot;v&quot; gencodec:&quot;required&quot;`    R *big.Int `json:&quot;r&quot; gencodec:&quot;required&quot;`    S *big.Int `json:&quot;s&quot; gencodec:&quot;required&quot;`    // This is only used when marshaling to JSON.    Hash *common.Hash `json:&quot;hash&quot; rlp:&quot;-&quot;`&#125;</code></pre><h3 id="交易签名"><a href="#交易签名" class="headerlink" title="交易签名"></a>交易签名</h3><p>先通过 <code>Keccak-256</code> 算法计算交易数据的 has h值，然后结合账户的私钥，通过 ECDSA（Elliptic Curve Digital Signature Algorithm），也就是椭圆曲线数字签名算法生成签名数据。</p><p><img src="https://i.loli.net/2019/12/22/X5xb6N4hMg1yDGW.png" alt="SignTx.jpg"></p><pre><code class="go">//代码位于 accounts/keystore/wallet.go/* SignTx implements accounts.Wallet, attempting to sign the given transaction with the given account. If the wallet does not wrap this particular account, an error is returned to avoid account leakage (even though in theory we may/be able to sign via our shared keystore backend).*/func (w *keystoreWallet) SignTx(account accounts.Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error) &#123;    // Make sure the requested account is contained within    if !w.Contains(account) &#123;        return nil, accounts.ErrUnknownAccount    &#125;    // Account seems valid, request the keystore to sign    return w.keystore.SignTx(account, tx, chainID) //*****&#125;</code></pre><p>插播一条：从交易原信息和&lt;v,r,s&gt;生成 <code>from</code> 字段的示意图。TODO：代码示例</p><p><img src="https://i.loli.net/2019/12/22/iaUXbWy45P91R6O.png" alt="txCalFrom.jpg"></p><h4 id="keystore-SignTx"><a href="#keystore-SignTx" class="headerlink" title="keystore.SignTx"></a>keystore.SignTx</h4><p>这里会首先判断账户是否已经解锁，如果已经解锁的话就可以获取它的私钥。</p><p>然后创建签名器，如果要符合 EIP155 规范的话，需要把 chainID 传进去，也就是我们的 “–networkid” 令行参数。</p><p>调用一个全局函数 <strong>SignTx()</strong> 完成签名.</p><pre><code class="go">//代码位于 accounts/keystore/keystore.go//SignTx signs the given transaction with the requested account.func (ks *KeyStore) SignTx(a accounts.Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error) &#123;    // Look up the key to sign with and abort if it cannot be found    ks.mu.RLock()    defer ks.mu.RUnlock()    unlockedKey, found := ks.unlocked[a.Address]    if !found &#123;        return nil, ErrLocked    &#125;    // Depending on the presence of the chain ID, sign with EIP155 or homestead    if chainID != nil &#123;        return types.SignTx(tx, types.NewEIP155Signer(chainID), unlockedKey.PrivateKey)    &#125;    return types.SignTx(tx, types.HomesteadSigner&#123;&#125;, unlockedKey.PrivateKey)&#125;</code></pre><h4 id="全局-types-signTx-完成签名"><a href="#全局-types-signTx-完成签名" class="headerlink" title="全局 types.signTx 完成签名"></a>全局 types.signTx 完成签名</h4><p>主要分为3个步骤：</p><ul><li>生成交易的hash值</li><li>根据hash值和私钥生成签名</li><li>把签名数据填充到Transaction实例中</li></ul><pre><code class="go">//代码位于 core/types/transaction_signing.go// SignTx signs the transaction using the given signer and private keyfunc SignTx(tx *Transaction, s Signer, prv *ecdsa.PrivateKey) (*Transaction, error) &#123;    h := s.Hash(tx)    sig, err := crypto.Sign(h[:], prv)    if err != nil &#123;        return nil, err    &#125;    return tx.WithSignature(s, sig)&#125;</code></pre><h5 id="交易散列生成"><a href="#交易散列生成" class="headerlink" title="交易散列生成"></a>交易散列生成</h5><pre><code class="go">//代码位于 core/types/transaction_signing.go// Hash returns the hash to be signed by the sender.// It does not uniquely identify the transaction.func (s EIP155Signer) Hash(tx *Transaction) common.Hash &#123;    return rlpHash([]interface&#123;&#125;&#123;        tx.data.AccountNonce,        tx.data.Price,        tx.data.GasLimit,        tx.data.Recipient,        tx.data.Amount,        tx.data.Payload,        s.chainId, uint(0), uint(0),    &#125;)&#125;</code></pre><p>先进行RLP编码（一种数据序列化方法），然后再用SHA3-256生成hash值。TODO：RLP 编码实现。</p><pre><code class="go">//代码位于 core/types/block.gofunc rlpHash(x interface&#123;&#125;) (h common.Hash) &#123;    hw := sha3.NewLegacyKeccak256()    rlp.Encode(hw, x)    hw.Sum(h[:0])    return h&#125;</code></pre><h5 id="根据hash值和私钥生成签名"><a href="#根据hash值和私钥生成签名" class="headerlink" title="根据hash值和私钥生成签名"></a>根据hash值和私钥生成签名</h5><p>TODO：签名的过程</p><p>通过 ECDSA 算法生成签名数据，最终会返回的签名是一个字节数组，按R / S / V的顺序排列。</p><pre><code class="go">//代码位于 crypto/signature_cgo.go/*Sign calculates an ECDSA signature. This function is susceptible to chosen plaintext attacks that can leak information about the private key that is used for signing. Callers mustbe aware that the given digest cannot be chosen by an adversery. Commonsolution is to hash any input before calculating the signature.*/// The produced signature is in the [R || S || V] format where V is 0 or 1.func Sign(digestHash []byte, prv *ecdsa.PrivateKey) (sig []byte, err error) &#123;    if len(digestHash) != DigestLength &#123;        return nil, fmt.Errorf(&quot;hash is required to be exactly %d bytes (%d)&quot;, DigestLength, len(digestHash))    &#125;    seckey := math.PaddedBigBytes(prv.D, prv.Params().BitSize/8)    defer zeroBytes(seckey)    return secp256k1.Sign(digestHash, seckey)&#125;</code></pre><h5 id="填充签名数据"><a href="#填充签名数据" class="headerlink" title="填充签名数据"></a>填充签名数据</h5><p>把签名数据的这3个值填充到Transaction结构中。</p><pre><code class="go">//代码位于 core/types/transaction.go// WithSignature returns a new transaction with the given signature.// This signature needs to be in the [R || S || V] format where V is 0 or 1.func (tx *Transaction) WithSignature(signer Signer, sig []byte) (*Transaction, error) &#123;    r, s, v, err := signer.SignatureValues(tx, sig)    if err != nil &#123;        return nil, err    &#125;    cpy := &amp;Transaction&#123;data: tx.data&#125;    cpy.data.R, cpy.data.S, cpy.data.V = r, s, v    return cpy, nil&#125;</code></pre><h6 id="SignatureValues"><a href="#SignatureValues" class="headerlink" title="SignatureValues"></a>SignatureValues</h6><p>生成的签名数据是字节数组类型，需要通过signer.SignatureValues()函数转换成3个big.Int类型的数据，然后填充到Transaction结构的R / S / V字段上。</p><p>TODO：v 到底怎么回事，一会加27，一会加35</p><pre><code class="go">//代码位于 /core/transaction_signing.go// SignatureValues returns signature values. This signature// needs to be in the [R || S || V] format where V is 0 or 1.func (fs FrontierSigner) SignatureValues(tx *Transaction, sig []byte) (r, s, v *big.Int, err error) &#123;    if len(sig) != crypto.SignatureLength &#123;        panic(fmt.Sprintf(&quot;wrong size for signature: got %d, want %d&quot;, len(sig), crypto.SignatureLength))    &#125;    r = new(big.Int).SetBytes(sig[:32])    s = new(big.Int).SetBytes(sig[32:64])    v = new(big.Int).SetBytes([]byte&#123;sig[64] + 27&#125;)    return r, s, v, nil&#125;</code></pre><h3 id="提交交易"><a href="#提交交易" class="headerlink" title="提交交易"></a>提交交易</h3><p>就看我参考的原文吧。主要是前两点和最近做的东西有点关系。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊科普</title>
      <link href="/2019/12/12/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%91%E6%99%AE/"/>
      <url>/2019/12/12/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%91%E6%99%AE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ethfans.org/posts/what-is-an-ethereum-keystore-file">什么是以太坊私钥储存（Keystore）文件？</a></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++随记</title>
      <link href="/2019/11/29/C-%E9%9A%8F%E8%AE%B0/"/>
      <url>/2019/11/29/C-%E9%9A%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li><p>想要随机产生0-100间的整数，从而做排序的操作</p><ul><li><a href="https://www.cnblogs.com/VVingerfly/p/5990714.html">C++产生随机数</a>             </li><li>通常用 <code>srand((unsigned)time(0)) </code>或者<code>srand((unsigned)time(NULL))</code>来 产生种子。如果仍然觉得时间间隔太小。可以在<code>(unsigned)time(0)</code>或者<code>(unsigned)time(NULL)</code>后面乘上某个合适的整数。 例如,<code>srand((unsigned)time(NULL)*10)</code>。</li><li><a href="https://blog.csdn.net/yangziluomu/article/details/102013793">浮点随机数产生</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链相关技术前沿洞察</title>
      <link href="/2019/11/05/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E5%89%8D%E6%B2%BF%E6%B4%9E%E5%AF%9F/"/>
      <url>/2019/11/05/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E5%89%8D%E6%B2%BF%E6%B4%9E%E5%AF%9F/</url>
      
        <content type="html"><![CDATA[<hr><p>2019 CCF区块链技术大会 ，  中国工程院院士陈纯院士发表了《联盟区块链关键技术与区块链的监管挑战》主题演讲  </p><h3 id="核心观点"><a href="#核心观点" class="headerlink" title="核心观点"></a>核心观点</h3><ol><li>联盟链底层平台的核心是性能、安全隐私、可用性和可扩展；</li><li>链上链下数据协同技术是未来发展的几个重要方向；</li><li>区块链的监管技术是区块链健康和持续发展的关键。</li></ol><h3 id="联盟区块链的4大关键技术"><a href="#联盟区块链的4大关键技术" class="headerlink" title="联盟区块链的4大关键技术"></a>联盟区块链的4大关键技术</h3><h4 id="联盟区块链高性能"><a href="#联盟区块链高性能" class="headerlink" title="联盟区块链高性能"></a>联盟区块链高性能</h4><p>问题： 大规模的节点，或大数据量的情况下区块链性能会急剧下降  </p><p>技术突破：包括高性能的共识算法、新型的共识机制、高效智能合约引擎、软硬件协同优化  等；希望能够提供共识效率与安全性，主要是为了要支撑大规模各种网络结构的主网。</p><h4 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h4><p>动态成员的准入机制，以及节点失效后的快速恢复机制。 （不能整个系统停下来加节点，应该是可以实时动态的。某几个节点出问题，我要删除的话，不能停下来删除，系统不能停）</p><p>去中心化联盟自治的管理机制，是通过多方提案投票表决方法还是别的方法，这些都要有机制。有人会怀疑，联盟链是不是真正能做到管理的公平机制 。</p><h4 id="高可扩展"><a href="#高可扩展" class="headerlink" title="高可扩展"></a>高可扩展</h4><p>编程可扩展，我们说支持多种编程语言的使用。当然越普通的编程语言越好；</p><p>存储方式可扩展，能不能支持多类型、多组织形式的数据可信存储；</p><p>支持预言机提供可信外部数据源服务；</p><p>支持跨链，实现同构链与异构链的跨链协同。</p><h4 id="区块链安全隐私"><a href="#区块链安全隐私" class="headerlink" title="区块链安全隐私"></a>区块链安全隐私</h4><p>中国要首先要全面支持我国加密算法和标准。</p><p>商业应用需要平台业务数据隐私保护，可以通过命名空间的方式在物理层面进行业务数据的分离？？  </p><p>更细粒度的隐私交易机制，实现交易可验证但是不可见。</p><p>基于可信执行环境等技术实现节点密钥管理和数据加密存储，基于默克尔、DAG等数据组织技术，防止文件被篡改。  </p><h3 id="链上链下数据协同技术？？？"><a href="#链上链下数据协同技术？？？" class="headerlink" title="链上链下数据协同技术？？？"></a>链上链下数据协同技术？？？</h3><p>CAP定理，就是一致性、可用性、分区容忍性 ；</p><p>区块链的不可能三⻆模型对应过来，它是去中心化、可扩展、安全 。</p><p>区块链系统需要通过链下系统扩展计算和存储能力。另一方面，现有系统链下需要与区块链对接以解决信息孤岛、防篡改等问题。</p><p>所谓的链上就是区块链，链下就是所有传统的信息系统。   要求链上链下数据，如果能够协同就能确<br>保关联性和一致性。</p><p>目前国内外对链上链下数据协同的技术才刚刚起步，也有一些协同研究，包括侧链和状态通道，为了提高性能和计算能力。</p><p>链上链下要同时考虑链上和链下，包括链下系统如何对接，数据隐私保护的对接、链下存储等。</p><h4 id="链上链下数据协同技术-的4大发展方向"><a href="#链上链下数据协同技术-的4大发展方向" class="headerlink" title="链上链下数据协同技术  的4大发展方向"></a>链上链下数据协同技术  的4大发展方向</h4><ol><li>大规模高性能点对点网络；</li><li>模块化安全密码学协议；</li><li>高性能可编程计算引擎；（可用不同的编程语言编写智能合约）</li><li>可定义的数据分发协议。</li></ol><h3 id="区块链监管技术发展趋势"><a href="#区块链监管技术发展趋势" class="headerlink" title="区块链监管技术发展趋势"></a>区块链监管技术发展趋势</h3><p>区块链的监管技术，这应该是  区块链健康和可持续发展的关键之一。  </p><ol><li>区块链节点的追踪与可视化；</li><li>联盟链穿透式监管技术；</li><li>公链主动发现与探测技术；</li><li>以链治链的体系结构及标准。 </li></ol><hr><p>2016年10月，工信部《中国区块链技术和应用发展白皮书》</p><h3 id="区块链-教育"><a href="#区块链-教育" class="headerlink" title="区块链+教育"></a>区块链+教育</h3><ul><li><strong>学生信用体系</strong> ：学历造假、论文造假、求职简历造假，用人单位、院校缺乏验证手段，蒙受信息不对称产生的损失，降低了学校与企业间、院校与院校间的信任。  <ul><li>帮助有良好记录的学生获得更多的激励措施，并构建起一个良性的信用生态 。 </li></ul></li></ul><ul><li><strong>产权保护</strong>：针对一些学术性实验、跨校组织的公开课以及多媒体教学资源，在网络上往往存在<strong>版权纠纷与学术纠纷</strong>，对学者以及研究人员缺乏相应的知识产权保护，影响了高等学府对学术研究的积极性。<ul><li>可为学术成果提供不可篡改的数字化证明，为学术纠纷提供了权威的举证凭据，降低纠纷事件消耗的人力与时间。    </li></ul></li></ul><p>2017[区块链技术在教育领域的应用模式与现实挑战*□杨现民 李新 吴焕庆 赵可云]</p><ul><li>优化教育业务流程，实现高效、低廉的教育资源交易。  <ul><li>在教育资源共享方面，利用分布式账本技术实现用户与资源间的直接联系，能够简化操作流程，提高资源共享效率，以此来促进教育资源的开放共享，解决资源孤岛问题。  </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零碎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法与数据结构学习必备</title>
      <link href="/2019/11/03/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E5%BF%85%E5%A4%87/"/>
      <url>/2019/11/03/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E5%BF%85%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cxyxiaowu.com/2917.html">程序员必须掌握的算法有哪些？谈谈这这几年学过的算法</a></p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="算法分析神器—时间复杂度"><a href="#算法分析神器—时间复杂度" class="headerlink" title="算法分析神器—时间复杂度"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU1MDE4MzUxNA==&mid=2247483867&idx=1&sn=6270b56b79cb74334eb4faf80de05f0a&scene=21#wechat_redirect">算法分析神器—时间复杂度</a></h3><ul><li> 刻画算法的运行时间 ：程序运行时间和问题规模 N 的函数关系</li><li> 时间复杂度 ： 我们一般只关心随着问题规模 n 趋于无穷时函数中对函数结果影响最大的项，也就是最高次项 </li><li> 一般我们会保留最高次项并忽略该项的系数 ， O代表了运行时间函数的一个渐进上界 </li><li> 时间复杂度可以表示某个算法的运行时间的趋势，大致地度量算法效率的好坏 </li><li> 时间复杂度的计算 </li><li> 得出运行时间的函数 </li><li> 对函数进行简化   </li></ul><h3 id="佩奇学编程-复杂度分析原来这么简单"><a href="#佩奇学编程-复杂度分析原来这么简单" class="headerlink" title="佩奇学编程 | 复杂度分析原来这么简单"></a><a href="https://mp.weixin.qq.com/s?__biz=MzIwODg1OTkzNw==&mid=2247484427&idx=1&sn=0ce7de439699dd3169ed8488cb5cd659&scene=21#wechat_redirect">佩奇学编程 | 复杂度分析原来这么简单</a></h3><ul><li>空间复杂度那块有一些不妥之处，要辨证看待</li></ul><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><h3 id="线性表（List）"><a href="#线性表（List）" class="headerlink" title="线性表（List）"></a>线性表（List）</h3><p>零个或多个数据元素的有限序列。除头尾节点，有且仅有一个前驱，一个后继。</p><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>逻辑上相邻的元素，位置上也相邻，三个重要属性：</p><ul><li>存储空间的起始位置</li><li>线性表的最大存储容量</li><li>线性表的当前长度</li></ul><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><h4 id="基础数据结构：【动画】如何轻松手写链表？"><a href="#基础数据结构：【动画】如何轻松手写链表？" class="headerlink" title="基础数据结构：【动画】如何轻松手写链表？"></a><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247486106&idx=2&sn=039eb52871cfe5428c7fcf1e770c8760&scene=21#wechat_redirect">基础数据结构：【动画】如何轻松手写链表？</a></h4><ul><li>熟悉节点的数据结构、理清思路、边界条件（输入边界（输入参数，为空，在链表中是否存在），特殊边界（头部，尾部））、手写代码（定义节点，增加节点，删除节点）、测试用例（普通测试、边界测试、特殊测试）</li></ul><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><ul><li><a href="https://blog.csdn.net/u013709270/article/details/53470428">跳跃表的原理及实现</a><ul><li>类似排序数组中二分插入，不过有层级的概念</li><li>大致看懂了，但是还没有自己实现！！</li></ul></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485133&idx=1&sn=5206c44c6ea6416d6c955e6eda29bc38&scene=21#wechat_redirect">以后有面试官问你「跳跃表」，你就把这篇文章扔给他</a></li></ul><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><ul><li>用数组描述的链表。——游标实现法</li><li><a href="https://blog.csdn.net/weixin_43340991/article/details/83475643">线性表-静态链表</a></li></ul><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247486111&idx=2&sn=c5861252c84f0c1fcd3e51e77f98e377&scene=21#wechat_redirect">三分钟基础知识：什么是栈？</a><ul><li>数组实现栈</li><li>链式栈</li></ul></li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><p><a href="https://sort.hust.cc/">十大经典排序算法</a></p><ul><li><strong>n</strong>：数据规模；<strong>k</strong>：“桶”的个数；<strong>In-place</strong>：占用常数内存，不占用额外内存；<strong>Out-place</strong>：占用额外内存；<strong>稳定性</strong>：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li></ul><p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-Lm9JtwbhXVOfXyecToy%2F-Lm9KQIJAMvCgJQzErQS%2F-Lm9KSPi7v-ygMtlI6Zr%2Fsort.png?generation=1565688978687703&alt=media"></p><h3 id="基于比较的排序算法：O-nlogn"><a href="#基于比较的排序算法：O-nlogn" class="headerlink" title="基于比较的排序算法：O(nlogn)"></a>基于比较的排序算法：O(nlogn)</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><a href="https://blog.csdn.net/nrsc272420199/article/details/82587933">快速排序</a></p><h3 id="不比较的排序算法"><a href="#不比较的排序算法" class="headerlink" title="不比较的排序算法"></a>不比较的排序算法</h3><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p><a href="https://www.cnblogs.com/eaglet/archive/2010/09/16/1828016.html">算法系列-计数排序</a></p><ul><li> 计数排序是一种算法复杂度 O(n) 的排序方法，适合于小范围集合的排序。也更适合于有多个重复元素的场景。</li><li> 需要知道这些元素的最大值和最小值，辅助数组的长度为 max - min +1，辅助数组每个元素存放的是值等于这个位置的数出现的次数，使用键值作为索引。只能作为整数的排序。</li><li> <a href="https://blog.csdn.net/haiki66/article/details/103308183">计数排序C++代码实现</a></li></ul><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p><a href="https://blog.csdn.net/developer1024/article/details/79770240">算法：排序算法之桶排序——链表实现</a></p><p><a href="https://www.geeksforgeeks.org/bucket-sort-2/">Bucket Sort-GeeksforGeeks——vector实现</a></p><ul><li>开辟空桶/list<ul><li>vector数组，大小为 N（N代表桶的个数） 的数组，数组中是大小为 M（M是一个桶的大小） 的 vector</li><li>用链表，开辟桶个数的空间存放head指针，这种存储方式，使用插入排序比较好</li></ul></li><li>遍历原数组，使用映射函数将数组元素映射至桶中<ul><li>对于链表来说，就是将元素进行排序的插入操作</li></ul></li><li>对桶中元素进行排序<ul><li>对链表来说，边插入，边排序</li><li>对vector来说，再调用一次排序</li></ul></li><li>将排好序的元素连接起来<ul><li>对链表来说，就是两个排好序的链表的合并</li></ul></li><li><a href="https://blog.csdn.net/haiki66/article/details/103314489">桶排序C++代码实现</a></li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p><a href="https://www.geeksforgeeks.org/radix-sort/">Radix Sort-GeeksforGeeks</a></p><ul><li>每一位排序的时候使用了 计数排序，计数数组只需要10位，0—10。</li></ul><p><a href="https://sort.hust.cc/10.radixsort">基数排序</a></p><ul><li>对于有负数的情况，那么就要多开辟计数数组的空间。比如 [0-9]对应负数，[10-19]对应正数。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="牛客"><a href="#牛客" class="headerlink" title="牛客"></a>牛客</h3><p><a href="https://wenku.baidu.com/view/be829ed084254b35eefd348b.html">稀疏矩阵的压缩存储-三元组表</a></p><ul><li>稀疏矩阵中的零元素非常多，全部存储会浪费很多空间，三元组&lt;row,col,val&gt;，表示第row行，第col列的元素值，不记录零元素，从而压缩稀疏矩阵进行存储。</li></ul><p><a href="https://blog.csdn.net/luoweifu/article/details/12071865">蚂蚁爬行问题</a></p><ul><li><a href="https://blog.csdn.net/xubinlxb/article/details/52529774">百度笔试编程题：爬行的蚂蚁（c++）</a><ul><li>关键点在于：因为每只蚂蚁都在以相同的速度运动，相遇后虽反向运动，仍相当于“穿透式”运动，即另一只反向运动的蚂蚁是当前的蚂蚁。两者交换身份。那么最长时间就是离杆子某一端最远的那个距离/速度。</li><li>以杆子的中点为基准，因为蚂蚁运动的方向不定，则所以蚂蚁掉落的最短的时间就是：<strong>max(靠近端点的最短距离)/速度</strong>；</li></ul></li><li>另一类问题是：给出蚂蚁初始位置和运动方向，给定时间T，求T时蚂蚁在杆子上的位置。<ul><li><a href="https://blog.csdn.net/u012881011/article/details/46787577">算法竞赛入门经典例题-蚂蚁</a></li><li>处理中比较好的一个点：就方向而言，左边L 置为-1，右边R 置为1，碰撞在同一个位置则为0。before记录初始状态，after记录终态，其实也就是 原位置 + T*d。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpeedyMurmurs data 记录</title>
      <link href="/2019/10/31/SpeedyMurmurs-data-%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/10/31/SpeedyMurmurs-data-%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="ripple-data-nov7-dynamic"><a href="#ripple-data-nov7-dynamic" class="headerlink" title="ripple-data-nov7-dynamic"></a>ripple-data-nov7-dynamic</h3><ul><li>raw-trust-lines-2016-nov-7.txt: All trust lines as obtained from the Ripple server</li></ul><pre><code class="json">&#123;&quot;result&quot;:&#123;&quot;account&quot;:&quot;r11zZZu6MvoCohwoQ2VrK9JXsw1Y3hVKa&quot;,&quot;lines&quot;:                [&#123;&quot;account&quot;:&quot;rMwjYedjc7qqtKYVLiAccJSmCwih4LnE2q&quot;,&quot;balance&quot;:&quot;0.005473328356624965&quot;,&quot;currency&quot;:&quot;BTC&quot;,&quot;limit&quot;:&quot;1000000000&quot;,&quot;limit_peer&quot;:&quot;0&quot;,&quot;no_ripple&quot;:true,&quot;quality_in&quot;:0,&quot;quality_out&quot;:0&#125;,&#123;&quot;account&quot;:&quot;r3ADD8kXSUKHd6zTCKfnKT3zV9EZHjzp1S&quot;,&quot;balance&quot;:&quot;3.1119669487193&quot;,&quot;currency&quot;:&quot;CAD&quot;,&quot;limit&quot;:&quot;1000&quot;,&quot;limit_peer&quot;:&quot;0&quot;,&quot;quality_in&quot;:0,&quot;quality_out&quot;:0&#125;,&#123;&quot;account&quot;:&quot;rMwjYedjc7qqtKYVLiAccJSmCwih4LnE2q&quot;,&quot;balance&quot;:&quot;2.451995558&quot;,&quot;currency&quot;:&quot;EUR&quot;,&quot;limit&quot;:&quot;5000&quot;,&quot;limit_peer&quot;:&quot;0&quot;,&quot;quality_in&quot;:0,&quot;quality_out&quot;:0&#125;,&#123;&quot;account&quot;:&quot;rMwjYedjc7qqtKYVLiAccJSmCwih4LnE2q&quot;,&quot;balance&quot;:&quot;19.99944999900283&quot;,&quot;currency&quot;:&quot;USD&quot;,&quot;limit&quot;:&quot;0&quot;,&quot;limit_peer&quot;:&quot;0&quot;,&quot;quality_in&quot;:0,&quot;quality_out&quot;:0&#125;]&#125;,&quot;status&quot;:&quot;success&quot;,&quot;type&quot;:&quot;response&quot;&#125;</code></pre><pre><code class="json">&#123;&quot;result&quot;:&#123;&quot;account&quot;:&quot;r12Fd6ffBipWZg9Ynt6AS6Y1G4ZnsaH6k&quot;,&quot;lines&quot;:[]&#125;,&quot;status&quot;:&quot;success&quot;,&quot;type&quot;:&quot;response&quot;&#125;</code></pre><ul><li>complete-parsed-trust-lines-2016-nov-7.txt（all-in-USD-trust-lines-2016-nov-7-cleaned.txt）<ul><li>(src, dst, lower bound, balance, currency, upper bound)</li></ul></li></ul><pre><code>r11VNrqQzivyJqou5ZNrQ9Wfz6j3esVfE rB3gZey7VWHYRqJHLoHDEJXJ2pEPNieKiS 0 0.4554764488341 JPY 10000000000r11VNrqQzivyJqou5ZNrQ9Wfz6j3esVfE rB3gZey7VWHYRqJHLoHDEJXJ2pEPNieKiS 0 0.0000423661606 BTC 10000000000r29mNgvpvRBJNEark7LLHpHaoEhDAMWJD rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B 0 0.007608519971505 BTC 10</code></pre><ul><li><p>currency-exchanges-2016-nov-7.txt: Exchange rates from each currency to USD. The exchange rates have been obtained on Nov 9th from google (fiat currencies) and coinmarketcap.com (cryptocurrencies)</p></li><li><p>all-in-USD-trust-lines-2016-nov-7.txt</p><ul><li>(src, dst, lower bound, balance, upper bound) </li></ul></li></ul><pre><code>r11VNrqQzivyJqou5ZNrQ9Wfz6j3esVfE rB3gZey7VWHYRqJHLoHDEJXJ2pEPNieKiS 0.0 0.00437257390881 96000000.0r11VNrqQzivyJqou5ZNrQ9Wfz6j3esVfE rB3gZey7VWHYRqJHLoHDEJXJ2pEPNieKiS 0.0 0.0306404783307 7.2323e+12</code></pre><ul><li>ripple-transactions-jan-2013-aug-2016.txt<ul><li>(tx_hash, sdr, rev, currency, amount1, amount2, ledger, tag1, tag2, crawl_id, unix_timestamp)</li></ul></li></ul><pre><code>5C0504B229CD8EE803B01D78868B8F4B595D8B1D03636BEEBDBD750B6E5171AE,rfe8yiZUymRPx35BEwGjhfkaLmgNsTytxT,rsdbFqwyGYX5fSvAmMEXBH2hRyBT8QfcUS,XRP,0,100,7227428,&quot;&quot;,&quot;&quot;,1,14029206605234065EB0115DFE0D1A71D7C2640EE798254A25E302D038D23BD44D1911834D,rGaRDdFcp1gZSrfuifZWiVLKq2SbaVRnuJ,rfTMcYDpWXhgcpYK27qxzx4cT3qDEpzgfs,XRP,12127,82200000,10438455,&quot;&quot;,&quot;&quot;,1,1418233370</code></pre><ul><li>transactions-in-USD-jan-2013-aug-2016.txt: Transactions performed in Ripple with known currencies.<ul><li>(tx_hash, sdr, rcv, USD_amount, unix_timestamp) </li></ul></li></ul><pre><code>176FCFC0A4607B82DDC0847BA0C101858296238226F94DE4F7DF5DB4DD7C0C08 r5ymZSvtdNgbKVc8ay1Jhmq5f9QgnvEtj rGaRDdFcp1gZSrfuifZWiVLKq2SbaVRnuJ 353.6667023 1418016770</code></pre><h3 id="ripple-data-jan29"><a href="#ripple-data-jan29" class="headerlink" title="ripple-data-jan29"></a>ripple-data-jan29</h3><ul><li>all-in-USD-trust-lines-2013-jan.txt:<ul><li> It contains the credit links between nodes that existed in the Ripple network in Jan 2013. Only credit links in a currency described in the file currency-exchanges-2016-nov-7.txt have been considered.</li><li>(acc1 acc2 lower_bound current_balance upper_bound)   (all values are in USD)</li></ul></li></ul><pre><code>rM1oqKtfh1zgjdAgbFmaRm3btfGBX25xVo rnziParaNb8nsU4aruQdwYE3j5jUcqjzFm 723.23 0.0 0.0rwpRq4gQrb58N7PRJwYEQaoSui6Xd3FC7j rhxbkK9jGqPVLZSWPvCEmmf15xHBfJfCEy 0.0 0.0 23866.59</code></pre><ul><li>links-created-in-USD-jan-2013-dec-2016.txt: <ul><li>It cointains the credit links created from January 2013 until December 2013.</li><li>(acc1 acc2 value date) —— It means that there is a link from acc1 to acc2 with an upper limit of value (in USD) and it was created in date.</li></ul></li></ul><pre><code>rhub8VRN55s94qWKDv6jmDy1pUykJzF3wq rLiCWKQNUs8CQ81m2rBoFjshuVJviSRoaJ 1100000000.0 2016-09-15T16:19:01+00:00rM1oqKtfh1zgjdAgbFmaRm3btfGBX25xVo r9Gps6fB9YLuZ87rWx7M9TgLAGK2zsz5s6 7.2323e+11 2016-10-10T02:43:41+00:00</code></pre><ul><li>ripple-graph-jan-2013.txt: Crawled Ripple graph</li></ul><pre><code>&#123;&quot;result&quot;:&#123;&quot;account&quot;:&quot;rBKPS4oLSaV2KVVuHH8EpQqMGgGefGFQs7&quot;,&quot;ledger_hash&quot;:&quot;EA814084C248A6D4D5AADC82897810D819DC936C187366E127162FE15E60D834&quot;,&quot;ledger_index&quot;:91211,&quot;lines&quot;:[&#123;&quot;account&quot;:&quot;rJRyob8LPaA3twGEQDPU2gXevWhpSgD8S6&quot;,&quot;balance&quot;:&quot;-6&quot;,&quot;currency&quot;:&quot;USD&quot;,&quot;limit&quot;:&quot;0&quot;,&quot;limit_peer&quot;:&quot;7&quot;,&quot;quality_in&quot;:0,&quot;quality_out&quot;:0&#125;,&#123;&quot;account&quot;:&quot;rnGTwRTacmqZZBwPB6rh3H1W4GoTZCQtNA&quot;,&quot;balance&quot;:&quot;-7&quot;,&quot;currency&quot;:&quot;USD&quot;,&quot;limit&quot;:&quot;0&quot;,&quot;limit_peer&quot;:&quot;3&quot;,&quot;quality_in&quot;:0,&quot;quality_out&quot;:0&#125;],&quot;validated&quot;:true&#125;,&quot;status&quot;:&quot;success&quot;,&quot;type&quot;:&quot;response&quot;&#125;</code></pre><ul><li>trust-set-transactions.txt: Crawled create link transactions from Jan 2013 until Dec 2016</li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文相关总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> speedymurmurs </tag>
            
            <tag> payment routing </tag>
            
            <tag> 路由算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊DApp</title>
      <link href="/2019/10/26/%E4%BB%A5%E5%A4%AA%E5%9D%8ADApp/"/>
      <url>/2019/10/26/%E4%BB%A5%E5%A4%AA%E5%9D%8ADApp/</url>
      
        <content type="html"><![CDATA[<h2 id="Web开发者视角下解释以太坊"><a href="#Web开发者视角下解释以太坊" class="headerlink" title="Web开发者视角下解释以太坊"></a><a href="https://medium.com/@mvmurthy/ethereum-for-web-developers-890be23d1d0c">Web开发者视角下解释以太坊</a></h2><h3 id="web-App-在客户端-服务器架构下的工作原理"><a href="#web-App-在客户端-服务器架构下的工作原理" class="headerlink" title="web App 在客户端-服务器架构下的工作原理"></a>web App 在客户端-服务器架构下的工作原理</h3><p>如图 webApp</p><p><img src="https://i.loli.net/2019/10/26/GaObWcxqQBFyIDE.png" alt="webApp.png"></p><ul><li>web应用程序托管在主机提供商上</li><li>客户端（可以是浏览器、使用服务的另一个 api 等）向服务器发出请求</li><li>当客户机向服务器发出请求时，服务器执行它的操作，与数据库和/或缓存通信，读取/写入/更新数据库并为客户机服务</li><li>比如闲鱼，外卖，淘宝？提供了一个安全可信的中间商平台，商家和买家其实都要为其服务支付费用</li></ul><p>如果：每个人都能公开且安全地访问数据库，不必依赖这个 webapp 所有者来获取数据，可以节省佣金，也可以访问你的所有数据  ——  分布式 Dapps</p><h3 id="以太坊-Dapp-的架构"><a href="#以太坊-Dapp-的架构" class="headerlink" title="以太坊 Dapp 的架构"></a>以太坊 Dapp 的架构</h3><p>如图：ethereumDapp</p><p><img src="https://i.loli.net/2019/10/26/r8UEeV4cWCXZvTw.png" alt="ethereumDapp.png"></p><ul><li>每个客户机(浏览器)都与自己的应用程序实例进行通信</li><li>在使用应用程序之前，必须下载整个区块链</li></ul><h3 id="以太坊是什么？"><a href="#以太坊是什么？" class="headerlink" title="以太坊是什么？"></a>以太坊是什么？</h3><ol><li>数据库（Database）：存储数据；交易，区块</li><li>代码（code）：具体应用的逻辑，买、卖、取消，退款等，需要编写应用层代码，即合约。将合约编译成以太坊字节码，将字节码部署在区块链上。</li></ol><p>因此，以太坊存储你的数据，存储代码，并在 EVM 中执行代码。</p><p>web3.js 是一个 JavaScript 库，用来连接以太坊节点。将这个库包含（include）进 js 框架中，即可开始构建。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ethereum </tag>
            
            <tag> DApp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链中的一些常用名词解释</title>
      <link href="/2019/10/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
      <url>/2019/10/26/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><h3 id="以太坊网络中的“DoS”攻击"><a href="#以太坊网络中的“DoS”攻击" class="headerlink" title="以太坊网络中的“DoS”攻击"></a>以太坊网络中的“DoS”攻击</h3><blockquote><p> What is a “DoS” of the Ethereum network?</p><p>A denial of service (DoS) incident on the Ethereum network happens when there are consistently full blocks and many pending transactions on the network.  Recall that miners can choose to include transactions based on the transaction fee attached. If there are hundreds of thousands of transaction in queue (or as it is technically termed, the transaction pool) it can cause unusual transaction delays of hours. DDoS incidents can be <strong>malicious</strong> or <strong>non-malicious.</strong></p></blockquote><p>网络中持续存在满的区块和许多待打包交易。交易的不寻常延迟。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊智能合约实践</title>
      <link href="/2019/10/25/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/10/25/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>接着上一节，<a href="%5Bhttps://haiki.github.io/2019/10/19/%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/%5D(https://haiki.github.io/2019/10/19/%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/)">从头搭建以太坊私链</a>。试着编写简单的智能合约，并在已经搭建好的链上部署。</p><p>具体参考 <a href="https://www.zhihu.com/people/li-kang-65/posts">李康</a> 的知乎内容。</p><h3 id="使用-Remix-编译合约"><a href="#使用-Remix-编译合约" class="headerlink" title="使用 Remix 编译合约"></a>使用 <a href="https://remix.ethereum.org/">Remix</a> 编译合约</h3><p>编写简单的测试合约</p><pre><code class="solidity">pragma solidity ^0.4.8;contract Test&#123;    uint256 public value;    function Test()&#123;        value = 123;    &#125;&#125;</code></pre><p>选择与合约版本对应的编译器，同时可以选择下面的 开启优化（Enable optimization），这个选项针对于比较大型的合约，对gas之类消耗比较大的情况会很有用。</p><p><img src="https://i.loli.net/2019/10/25/Sgdnjp5wZ3mWIR9.jpg" alt="compiler.JPG"></p><p>编译成功之后，向下拉上图，可以看到 compilation details。点击则可以看到一些详细信息。</p><p><img src="https://i.loli.net/2019/10/25/64HYaAMhw8FDpIn.jpg" alt="compilationDetails.JPG"></p><p>geth1 的控制台下操作如下：</p><p><img src="https://i.loli.net/2019/10/25/xOyVQvibYW6zSNm.jpg" alt="deployContract.JPG"></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/26789825">李康</a> ：我们在部署智能合约时使用的 data 字段是 Bytecode 而不是 Runtime Bytecode，这是因为以太坊上的节点收到合约部署交易时，运行 data 指定的字节码，执行完毕后返回的代码才是真正的合约代码，即 Runtime Bytecode。</p></blockquote><p>也就是说，红框内的 <code>data</code> 字段，是 Bytecode，黄框内的 <code>data</code>，是 Runtime Bytecode。合约的地址是蓝框内的。</p><hr><ul><li><p>对于有参数的智能合约，部署时，需要对参数进行填写！</p></li><li><p>对于下次使用合约，首先得到合约本身，然后 用 <code>.at(address)</code>，而不需要用 <code>new</code> ！</p></li><li><p>对于部署上去的合约，比如上图的 <code>test</code>实例，可直接键入 <code>test.address</code>从而查看合约的地址，键入 <code>test</code> 即可用 <code>json</code>  串的形式，返回 <code>ABI</code>，可以更清晰的去看此合约的接口，参数之类的，还有合约的地址，部署合约返回的交易散列。</p></li><li><p>合约调用常用命令：</p></li></ul><pre><code>eth.getTransactionReceipt(txHash)test.Test(para,...,&#123;from:eth.accounts[0],gas:30000,gasPrice:3,value:&#125;)</code></pre><h5 id="编写-资产聚合与分散合约时遇到的solidity语法问题"><a href="#编写-资产聚合与分散合约时遇到的solidity语法问题" class="headerlink" title="编写 资产聚合与分散合约时遇到的solidity语法问题"></a>编写 资产聚合与分散合约时遇到的solidity语法问题</h5><ul><li><p>字符串的操作库（0.4.x版本）：<a href="https://github.com/Arachnid/solidity-stringutils">https://github.com/Arachnid/solidity-stringutils</a></p><ul><li>（0.5.0版本）：<a href="https://github.com/tokencard/contracts/blob/master/contracts/externals/strings.sol">https://github.com/tokencard/contracts/blob/master/contracts/externals/strings.sol</a></li><li><a href="https://github.com/Arachnid/solidity-stringutils#concatenating-strings">https://github.com/Arachnid/solidity-stringutils#concatenating-strings</a></li></ul></li><li><p>『0016』 - Solidity Types - 玩转 Solidity 数组 （Arrays）：<a href="https://blog.csdn.net/liyuechun520/article/details/78410733">https://blog.csdn.net/liyuechun520/article/details/78410733</a></p></li><li><p>URL的API ：<a href="https://ropsten.etherscan.io/apis#transactions">https://ropsten.etherscan.io/apis#transactions</a></p></li><li><p>Solidity的Using for的使用：<a href="https://blog.csdn.net/qq_33764491/article/details/80604887">https://blog.csdn.net/qq_33764491/article/details/80604887</a></p></li><li><p>library</p></li><li><p>以太坊交易源码分析：<a href="https://blog.csdn.net/TurkeyCock/article/details/80485391">https://blog.csdn.net/TurkeyCock/article/details/80485391</a></p></li></ul><ul><li>go 和 solidity的类型对应关系 <a href="https://islishude.github.io/blog/2019/06/29/blockchain/%E4%BD%BF%E7%94%A8-Go-%E8%BF%9B%E8%A1%8C-Solidity-ABI-%E7%BC%96%E8%A7%A3%E7%A0%81/">https://islishude.github.io/blog/2019/06/29/blockchain/%E4%BD%BF%E7%94%A8-Go-%E8%BF%9B%E8%A1%8C-Solidity-ABI-%E7%BC%96%E8%A7%A3%E7%A0%81/</a></li><li>交易签名的过程：<a href="https://ethereum.iethpay.com/how-to-sign-and-hash-tx.html">https://ethereum.iethpay.com/how-to-sign-and-hash-tx.html</a></li><li>交易签名以及哈希值的计算：<a href="https://ethereum.iethpay.com/how-to-sign-and-hash-tx.html">https://ethereum.iethpay.com/how-to-sign-and-hash-tx.html</a></li><li>以太坊上的交易：<a href="https://ethfans.org/posts/the-business-of-sending-transactions-on-ethereum">https://ethfans.org/posts/the-business-of-sending-transactions-on-ethereum</a></li></ul><ul><li><p><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">Elliptic Curve Cryptography: a gentle introduction</a><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/</a></p></li><li><p><a href="https://ethereum.stackexchange.com/questions/25601/what-is-the-difference-between-web3-eth-sign-web3-eth-accounts-sign-web3-eth-p">What is the difference between web3.eth.sign, web3.eth.accounts.sign, web3.eth.personal.sign functions?</a></p></li><li><p>以太坊上发送交易的九种办法：<a href="https://ethfans.org/posts/the-business-of-sending-transactions-on-ethereum">https://ethfans.org/posts/the-business-of-sending-transactions-on-ethereum</a></p></li><li><p>What are ABI encoding functions in Solidity 0.4.24?：<a href="https://medium.com/@libertylocked/what-are-abi-encoding-functions-in-solidity-0-4-24-c1a90b5ddce8">https://medium.com/@libertylocked/what-are-abi-encoding-functions-in-solidity-0-4-24-c1a90b5ddce8</a></p><ul><li>abi.encode() returns (bytes)</li><li>abi.encodePacked() returns (bytes)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> solidity </tag>
            
            <tag> 智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊概念及API的整合与理解</title>
      <link href="/2019/10/22/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E5%BF%B5%E5%8F%8AAPI%E7%9A%84%E6%95%B4%E5%90%88%E4%B8%8E%E7%90%86%E8%A7%A3/"/>
      <url>/2019/10/22/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E5%BF%B5%E5%8F%8AAPI%E7%9A%84%E6%95%B4%E5%90%88%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Ethereum-Readme"><a href="#Ethereum-Readme" class="headerlink" title="Ethereum Readme"></a>Ethereum Readme</h2><h3 id="Executables"><a href="#Executables" class="headerlink" title="Executables"></a>Executables</h3><p>go-ethereum 项目的<code>cmd</code>文件夹下，有很多包装器/可执行文件</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>geth</td><td>主要的以太坊命令行接口（CLI）客户端，可运行全节点等类型节点。它可以被其他进程用作网关，通过暴露在HTTP，WebSocket和 IPC 传输之上的 JSON RPC 端点进入以太坊网络。</td></tr><tr><td>abigen</td><td></td></tr><tr><td>bootnode</td><td>以太坊客户端实现的精简版，只加入网络的节点发现协议，不运行其他的更高层应用层协议。可作为轻量级启动节点，协助私有网络中的节点发现。</td></tr><tr><td>evm</td><td>开发实用工具</td></tr><tr><td>gethrpctest</td><td>开发实用工具</td></tr><tr><td>rlpdump</td><td>开发实用工具</td></tr><tr><td>puppeth</td><td>CLI向导程序，帮助创建新的以太坊网络</td></tr></tbody></table><h3 id="Running-geth"><a href="#Running-geth" class="headerlink" title="Running geth"></a>Running <code>geth</code></h3><p>命令行标记：<a href="https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options">Command Line Options</a></p><p><code>geth [options] command [command options] [arguments...]</code></p><pre><code>ETHEREUM OPTIONS:LIGHT CLIENT OPTIONS:DEVELOPER CHAIN OPTIONS:ETHASH OPTIONS:TRANSACTION POOL OPTIONS:PERFORMANCE TUNING OPTIONS:ACCOUNT OPTIONS:API AND CONSOLE OPTIONS:NETWORKING OPTIONS:MINER OPTIONS:GAS PRICE ORACLE OPTIONS:VIRTUAL MACHINE OPTIONS:LOGGING AND DEBUGGING OPTIONS:METRICS AND STATS OPTIONS:WHISPER (EXPERIMENTAL) OPTIONS:DEPRECATED OPTIONS:MISC OPTIONS:</code></pre><p><code>geth console</code>命令 ：1）以 fast sync 模式开启 <code>geth</code>；2）启动 <code>geth</code>内建的  <a href="https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console">JavaScript console</a> （通过 <code>console</code> 子命令），调用所有的官方的 web3 methods <a href="https://github.com/ethereum/wiki/wiki/JavaScript-API">JavaScript API</a> 和 <code>geth</code> 本身的 <a href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs">management APIs</a> 。<code>console</code> 是可选项，不写时会 <code>attach</code> 到一个正在运行的 <code>geth</code> 实例（默认是生产节点），即 <code>geth attach</code>。</p><hr><h3 id="JavaScript-console"><a href="#JavaScript-console" class="headerlink" title="JavaScript console"></a><a href="https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console">JavaScript console</a></h3><ul><li><p>以太坊提供了一个  <strong>javascript runtime environment</strong> (JSRE)，可用在交互式（console）或 非交互式（script）模式。 Javascript console 暴露了所有的 web3 Javascript Dapp API( <a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethcall">JavaScript API</a> )和 admin API ( <a href="https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console#javascript-console-api">JavaScript Console</a> )</p></li><li><p>交互式应用，the JSRE REPL Console（<strong>Read, Evaluate &amp; Print Loop</strong>）：</p><ul><li><p><code>geth console</code> ： 开启 geth 节点，并打开控制台</p></li><li><p> <code>geth attach</code>：打开正在运行的 geth 实例的控制台 </p></li></ul></li><li><p>geth 节点在非默认的 ipc 端点下运行，则可以通过 rpc 接口连接</p></li><li><p>note：默认情况下 geth 开启时不启动 http 和 ws 服务，没有提供完整接口</p><pre><code>- `$ geth attach ipc:/some/custom/path `-  `$ geth attach http://191.168.1.1:8545`        -  `$ geth attach ws://191.168.1.1:8546 `</code></pre><ul><li>记录日志信息，不在控制台上打印内容： <code>$ geth --verbosity 5 console 2&gt;&gt; /tmp/eth.log</code></li><li>加载自定义 JavaScript 文件（加载常用函数，设置web3 合约对象）： <code>geth --preload &quot;/my/scripts/folder/utils.js,/my/scripts/folder/contracts.js&quot; console</code></li></ul></li><li><p>交互式应用：JSRE script mode</p><ul><li>还可以向JavaScript解释器执行文件。某种复杂形式：<code>$ geth --jspath &quot;/tmp&quot; --exec &#39;loadScript(&quot;checkbalances.js&quot;)&#39; attach http://123.123.123.123:8545</code></li></ul></li></ul><h3 id="JavaScript-API"><a href="#JavaScript-API" class="headerlink" title="JavaScript API"></a><a href="https://github.com/ethereum/wiki/wiki/JavaScript-API">JavaScript API</a></h3><p>要使应用程序在 Ethereum上 工作，可以使用 web3.js 库提供的 web3 对象。在底层，它通过RPC调用与本地节点通信。web3.js 处理任何暴露 RPC 层的 Ethereum 节点。web3 包含 <code>eth</code>对象（<code>web3.eth</code> 与以太坊区块链的交互），<code>ssh</code>对象（<code>web3.ssh</code> 与Whisper 的交互），<code>net</code>  <code>db</code> <code>ssh</code>。</p><ul><li>Adding web3</li><li>Using callbacks：本协议是与本地的 RPC 节点工作，它的所有功能默认使用同步的 HTTP 请求。</li><li>Batch requests</li><li>A note on big numbers in web3.js<ul><li>浮点数建议小数部分是 20位，所以 <code>balance</code> 一般都建议用 <code>Wei</code>，在给用户展示的时候再转换为 <code>ether</code>。</li></ul></li></ul><h3 id="management-APIs"><a href="#management-APIs" class="headerlink" title="management APIs"></a><a href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs">management APIs</a></h3><h4 id="Enabling-the-management-APIs"><a href="#Enabling-the-management-APIs" class="headerlink" title="Enabling the management APIs"></a>Enabling the management APIs</h4><p>要通过 Geth RPC 端点提供这些 api，需要用命令 <code>--$&#123;interface&#125;api</code> 命令行参数， <code>--$&#123;interface&#125;</code>可以是 <code>rpc,ws,ipc</code>。</p><p><code>geth --ipcapi admin,eth,miner --rpcapi eth,web3 --rpc</code></p><ul><li>在 IPC 接口上启用 admin、官方 DAp p和 miner API；</li><li>通过 HTTP 接口启用 官方的DApp 和 web3 API；</li><li>必须使用 <code>--rpc</code> 标志显式地启用 HTTP RPC 接口</li></ul><h4 id="List-of-management-APIs"><a href="#List-of-management-APIs" class="headerlink" title="List of management APIs"></a>List of management APIs</h4><ul><li><code>admin</code>: Geth node management</li><li><code>debug</code>: Geth node debugging</li><li><code>miner</code>: Miner and <a href="https://github.com/ethereum/wiki/wiki/Ethash-DAG">DAG</a> management</li><li><code>personal</code>: Account management</li><li><code>txpool</code>: Transaction pool inspection</li></ul><p>见 managementAPI 图</p><p><img src="https://i.loli.net/2019/10/23/UJheoOLq7MBvzxI.jpg" alt="managementAPI.JPG"></p><hr><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><ul><li><p><code>geth</code> 后面的多个标记可以写在配置文件中，如  <code>$ geth --config /path/to/your_config.toml</code>。</p></li><li><p>查看配置文件的内容，可使用命令： <code>$ geth --your-favourite-flags dumpconfig</code> 导出已存的配置。</p></li><li><p>只在 geth v1.6.0 以上的版本使用。</p></li></ul><h4 id="Docker-quick-start"><a href="#Docker-quick-start" class="headerlink" title="Docker quick start"></a>Docker quick start</h4><p><code>--rpcaddr 0.0.0.0</code>：如果想从其他容器或者主机访问 RPC。默认情况下，<code>geth</code> 绑定到本地的接口和 RPC 端点，外部无法访问。</p><h4 id="Programmatically-interfacing（连接）-geth-nodes"><a href="#Programmatically-interfacing（连接）-geth-nodes" class="headerlink" title="Programmatically interfacing（连接） geth nodes"></a>Programmatically interfacing（连接） <code>geth</code> nodes</h4><p>通过自己的程序去连接 <code>geth</code> 和以太坊网络，而不是手动地用 <code>console</code> 。<code>geth</code> 内置了对基于JSON-RPC 的 api 的支持：标准的 APIs（<a href="https://github.com/ethereum/wiki/wiki/JSON-RPC">JSON RPC</a>）和 geth 特定的 APIs（<a href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs">Management APIs</a>）。可以通过 HTTP，WebSockets 和 IPC（基于 UNIX 平台的 UNIX 套接字，windows 上称作 pipes） 去暴露。</p><p>默认情况下，IPC 接口打开，暴露 <code>geth</code>支持的所有APIs，HTTP 和 WS 接口需要手动打开，只暴露一部分 APIs，可通过配置关闭或者打开。</p><p>使用自己的编程环境的功能(库、工具等)通过 HTTP、WS 或 IPC 连接到 geth 节点。需要在所有传输上使用 JSON-RPC。可以对多个请求重用相同的连接!</p><p>HTTP based JSON-RPC API options：</p><ul><li><code>--rpc</code> Enable the HTTP-RPC server</li><li><code>--rpcaddr</code> HTTP-RPC server listening interface (default: <code>localhost</code>)</li><li><code>--rpcport</code> HTTP-RPC server listening port (default: <code>8545</code>)</li><li><code>--rpcapi</code> API’s offered over the HTTP-RPC interface (default: <code>eth,net,web3</code>)</li><li><code>--rpccorsdomain</code> Comma separated list of domains from which to accept cross origin requests (browser enforced)<ul><li>参见：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a></li></ul></li></ul><h4 id="JSON-RPC"><a href="#JSON-RPC" class="headerlink" title="JSON RPC"></a><a href="https://github.com/ethereum/wiki/wiki/JSON-RPC">JSON RPC</a></h4>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> API </tag>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从头搭建以太坊私链</title>
      <link href="/2019/10/19/%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/"/>
      <url>/2019/10/19/%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h3 id="安装geth-通过源码编译安装"><a href="#安装geth-通过源码编译安装" class="headerlink" title="安装geth -通过源码编译安装"></a>安装geth -通过源码编译安装</h3><p>参考<a href="https://media.consensys.net/how-to-build-a-private-ethereum-blockchain-fbf3904f337">这个</a>文档</p><ol><li><p><code>[haiki@localhost ~]$ mkdir ethereum</code></p></li><li><p><code>[haiki@localhost ~]$ cd ethereum</code></p></li><li><p><code>[haiki@localhost ethereum]$ git clone https://github.com/ethereum/go-ethereum.git </code></p></li><li><p><code>cd go-ethereum</code></p></li><li><p><code>make geth</code> 进行编译，得到可执行程序，得到编译结尾如下图，则表示编译成功。</p><p><img src="https://i.loli.net/2019/10/19/xMKDnI1kmlCSZNR.jpg" alt="makeGrth.JPG"></p></li><li><p>按照上图提示，需要在执行make的当前目录下执行 <code>./build/bin/geth</code>去安装 geth。此时，我所在的目录是 <code>/home/haiki/ethereum/go-ethereum</code>，如果已经进入到了 <code>/home/haiki/ethereum/go-ethereum/build/bin</code>，可以直接 <code>./geth</code>进行安装。其中，加 <code>./</code> 表示执行当前目录下的 geth 可执行文件。</p></li><li><p>现在，相当于 <code>/home/haiki/ethereum/go-ethereum/build/bin</code>目录下已经有了geth 这个可执行程序，相当于 windows 下的 .exe程序，在这个 bin 目录下，执行 <code>geth version</code>，查看安装是否成功，出现下图，则成功。</p><p><img src="https://i.loli.net/2019/10/19/ZGx3cWEPrCjQnYH.jpg" alt="gethVersion.JPG"></p></li><li><p>如果要使用这个程序，那么需要总是把geth所在的路径包含上，这时候，可以设置一个全局的环境变量，在哪里都可以执行用geth命令。</p><ol><li><code>vim /home/haiki/.bashrc</code></li><li><code>export GETHPATH=/home/haiki/ethereum/go-ethereum/build</code>，在原来的  <code>PATH</code>上加一个 <code>geth</code> 的路径： <code>export PATH=$GOPATH/bin:$GOROOT/bin:$PATH:$GETHPATH/bin</code></li><li>此时，在任何目录下（不必须是 <code>geth</code> 所在的目录下），执行 <code>geth version</code>都可以出现上图的结果。</li></ol></li></ol><h3 id="geth的使用"><a href="#geth的使用" class="headerlink" title="geth的使用"></a>geth的使用</h3><ol><li><p>创建账户</p><ol><li><p><code>[haiki@localhost ~]$ geth --datadir /home/haiki/ethereum/pqgeth account new</code>，按照提示，输入密码（这里是123456）。这个密码不能忘记，忘记没有找回选项。</p></li><li><p>此时在 <code>pqgeth</code> 下会生成一个 <code>keystore</code>文件，其中保存着生成的以太坊地址及用密码加密的私钥；如果不用 <code>--datadir</code> 参数，默认在用户空间的家目录（如/home/haiki）下生成 <code>.ethereum</code>文件（可以用 <code>ls -al</code> 查看），并在里面生成 <code>keystroe</code>文件。</p></li><li><p>按照屏幕显示的结果，即gethAccountNew图，可以知道，得到的地址，密钥文件的存放路径，以及一些安全提示信息。</p><p><img src="https://i.loli.net/2019/10/21/2bstUBRHALoW6Z1.jpg" alt="gethAccountNew.JPG"></p></li><li><p>可以按照相同的方式生成多个账户地址。</p></li></ol></li><li><p>定制私链的创世区块文件：见<a href="https://github.com/ethereum/go-ethereum/blob/master/README.md">官网</a></p><ol><li><p>编写 <code>genesis.json</code> 文件，这条链上的所有的节点都必须知晓这个文件，并达成共识。其中 <code>alloc</code>字段是预先分配有钱的账户，方便后序测试，例如转账这种。其中，chainId用来标识当前是哪条链，可以是任意正整数，network 默认是1，是一个网络。</p><pre><code>&#123;&quot;config&quot;: &#123;    &quot;chainId&quot;: 17,    &quot;homesteadBlock&quot;: 0,    &quot;eip150Block&quot;: 0,    &quot;eip155Block&quot;: 0,    &quot;eip158Block&quot;: 0,    &quot;byzantiumBlock&quot;: 0,    &quot;constantinopleBlock&quot;: 0,    &quot;petersburgBlock&quot;: 0  &#125;,  &quot;alloc&quot;: &#123;        &quot;d1f506b11eb311f955a208962905a526268babc6&quot;: &#123;                &quot;balance&quot;: &quot;100000000&quot;                &#125;        &#125;,  &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;,  &quot;difficulty&quot;: &quot;0x20000&quot;,  &quot;extraData&quot;: &quot;&quot;,  &quot;gasLimit&quot;: &quot;0x2f</code></pre></li><li><p>启动并初始化每个 <code>geth</code> 节点，确保参数设置正确： <code>geth --datadir ~/ethereum/pqgeth/ init genesis.js</code>。如图 genesis1。</p><p><img src="https://i.loli.net/2019/10/21/ygbG7d9CIJY8vo2.jpg" alt="genesis1.JPG"></p><ul><li>此时在 <code>datadir</code>目录下会生成一个 <code>geth</code>文件夹，包含 <code>chaindata</code>，<code>lightchaindata</code></li><li>这时，其实就可以运行 <code>geth </code>啦。但是如果只运行 <code>geth</code>，不加任何参数的情况下，结果如 geth_console1 图、 geth_console2 图，geth_console3 图，此时运行 <code>admin.nodeInfo</code>，可得到 geth_nodeInfo 图，此时的 <code>chainID</code> 和 <code>network</code> 均为1，和我们在 <code>genesis.json</code> 中设置的 <code>chainId:17</code>不一致。？？？</li></ul><p><img src="https://i.loli.net/2019/10/21/VYsRA9S2e7jOnic.jpg" alt="geth_console1.JPG"></p><p><img src="https://i.loli.net/2019/10/21/WIKqwodlz3jkZCn.jpg" alt="geth_console2.JPG"></p><p><img src="https://i.loli.net/2019/10/21/Uqk48FeoMwIt9jL.jpg" alt="geth_console3.JPG"></p><p><img src="https://i.loli.net/2019/10/21/W54UJ1eSxZdjmXq.jpg" alt="geth_console_nodeInfo.JPG"></p></li><li><p>启动一个节点实例，可以根据需要写很多参数，参数详见 <a href="https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options">Command Line Options</a>，为了避免每次写很多参数，可以在家目录的 <code>.bashrc</code> 中（就是配置全局环境的那个地方）编写以下命令：</p><pre><code class="bash">alias geth1=&#39;geth --verbosity 6 --identity &quot;haiki&quot; --rpc --rpcport &quot;20000&quot; --rpcaddr 0.0.0.0 --allow-insecure-unlock --etherbase &quot;d1f506b11eb311f955a208962905a526268babc6&quot;  --rpccorsdomain &quot;*&quot; --datadir &quot;/home/haiki/ethereum/pqgeth&quot; --port &quot;40000&quot; --nodiscover   --rpcapi &quot;db,eth,net,web3&quot; --networkid 2000 --nat &quot;any&quot; console 2&gt;&gt; &quot;/home/haiki/ethereum/pqgeth/node1.log&quot;&#39;</code></pre><ul><li>这样可以使得每次只用 <code>geth1</code> 命令即可相当于后面那一大串命令，而且，执行命令的结果重定向并追加至  <code>&quot;/home/haiki/ethereum/pqgeth/node1.log&quot;</code> 文件中。</li><li>此时可以直接运行 <code>geth1</code>, 屏幕上会得到 geth1图的输出，再次运行 <code>admin.nodeInfo</code>，可得 geth_nodeInfo1 图，此时的 <code>chainID</code> 和 <code>network</code> 分别为 <code>genesis.json</code> 和 <code>.bashrc</code> 中设置的值。</li><li>–allow-insecure-unlock：<a href="https://blog.csdn.net/wo541075754/article/details/98847308">以太坊geth新版本error：account unlock with HTTP access is forbidden</a><br><img src="https://i.loli.net/2019/10/21/talkRKxiQDOrAHv.jpg" alt="geth1.JPG"><br><img src="https://i.loli.net/2019/10/21/bwFu4fJ5zHXyp1v.jpg" alt="geth_nodeInfo1.JPG"></li></ul></li></ol></li><li><p>运行一个矿工：从这里开始的部分可以参考：<a href="https://medium.com/coinmonks/ethereum-setting-up-a-private-blockchain-67bbb96cf4f1">搭建以太坊私链</a></p><ol><li>可以在 <code>geth</code>命令后加选项 <code>--mine --minerthreads 1</code>，这样在启动 <code>geth</code> 时，则就说明会一直挖矿，但这样做使得有很多空块，占用内存，所以为了测试需要，一般用方法2；</li><li><code>geth1</code>，启动节点，控制台下输入 <code>miner.start(1)</code>，默认情况下是 <code>coinbase</code>节点挖矿，也可以用命令设置：<code>&gt;miner.setEtherbase(eth.coinbase)</code>。 不用挖矿时 <code>miner.stop()</code>；没有交易时挖出空块，也可以有奖励，有收入。这里可能遇到的问题：<a href="https://blog.csdn.net/tianlongtc/article/details/80026561">解决miner.start() 返回null</a>   </li></ol></li><li><p>转账</p><ul><li>首先要对发送方账户进行解锁，<code>&gt; ac1 = eth.accounts[0]，&gt; personal.unlockAccount(ac1)</code>，此时要求输入密码。</li><li><code>&gt; eth.sendTransaction(&#123;&quot;from&quot;:ac1,&quot;to&quot;:ac2,&quot;value&quot;:10&#125;)</code> ，<code>value</code> 对应的单位是 <code>wei</code>， 如果想用 <code>ether</code>，可以用 <code>amount = web3.toWei(3,&#39;ether&#39;)</code>这种，把 <code>value</code> 的参数设置为 <code>amount</code>。这里要注意的是，参数的键值 <code>“from”,&quot;to&quot;,&quot;val&quot;</code> 需要用双引号引起来。</li><li>用 <code>eth.getBalance(ac2)</code> 查看转账是否到账，因为 <code>ac1</code> 一直在挖矿，其资金一直在上涨。当测试完成时，可以停止挖矿。其他命令的尝试和使用参见 <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#json-rpc-api">JSON RPC</a></li></ul></li><li><p>再启动一个节点，称作节点2，连接到已经搭建的区块链上</p><ol><li>新建一个存储节点信息，区块链信息，账户信息的文件夹，<code>mkdir ~/ethereum/go-ethereum/kkgeth</code></li><li>需要连接到第一个节点所在的区块链上，他们的创世块是一样的，这个节点也要初始化一下：<code> geth --datadir ~/ethereum/kkgeth/ init genesis.js</code>，注意这时用的 <code>datadir</code>。</li><li>和第一个节点做连接，则需要用到 <code>enode</code>，<code>enode</code> 的信息可以在运行的节点1中输入：<code>admin.nodeInfo.enode</code>得到。  这时候，要把 <code>geth1</code>中的 <code>----nodiscover</code> 去掉，让其他节点能够发现第一个节点。</li><li>和上面一样，开一个 <code>geth</code> 的实例<pre><code class="bash">alias geth2=&#39;geth --bootnodes enode://129265846efde605637ca4dee3e98e95cb466c386c64204bdedc84e98ff1e30d44e7e11e7fa6a561e8a3499acae31797da14749e3dab97af0fea682812f87b7f@127.0.0.1:40000 --verbosity 6 --identity &quot;pq&quot; --rpc --rpcport &quot;20001&quot; --rpcaddr 0.0.0.0  --allow-insecure-unlock --etherbase &quot;23b882359eed499a3b9cd06643c096e9ce048cfa&quot;  --rpccorsdomain &quot;*&quot; --datadir &quot;/home/haiki/ethereum/kkgeth&quot; --port &quot;40001&quot; --rpcapi &quot;db,eth,net,web3&quot; --networkid 2000 --nat &quot;any&quot; console 2&gt;&gt; &quot;/home/haiki/ethereum/kkgeth/node2.log&quot;&#39;</code></pre></li><li>运行 <code>geth2</code>，运行 <code>admin.addPeer(&#39;enode://129265846efde605637ca4dee3e98e95cb466c386c64204bdedc84e98ff1e30d44e7e11e7fa6a561e8a3499acae31797da14749e3dab97af0fea682812f87b7f@127.0.0.1:40000&#39;)</code> ，再输入 <code>net.peerCount</code> ，显示1，则表示已经连接到一个节点。可以用 <code>admin.peers</code> 查看当前连接到的节点信息，用 <code>net.peerCount </code> 查看网络中节点连接个数。这里有个奇怪现象，就是作为 bootnode 的那个节点，会连好多个节点。 在命令中只连接了一个节点，但是会显示其他的不知道哪里的节点。其他新增节点的命令可以看 ： <a href="https://www.netkiller.cn/blockchain/ethereum/faq.add.node.html">新增节点后不生效</a></li></ol></li></ol><h3 id="开启多个节点的脚本"><a href="#开启多个节点的脚本" class="headerlink" title="开启多个节点的脚本"></a>开启多个节点的脚本</h3><p>来自 <a href="https://victorjiangxin.github.io/">姜大佬</a> ，需要修改 端口base，地址什么的。</p><p>用法： <code>sh  startChain.sh  &lt;id&gt; </code> ，自动创建一条链，以及自动创建文件夹。如：<code>sh startChain.sh 1</code>。</p><pre><code class="shell">#!/usr/bin/shif [ &quot;&quot; = &quot;$1&quot; ];then    id=0else    id=$1firpcport_base=55000port_base=50000networkid=23333rpcport=$(($rpcport_base+$id))port=$(($port_base+$id))GETH_ROOT=&quot;$HOME/jx-eth&quot;datadir=&quot;$GETH_ROOT/data$id&quot;# judge if the chain has been initif [ ! -d $datadir ];then    if [ ! -f &quot;$GETH_ROOT/genesis.json&quot; ];then        echo &quot;Can&#39;t find genesis.json in dir $GETH_ROOT, plz re-create file gensis.json&quot;        exit 1    else        mkdir $datadir        geth --datadir $datadir init &quot;$GETH_ROOT/genesis.json&quot;    fifigeth --datadir $datadir --identity &quot;ETH-NODE$id&quot; --rpc --rpcport &quot;$rpcport&quot; --rpcaddr 0.0.0.0 --rpccorsdomain &quot;*&quot; --rpcapi &quot;personal,db,eth,net,web3&quot; --nodiscover --maxpeers 20 --networkid $networkid --port $port console</code></pre><p>tmux</p><p><a href="https://blog.csdn.net/Em_dark/article/details/82255248">linux 下安装npm和node</a></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> 私链 </tag>
            
            <tag> geth </tag>
            
            <tag> go环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>speedyMurmurs源码分析Dynamic部分</title>
      <link href="/2019/10/16/speedyMurmurs%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Dynamic%E9%83%A8%E5%88%86/"/>
      <url>/2019/10/16/speedyMurmurs%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Dynamic%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>Dynamic.class</p><pre><code class="java">&quot;SKIP_EXISTING_DATA_FOLDERS&quot;, &quot;false&quot;&quot;MAIN_DATA_FOLDER&quot;,&quot;./data/&quot;String path = &quot;../data/&quot;;@param args    0: run //使用第几组数据    1: config (0- SilentWhispers, 7- SpeedyMurmurs, 10-MaxFlow)    2: steps previously completed  if(step==0)&#123;    graph =  path+&quot;finalSets/dynamic/jan2013-lcc-t0.graph&quot;;//Number of Nodes:93502,Number of Edges: 331096    trans = path+&quot;finalSets/dynamic/jan2013-trans-lcc-noself-uniq-1.txt&quot;; &lt;四元组&gt;    newlinks = path+&quot;finalSets/dynamic/jan2013-newlinks-lcc-sorted-uniq-t0.txt&quot;;&lt;四元组&gt;&#125;//对于SW，参数分别表示：图数据，name，交易，新边，类型（SW/SM/Max），第几组数据case 0: runDynSWSM(new String[] &#123;graph, &quot;SW-P&quot;+(step+1),trans ,  newlinks, &quot;0&quot;, &quot;&quot;+run&#125;); break;//对于SMcase 7: runDynSWSM(new String[] &#123;graph, &quot;SM-P&quot;+(step+1), trans ,  newlinks, &quot;7&quot;, &quot;&quot;+run&#125;); break;//对于MaxFlowcase 10: runMaxFlow(graph, trans, &quot;M-P&quot;+(step+1), newlinks, 165.55245497208898*1000); break;</code></pre><pre><code class="java">runDynSWSM(String[] args)&quot;SERIES_GRAPH_WRITE&quot;, &quot;&quot;+true&quot;SKIP_EXISTING_DATA_FOLDERS&quot;, &quot;false&quot;graph,name,trans,add,type,iepoch = 165.55245497208898*1000;max = 1;//一笔交易的尝试次数就是1次dyn,multi//对于SW，分别是false，true，对于SM，分别是true，false    ra = new TreerouteSilentW();        ParameterList.key = &quot;TREE_ROUTE_TDRAP&quot;        ParameterList.parameters = new Parameter[0];        Treeroute.rand = new Random();    ra = new TreerouteTDRAP();        ParameterList.key = &quot;TREE_ROUTE_SILENTW&quot;         ParameterList.parameters = new Parameter[0];        Treeroute.rand = new Random();double req = 165.55245497208898*2;int[] roots = &#123;64,36,43&#125;;//直接给定下来了。。。Partitioner part = new RandomPartitioner();    Partitioner.name = &quot;RANDOM_PARTITIONER&quot;;    RandomPartitioner.rand = new Random();Network net = new ReadableFile(name, name,graph,null);</code></pre><pre><code class="java">//网络读取数据的参数//name = &quot;SW-P&quot;+(step+1)/&quot;SM-P&quot;+(step+1)/&quot;M-P&quot;+(step+1)Network net = new ReadableFile(name, name,graph,null);    ReadableFile.filename = graph;    ParameterList.key = &quot;READABLE_FILE_&quot; + name;    ParameterList.parameters = &#123;[&quot;NODES&quot;:93502]&#125;;    Network.node = 93502;    Network.transformations = new Transformation[0];</code></pre><pre><code class="java">//具体的ra算法CreditNetwork cred = new CreditNetwork(trans, name, epoch, ra, dyn, multi, req, part, roots, max, add);    public CreditNetwork(String file, String name, double epoch, Treeroute ra, boolean dynRep,             boolean multi, double requeueInt, Partitioner part, int[] roots, int max, String links)&#123;        this(file,name,epoch,ra,dynRep, multi, requeueInt, part, roots, max, links, true);    &#125;        ParameterList.key = &quot;CREDIT_NETWORK&quot;；        ParameterList.parameters = new Parameter[]&#123;new StringParameter(&quot;NAME&quot;, name),                 new DoubleParameter(&quot;EPOCH&quot;, epoch),                new StringParameter(&quot;RA&quot;, ra.getKey()),                 new BooleanParameter(&quot;DYN_REPAIR&quot;, dynRep),                 new BooleanParameter(&quot;MULTI&quot;, multi),                 new IntParameter(&quot;TREES&quot;, roots.length),                new DoubleParameter(&quot;REQUEUE_INTERVAL&quot;, requeueInt),                 new StringParameter(&quot;PARTITIONER&quot;, part.getName()),                new IntParameter(&quot;MAX_TRIES&quot;,max)&#125;);        CreditNetwork.epoch = epoch;        CreditNetwork.ra = ra;        CreditNetwork.multi = multi;        CreditNetwork.dynRepair = dynRep;        transactions = this.readList(file);        CreditNetwork.requeueInt = requeueInt;        CreditNetwork.part = part;        CreditNetwork.roots = roots;        CreditNetwork.maxTries = max;        if (links != null)&#123;            this.newLinks = this.readLinks(links);    //把新边信息存起来</code></pre>]]></content>
      
      
      <categories>
          
          <category> 论文相关总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> speedymurmurs </tag>
            
            <tag> payment routing </tag>
            
            <tag> 路由算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>speedyMurmurs源码分析</title>
      <link href="/2019/10/11/speedyMurmurs%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/10/11/speedyMurmurs%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>Static.main</p><h3 id="Config文件的读取"><a href="#Config文件的读取" class="headerlink" title="Config文件的读取"></a>Config文件的读取</h3><pre><code class="java">String defaultConfigFolder = &quot;./config/&quot;;Config.overwrite(String key, String value) &lt;speedy\src\gtna\util\Config.java&gt;    if properties == null  // Properties extends Hashtable&lt;Object,Object&gt;        Config.init() //将./config中的所有.properties文件内容加载到properties中；先得到./config下的文件夹绝对路径            Config.initWithFolders    //然后得到各文件夹下的.properties文件绝对路径                Config.initWithFiles //读取.properties文件                        Config.addFile                    Util.toStringArray(v)    //用来把存储在vector中的文件绝对路径转换成字符数组string[]    overwrite.put(key,val);// HashMap&lt;String, String&gt; overwrite;</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><pre><code class="java">@param args 0: run (integer 0-19)   //对应于20组交易数据， 1: config (0: LM-MUL-PER(SilentWhispers), 1: LM-RAND-PER, 2: LM-MUL-OND, 3:LM-RAND-OND, 4: GE-MUL-PER, 5: GE-RAND-PER, 6: GE-MUL-OND, 7:GE-RAND-OND (SpeedyMurmurs), 8: ONLY-MUL-PER, 9:ONLY-RAND-OND, 10: max flow)  2: #transaction attempts             //交易重新发送次数，跑的时候使用了2；对比实验是1-10 3: #embeddings/trees (integer &gt; 0)         //用了3；对比实验是1-7transList = &quot;../data/finalSets/static/sampleTr-&quot; + i + &quot;.txt&quot;; &lt;src,dst,val,time&gt;graph = &quot;../data/finalSets/static/ripple-lcc.graph&quot;;//&lt;节点：相邻节点1；相邻节点2...相邻节点n&gt;degFile = &quot;../data/finalSets/static/degOrder-bi.txt&quot;;//是排序的，每一行的数代表对应行度数的节点index&lt;度数为i的节点&gt;name = &quot;STATIC&quot;;    //实验名称epoch = 1000;    //每1000笔交易算一个epochtl = 2 * epoch;    //重试交易的时间间隔up = false; //无update</code></pre><pre><code class="java">//为不同树上的路径分配路由的资金数Partitioner part = new RandomPartitioner();    //实例化Partitioner    RandomPartitioner.rand =  new Random();    Partitioner.name = &quot;RANDOM_PARTITIONER&quot;;</code></pre><pre><code class="java">// 选择生成树的根节点// 其中，random表示随机选取root节点，当为false时，使用最大度的方法，即在degFile中选择前trees个节点。//如果使用随机，则使用i（当前是第几个run）作为随机种子初始化rand，之后遍历文件得到最大度，以最大度为界，随机出root（rand.nextInt）Misc.selectRoots(String file, boolean random, int trees, int seed)        Misc.selectRoots(degFile, random:false, trees, i)</code></pre><pre><code class="java">//实例化不同的路由算法RATreeroute sW = new TreerouteSilentW();    Metric.key = &quot;TREE_ROUTE_SILENTW&quot;;    Metric.parameters = new Parameter[0];    Treeroute.rand = new Random();    Treeroute voute = new TreerouteTDRAP();//TreerouteTDRAP继承TreerouteNH，TreerouteNH继承Treeroute    TreerouteNH        Metric.key = &quot;TREE_ROUTE_TDRAP&quot;;        Metric.parameters = new Parameter[0];        Treeroute.rand = new Random();            Treeroute only = new TreerouteOnly();    Metric.key = &quot;TREE_ROUTE_ONLY&quot;;    Metric.parameters = new Parameter[0];    Treeroute.rand = new Random();</code></pre><pre><code class="java">// 各种路由的参数组合实例化//vary dynRepair, multi, routing algo -&gt; 8 poss + 2 treeonly versions// String[] com = &#123; &quot;SW-PER-MUL&quot;, &quot;SW-PER&quot;, &quot;SW-DYN-MUL&quot;, &quot;SW-DYN&quot;, &quot;V-PER-MUL&quot;, &quot;V-PER&quot;, &quot;V-DYN-MUL&quot;, &quot;V-DYN&quot;, &quot;TREE-ONLY1&quot;, &quot;TREE-ONLY1&quot; &#125;;//三种不同的路由算法，使用不同的组合，实例化CreditNetwork    CreditNetwork silentW = new CreditNetwork(transList, name, epoch, sW, false, true, tl, part, roots, tries, up);     public CreditNetwork(String file, String name, double epoch, Treeroute ra, boolean dynRep,             boolean multi, double requeueInt, Partitioner part, int[] roots, int max, boolean up)&#123;        this(file,name,epoch,ra,dynRep, multi, requeueInt, part, roots, max, null,up);//调用本类中的重载函数    &#125;            public CreditNetwork(String file, String name, double epoch, Treeroute ra, boolean dynRep,                 boolean multi, double requeueInt, Partitioner part, int[] roots, int max, String links, boolean up)            Metric                ParameterList.key = &quot;CREDIT_NETWORK&quot;；                ParameterList.parameters = new Parameter[]&#123;                        new StringParameter(&quot;NAME&quot;, name),                         new DoubleParameter(&quot;EPOCH&quot;, epoch),                        new StringParameter(&quot;RA&quot;, ra.getKey()),                         new BooleanParameter(&quot;DYN_REPAIR&quot;, dynRep),                         new BooleanParameter(&quot;MULTI&quot;, multi),                         new IntParameter(&quot;TREES&quot;, roots.length),                        new DoubleParameter(&quot;REQUEUE_INTERVAL&quot;, requeueInt),                         new StringParameter(&quot;PARTITIONER&quot;, part.getName()),                        new IntParameter(&quot;MAX_TRIES&quot;,max)&#125;);</code></pre><pre><code class="java">//network实例化，加载图数据，节点个数，文件夹//Config.overwrite(&quot;READABLE_FILE_&quot; + folder + &quot;_NAME_SHORT&quot;, name); 初始化当前网络的名称// String[] com = &#123; &quot;SW-PER-MUL&quot;, &quot;SW-PER&quot;, &quot;SW-DYN-MUL&quot;, &quot;SW-DYN&quot;, &quot;V-PER-MUL&quot;, &quot;V-PER&quot;, &quot;V-DYN-MUL&quot;, &quot;V-DYN&quot;, &quot;TREE-ONLY1&quot;, &quot;TREE-ONLY1&quot; &#125;;Network network = new ReadableFile(com[config], com[config], graph, t:null);    public ReadableFile(String name, String folder, String filename,Transformation[] t)        this(name, folder, filename, new Parameter[0], t);        ReadableFile(String name, String folder, String filename, Parameter[] parameters, Transformation[] t)            ParameterList.key = &quot;READABLE_FILE_&quot; + folder;            ParameterList.parameters = new IntParameter(&quot;NODES&quot;, nodes);//这个nodes数是从graph中的第二行得到的67149            Network.nodes = nodes;            Network.transformations = transformations;//null</code></pre><pre><code class="java">//这里是整个程序真正的关键执行入口处，series的实例化//Metric[] m = new Metric[] &#123; silentW, silentWnoMul, silentWdyn, silentWdynNoMul, vouteMulnoDyn, voutenoDyn, vouteMul,voutenoMul, treeonly1, treeonly2 &#125;;Series.generate(network, new Metric[] &#123; m[config] &#125;, i, i);Series generate(Network nw, Metric[] metrics, int startRun,int endRun)        Series s = new Series(nw, metrics);        s.network = network;        s.metrics = metrics;        s.mainDataFolder = Config.get(&quot;MAIN_DATA_FOLDER&quot;);//生成数据的文件夹，./data/static/，这个在config文件中是./data，但是程序运行一开始就overwrite成./data/static了    folder.mkdirs();    //older = new File(s.getFolder());生成 ./data/static/READABLE_FILE_SW-PER-MUL-67149/，用的是network对象    folder.mkdirs();    //folder = new File(s.getFolder(m)); 由metric对象，得到文件名称 &quot;CREDIT_NETWORK-9个参数&quot;，见CreditNetwork        Series.generateRun(s, run);</code></pre><pre><code class="java">//创建文件夹，图数据读取Series.generateRun(s, run);        System.out.println(&quot;\n&quot; + run + &quot;:&quot;);    ArrayList&lt;Single&gt; runtimes = new ArrayList&lt;Single&gt;();    ArrayList&lt;Single&gt; etc = new ArrayList&lt;Single&gt;();    File folder = new File(s.getSeriesFolderRun(run));//这里得到的folder应该是./data/static/READABLE_XXX_/0...19    输出：G: SW-PER-MUL(N = 67149)//使用timer输出的一段话，记录图生成时间，意指graph or generate    Graph g = s.getNetwork().generate();//ReadableFile,生成图，ripple-lcc.graph中有节点和边的信息了，这里需要用ripple-lcc-CREDIT_LINKS.graph加载权重信息，即添加图的properties        ReadableFile.generate();            Graph graph = new GtnaGraphReader().readWithProperties(this.filename);//filename是graph的绝对路径，这里是读取creditlinks的权值信息                readWithProperties(filename, properties);//GraphReader.java; properties是ripple-lcc-CREDIT_LINKS.graph的绝对路径                    GraphProperty property = (GraphProperty) ClassLoader.getSystemClassLoader().loadClass(className).newInstance();//感觉是CreditLink类的实例化                    String key = property.read(prop);// CreditLinks.read(filename);//将所有的权值信息保存在CreditLink.weights中，并返回key值CREDIT_LINKS                    graph.addProperty(key, property);//key = REDIT_LINKS，即ripple-lcc-CREDIT_LINKS.graph中的key            graph.setName(this.getDescription());                Graph.name = ???    runtimes.add(new Single(&quot;G_RUNTIME&quot;, timer.getRuntime()));//./data/static/READABLE_V-ROUTE_67149/0...19/runtime.txt：G_RUNTIME=0.54    输出：P: CREDIT_LINKS//意指 properties    folder = new File(s.getMetricFolder(run, m));//folder.mkdirs();//CREDIT_NETWORK-STATIC-1000.0-TREE_ROUTE_SILENTW-false-true-3-2000.0-RANDOM_PARTITIONER-2    输出：M：CNET(name=STATIC,epoch=1000,ra-Tree=XXX,dr=XX,mul=XX,trees=X,ri=XX,part=XXX,mt=XX)    m.computeData(g, s.getNetwork(), metrics);    runtimes.add(new Single(m.getRuntimeSingleName(), timer.getRuntime()));//runtime.txt:CREDIT_NETWORK-STATIC-1000.0-TREE_ROUTE_SILENTW-false-true-1-2000.0-RANDOM_PARTITIONER-2_RUNTIME=86.41    m.writeData(s.getMetricFolder(run, m));//CreditNetwork.java;把生成的结果数据写入文件夹；folder是CREDIT_NETWORK-STATIC-1000.0-TREE_ROUTE_SILENTW-false-true-3-2000.0-RANDOM_PARTITIONER-2下的各个.txt文件    SingleList singleList = new SingleList(m, m.getSingles());//this.metric = metric; this.singles = singles;this.map = new HashMap&lt;String, Single&gt;();        m.getSingles()；//得到每个single            return new Single[]&#123;m_av, m_Re_av, m_S_av, m_F_av,p_av, p_Re_av, p_S_av, p_F_av, reL_av, ls_av, s_av, s1, s, pP_av, pPF_av, pPNF_av, rt,d1,d2,d3&#125;;    singleList.write(s.getSinglesFilenameRun(run, m));//写入_singles.txt文件    SingleList rt = new SingleList(null, runtimes);    rt.write(s.getRuntimesFilenameRun(run));// runtimes.txt 文件写入    //etc文件写入    int mb = 1024 * 1024;    Runtime runtime = Runtime.getRuntime();    double used = (runtime.totalMemory() - runtime.freeMemory()) / mb;    etc.add(new Single(&quot;MEMORY_USED&quot;, used));    SingleList etcSl = new SingleList(null, etc);    etcSl.write(s.getEtcFilename(run));</code></pre><pre><code class="java">//路由，执行交易，统计各项数据m.computeData(g, s.getNetwork(), metrics);    Treeembedding embed = new Treeembedding(&quot;T&quot;,60,roots, MultipleSpanningTree.Direct.TWOPHASE);&#123;        this(name,pad,roots.length,turnSelector(roots),1,false, dir);    &#125;        Treeembedding(String name, int pad, int k, String rootSelector, double p, boolean depth, MultipleSpanningTree.Direct dir)            ParameterList.key = &quot;TREE_EMBEDDING&quot;;        ParameterList.parameters = new Parameter[]&#123;                    new StringParameter(&quot;NAME&quot;, name), //&quot;T&quot;                    new IntParameter(&quot;PAD&quot;, pad),                     new IntParameter(&quot;TREES&quot;,k),                     new StringParameter(&quot;ROOT&quot;,rootSelector),//就是把root的索引拼接起来，1-2-3这样                    new DoubleParameter(&quot;P&quot;,p), //1                    new BooleanParameter(&quot;DEPTH&quot;, depth), //false                    new StringParameter(&quot;PARENT_DIR&quot;,dir.name())&#125;//TWOPHASE        Transformation.times = 1;        Treeembedding.padding = pad;        Treeembedding.trees = k;        rand = new Random();        Treeembedding.rootSelector = rootSelector;        Treeembedding.p = p;        Treeembedding.depth = depth;        Treeembedding.dir = dir;    if (!g.hasProperty(&quot;SPANNINGTREE_0&quot;))&#123;            g = embed.transform(g); //给这个图生成规定的生成树，先进入Treeembedding.java，生成生成树。之后又进入spanningtree.java，给生成树的每个节点生成坐标        &#125;    //读取交易列表，0: decide which is next transaction: previous one or new one? and add new links if any    //1: check if and how many spanning tree re-construction took place since last transaction        //do 1 (!) re-computation if there was any &amp; set stabilization cost        //如果不是实时动态修复，那么就是periodical的，SilentWhispers为代表，需要每过一个epoch计算生成树，和坐标,需要记录生成树的稳定开销。        //这里对于SM是没有开销的，因为它在静态情况下是没有新边的加入，生成树是不需要变化的        //计算开销的方法:            for (int j = epoch_old +1; j &lt;= epoch_cur; j++)&#123;                stabMes.add(this.roots.length*2*this.computeNonZeroEdges(g, edgeweights));//树的个数*2*非零的边数            &#125;            //有些度量的计算方法完全看不懂啊。。。。    //2: execute the transaction，分为 Multi 和 Adhoc    if (this.multi)&#123;        results = this.routeMulti(cur, g, nodes, exclude, edgeweights);    &#125; else &#123;        results = this.routeAdhoc(cur, g, nodes, exclude, edgeweights);    &#125;    //re-queue if necessary        //3 update metrics accordingly        path = this.inc(path, results[1]); //results[1]应该是一个比较大的数吧，在这里可以做Index？？？        reLand = this.inc(reLand, results[2]);//receiver-land        landSen = this.inc(landSen, results[3]);// land - sender        mes = this.inc(mes, results[4]);        del = this.inc(del, results[5]);        //成功情况下        mesAll = this.inc(mesAll, cur.mes);        pathAll = this.inc(pathAll, cur.path);        pathSucc = this.inc(pathSucc, results[1]);        mesSucc = this.inc(mesSucc, results[4]);        delSucc = this.inc(delSucc, results[5]); //delay                pathSF = this.inc(pathSF, val);        pathSsF[j-6] = this.inc(pathSsF[j-6], val);    //4 post-processing: remove edges set to 0, update spanning tree if dynRapir    if (this.dynRepair &amp;&amp; zeroEdges != null)         // 找到zeroEdges，对于边的src，dest，在生成树中是孩子节点的那个，做为repair的subroot        cur_stab = cur_stab + this.repairTree(nodes, sp, coords, cut, (CreditLinks) g.getProperty(&quot;CREDIT_LINKS&quot;));//开销就是边的改动        if (!this.update)&#123;                this.weightUpdate(edgeweights, originalWeight);//因为是静态的，这里就不会对原CreditLink中的值做改变            &#125;    /SM是所有的交易都执行完，执行这个        if (this.dynRepair)&#123;            stabMes.add(cur_stab);        &#125;            //compute metrics，使用Distribution</code></pre><pre><code class="java">//生成树的生成和坐标的生成g = embed.transform(g);public Graph transform(Graph g)//这些参数可以直接参见Treeembedding    Transformation tbfs = new MultipleSpanningTree(this.rootSelector,this.trees, rand,this.p,this.depth, this.dir);        ParameterList.key = &quot;SPANNINGTREE_BFS&quot;;        ParameterList.parameters = new Parameter[] &#123;                     new StringParameter(&quot;ROOT_SELECTOR&quot;, rootSelector),                     new BooleanParameter(&quot;RANDOM_ORDER&quot;,true),                     new StringParameter(&quot;ONED&quot;,oneD.name())&#125;);        Transformation.times = 1;        MultipleSpanningTree.rootSelector = rootSelector;        randomorder = true;        MultipleSpanningTree.rand = rand;        MultipleSpanningTree.trees = k;        MultipleSpanningTree.p = p;        MultipleSpanningTree.d = depth;        MultipleSpanningTree.oneDSel = oneD;//TWOPHASE    g = tbfs.transform(g);//MultipleSpanningTree.transform(g) //多个生成树，确定根节点，孩子父亲节点        CreditLinks: Map&lt;Edge, double[]&gt; weights;//graph-lcc-CREDIT_LINKS        int[] r = this.selectRoot(graph, rootSelector);//又把1-2-3这种形式给分成了｛1，2，3｝        //对于所有的节点        if (this.oneDSel ==  Direct.TWOPHASE)&#123;            l = potParents(graph, nodes[i], Direct.NONE, edgeweights).length;//得到的是当前节点的无重复的相邻节点的个数，不对边做剔除                case NONE: return potChildren(g, n, Direct.NONE, ew);                    ew.getPot(in[j], n.getIndex()) &gt; 0        &#125;        //对于不同的生成树        //分别得到根节点的入边，出边，筛选出容量大于0的节点，统计出与此节点双向的合法节点：即出和入相同的节点        int[] out = potChildren(graph, nodes[roots[i]], this.oneDSel, edgeweights);// this.oneDSel ==  Direct.TWOPHASE            //给生成树赋值坐标，根节点是空，其他节点的坐标是&lt;其父节点的坐标+随机数&gt;        //pad coordinates            //coordinate 是二维数组，第一维的长度就是节点数，第二维的长度取决于当前节点在生成树中的的层数            // 对于根节点，二维长度为0，对于第一层的节点，二维长度为1...对于 padding 则是将所有的第二维数组，填充为一样长度</code></pre><pre><code class="java">/**     * routing using a multi-part computation: costs are     * i) finding path (one-way, but 3x path length as each neighbor needs to sign its predecessor and successors)     * ii) sending shares to all landmarks/roots from receiver      * iii) sending results to sender from all landmarks/roots     * iv) testing paths (two-way)     * v) updating credit (one-way)     * @return &#123;success?0:-1, sum(pathlength), receiver-landmark, landmarks-sender,overall message count, delay, p1, p2,...&#125;     */    results = this.routeMulti(cur, g, nodes, exclude, edgeweights);int[] routeMulti(Transaction cur, Graph g, Node[] nodes, boolean[] exclude, CreditLinks edgeweights)        //对于不同的三棵树，在每颗树上找路径    paths[j] = ra.getRoute(src, dest, j, g, nodes, exclude);        initRoute(); //对于SW，置 up 为true，up是向上（到根）找路的意思；对于TreerouteOnly，无代码        int next = this.nextHop(src, nodes,destC,dest,exclude,pre);            //首先计算src 到 root 的路径            index = sp.getParent(cur);            //再计算 root 到 dst 的路径，找出最近的；父亲只有一个，但是孩子有很多个，要选最好的那个            int[] out = sp.getChildren(cur);            int dbest = this.getCPL(dest, this.coords[cur]);//计算src和dest坐标的相同位数，再在孩子节点中找比离 dest 更近的节点            //返回从 src 到 dest 的路径，有可能找不到路，即没有下一跳，此时需要判断，path的最后一个值是否为dest    //compute the  minimum credit along the paths，计算找到的每个树的路径上的最小值    double w = edgeweights.getPot(l,k);//对路径上的所有边，求最小    //partition transaction value，将一笔交易要转移的val，拆分成每个路径上合适的金额    vals = part.partition(g, src,dest,cur.val,mins);        //首先将一个 val， 随机的分成 trees 份，然后再根据每条路上的最小值进行调整        //对于某棵树上没有找到路，那么其最小值就是0，这样以来，就是在其他树的路径上去平分了    //check if transaction works：    //如果这棵树上有路，检查更新后的边权重是否满足原来的Creditlinks的最大最小要求，进行更新creditlinks的wt[1]    //如果所有的路径上都成功，将更新后，那些容量为0的边记录一下        CreditNetwork.zeroEdges.add(new Edge(src,dst));        //compute metrics    int[] res = new int[6+this.roots.length];//前6个是固定的要统计的值，后roots.length个值分别是各个树上的路    res[0] = success?0:-1;    res[1] = 统计总的路径长度;res[6+j] = paths[j].length-1;/-(paths[j].length-2);        //receiver-landmarks    //the sender and receiver both send only one message to each landmark forwarded by all nodes on the shortest path to the landmark.    int d = sp.getDepth(dest);    res[2] = res[2]+d*paths.length; //统计paths.length个值分别是各个树上的路；            //landmarks-sender    int d = sp.getDepth(src);    res[3] = res[3]+d;        //overall message count    res[4] = res[1]+res[2]+res[3];    res[4] = res[4]+2*(paths[j].length-1);//累加        //delay 与src，dest 的depth 有关，具体怎么算的实在是看不明白</code></pre>]]></content>
      
      
      <categories>
          
          <category> 论文相关总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> speedymurmurs </tag>
            
            <tag> payment routing </tag>
            
            <tag> 路由算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2019/10/10/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/10/10/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<ul><li><p><a href="https://zhuanlan.zhihu.com/p/40133139">Linux 任务后台运行 —screen常用命令</a></p></li><li><p><a href="https://blog.csdn.net/hejunqing14/article/details/50338161">用screen 在后台运行程序</a></p><ul><li>Linux使用screen之后terminal就没法往上走看前面的输出内容了，<code>ctrl a+[</code> 然后使用上下                                                         </li></ul></li><li><p><a href="https://blog.csdn.net/stormbjm/article/details/9086163">linux下添加用户并赋予root权限</a></p><ul><li><a href="http://blog.chinaunix.net/uid-26000296-id-3496103.html">linux新建用户与权限修改</a></li></ul></li><li><p><a href="https://blog.csdn.net/li_101357/article/details/46778827">useradd 与adduser的区别</a></p><ul><li>用 addusr 比较好，如果用usradd，加 -m 参数，这样可以生成一个自己用户的目录</li></ul></li><li><p><a href="https://www.biaodianfu.com/linux-configure-make-make-install.html">Linux软件安装 ./configure,make,make install的作用</a></p></li><li><p><a href="https://cnbin.github.io/blog/2015/06/22/linux-slash-configure-prefix-ming-ling/">Linux ./configure –prefix 命令</a></p></li><li><p><a href="https://juejin.im/">Golang环境变量设置详解</a></p></li><li><p><a href="https://www.jianshu.com/p/4e699ff478a5">go环境变量配置 (GOROOT和GOPATH)</a></p><ul><li>GOROOT：是go的安装目录</li><li>GOPATH的值不能与GOROOT相同。用于指定我们的开发工作区(workspace),是存放源代码、测试文件、库静态文件、可执行文件的工作。</li></ul></li><li><p><a href="https://cnbin.github.io/blog/2015/06/22/linux-xiu-gai-huan-jing-bian-liang-path/">Linux 修改环境变量 PATH</a></p></li><li><p><a href="http://www.findme.wang/blog/detail/id/1.html">查看linux中某个端口（port）是否被占用</a></p></li><li><p>root用户修改其他普通用户的密码（忘记密码情况）</p><ul><li>不记得用户名 <code>cat/etc/shadow</code> ，查看用户名</li><li>知道用户名，输入  <code>  passwd 用户名</code></li></ul></li><li><p>以太坊上的交易：<a href="https://ethfans.org/posts/the-business-of-sending-transactions-on-ethereum">https://ethfans.org/posts/the-business-of-sending-transactions-on-ethereum</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="/2019/10/10/java/"/>
      <url>/2019/10/10/java/</url>
      
        <content type="html"><![CDATA[<ul><li><p><code>int[] num = new int[0];</code> 开辟一个大小为 0（即 <code>num.length == 0</code> ） 的空间，可以在 <code>empty array</code>上遍历，但是不能在 <code>null</code> array 上遍历。</p></li><li><p><code>readline();</code> 参见脱坑指南 <a href="https://blog.csdn.net/swingline/article/details/5357581#commentBox">被readLine()折腾了一把</a></p></li><li><p><code>.txt</code> 文件一定要用 <code>notepad++</code> 看，用电脑自带的记事本，看起来不会空行之类的，所有数据堆成一片。</p></li><li><p><a href="https://blog.csdn.net/ustcjackylau/article/details/42454779">java Queue中 remove/poll, add/offer, element/peek区别</a></p></li><li><p><a href="https://blog.csdn.net/foart/article/details/4295645">Java Math的 floor,round和ceil的总结</a></p></li><li><p><a href="https://blog.csdn.net/u010255818/article/details/52733256">java中Properties类的操作</a></p></li><li><p><a href="https://www.iteye.com/blog/tristan-wang-647729">Java读取Properties文件的六种方法</a></p></li><li><p><a href="https://blog.csdn.net/u010983881/article/details/49762595">HashMap 和 HashTable 的区别到底是什么？</a></p></li><li><p>ArrayList 和 LinkedList 的区别？</p></li><li><p><a href="https://blog.csdn.net/shlearry/article/details/50553986">java中 .currentTimeMillis的用法和含义</a></p></li><li><p><a href="https://www.iteye.com/blog/blackproof-1709336">Class.forName和ClassLoader.loadClass</a></p></li><li><p>switch case中，在某个case中定义的变量，在其他case中可以直接拿来使用。return和break的区别是，前者直接返回，不执行这个函数下面的语句了。而后者是直接跳出当前的switch语句。</p><pre><code class="java">import java.io.*;import java.util.*;public class test&#123;    public int[] testSwitch(int n)&#123;        switch(n)&#123;            case 1:            //boolean take = new boolean[10];                            int[] res = new int[10];                for(int i = 0; i &lt; 5; i++)                    res[i] = i;                return res;            case 2:                 res = new int[5];                for(int j = 0; j &lt; 5; j++)                    res[j] = j+10;                return res;        &#125;        return null;    &#125;    public static void main(String[] args)&#123;        test t = new test();        int[] res1 = new int[20];        res1 = t.testSwitch(2);        for(int k = 0; k &lt; res1.length; k++)            System.out.println(res1[k]+&#39;\n&#39;);            &#125;&#125;</code></pre></li><li><p><a href="http://outofmemory.cn/code-snippet/2099/java-usage-FilenameFilter-shaixuan-file">java使用FilenameFilter筛选文件</a></p><ul><li><a href="https://stackoverflow.com/questions/19932962/use-of-filenamefilter">stackoverflow</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA的使用：提升看源码效率</title>
      <link href="/2019/10/09/IDEA%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/10/09/IDEA%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="IntelliJ-IDEA-常见文件类型的图标介绍"><a href="#IntelliJ-IDEA-常见文件类型的图标介绍" class="headerlink" title="IntelliJ IDEA 常见文件类型的图标介绍"></a>IntelliJ IDEA 常见文件类型的图标介绍</h3><p>参见博客: <a href="https://blog.csdn.net/qq_35246620/article/details/64157559">IntelliJ IDEA 常见文件类型的图标介绍</a></p><h3 id="IDEA中配置参数，运行main函数"><a href="#IDEA中配置参数，运行main函数" class="headerlink" title="IDEA中配置参数，运行main函数"></a>IDEA中配置参数，运行main函数</h3><p>对于java程序，编译（build）指令： <code>javac</code>，运行（run）指令： <code>java</code> ，需要安装 JDK（这里又有Oracle JDK 和 OpenJDK，自行百度区别和使用），JRE。</p><p>对于windows 配置 <code>JAVA_HOME</code>，<code>PATH</code>，<code>classpath</code> 的方法见：<a href="https://blog.csdn.net/haiki66/article/details/88758199">Java中JAVA_HOME, PATH,CLASSPATH的作用和配置值</a></p><p>IDEA下可以有两种运行程序的方法：</p><ol><li>最上方工具栏分别找到 <code>Build</code>  和 <code>Run</code>对程序进行编译，运行。使用这种方法时，如果main函数运行时需要传入参数，参数的配置方法为：鼠标指向最上面工具栏的：<code>Run</code> ，选中左键进入<code>Edit configurations</code>。如下图所示。其中<code>program argument1</code>处依次填入需要的参数。</li></ol><ul><li>这里我们可以留意到的是：<code>Main class</code> 的书写形式， main 函数所在的类，是以包名的形式呈现的。那么对于不同类中的 main 函数，通过修改 类名即可。这样简单的配置之后，我们就可以直接用 <code>Build</code> 和 <code>Run</code> 来处理程序啦~ 很多命令的处理过程，都由IDE进行</li></ul><p><img src="https://i.loli.net/2019/10/09/oLgrNqhYudD5pbT.jpg" alt="IDEA.JPG"></p><ol start="2"><li>在终端（terminal）下运行输入 <code>javac</code> 和 <code>java</code> 编译运行程序（也就是IDE帮我们做的一些命令）。<ul><li><code>javac -classpath &lt;lib&gt; -sourcepath &lt;src&gt; -d &lt;bin&gt;</code></li><li><code>java -classpath &lt;lib&gt;&lt;:/;&gt;&lt;bin&gt; &lt;main函数所在类&gt;</code></li><li>其中，凡是用 <code>&lt;&gt;</code>框起来的都是要根据自己的实际情况进行更改的。<ul><li><code>-classpath</code>也可以简写为 <code>-cp</code>，是用来加载外部包的，比如你写的项目里面，用到了一些jar 包，那么需要把这些jar包的路径告诉 javac 这个可执行程序，也就对应于 <code>&lt;lib&gt;</code>，比如我的这个项目，某些 jar 包的路径是 <code>./lib/</code>，表示当前项目的当前文件夹下的lib文件夹下。</li><li><code>-sourcepath</code> 需要输入的是当前项目所在的文件夹，查看当前项目所在路径可以试错，也可以自行百度。示例：<code>./src/</code></li><li><code>-d</code> 是指：编译之后生成的 <code>.class</code> 文件放在哪个文件夹下，这个的文件路径可以自己设置，一般在当前项目下，新建一个文件夹，如  <code>./bin</code> 或者 <code>./out</code> 。我们要知道的是，java 运行的都是 <code>.class</code> 文件。</li><li><code>javac</code> 和 <code>java</code> 中的  <code>&lt;lib&gt;&lt;bin&gt;</code> 都一样。需要注意的是，对于 <code>java</code> 命令中 &lt;&gt;<code>&lt;:/;&gt;</code> 是说，当在unix下使用此命令时，用冒号，在window下使用时，用分号。</li><li><code>&lt;main函数所在类&gt;</code> 就是方法 1 中提到的 以包名形式的包含main函数的类名。</li></ul></li></ul></li></ol><h3 id="IDEA中查看类继承关系"><a href="#IDEA中查看类继承关系" class="headerlink" title="IDEA中查看类继承关系"></a>IDEA中查看类继承关系</h3><p>鼠标点在类名上，右键，在复选框中找到 <code>Diagrams</code> —&gt; <code>show diagrams</code> ，则可以查看类的继承关系。</p><p><img src="https://i.loli.net/2019/10/10/EWPbBq7cZnfNDKe.png" alt="IDEA1.png"></p><h3 id="函数调用关系——SourceInsight"><a href="#函数调用关系——SourceInsight" class="headerlink" title="函数调用关系——SourceInsight"></a>函数调用关系——SourceInsight</h3><p>增：10月11在意外中发现了别人写的一篇博客，好仔细！推荐！</p><p>[C 源码阅读之函数(Function/Method)调用树图( Call Graph)及数据结构依赖图][<a href="http://blog.sina.com.cn/s/blog_6b6ab0890101qd9j.html]">http://blog.sina.com.cn/s/blog_6b6ab0890101qd9j.html]</a></p><p>这个有两种方式：</p><ol><li><p>鼠标点击需要查看的函数名，在上方的菜单栏查找一个图标，如下图所示，则会显示这个函数的调用关系。</p><p><img src="https://i.loli.net/2019/10/10/8LRf45onVOvhYju.png" alt="SourceInsight.png"></p></li><li><p>鼠标右键函数名，选择 <code>Show in Relation Window</code>，会出现和 1 一样的结果。</p><ol><li>看下图，左下角会有一些小的选择，按照箭头标注，最左边点击一下，会出现列表形式的函数调用关系，在第一列，是 <code>name</code> ，默认情况下，函数是以字母序排序的，如果想按照函数调用顺序，可以鼠标左键点一下 <code>name</code>，会以英文形式提示你，现在是以什么排序的。类似文件夹下，以创建时间，或者修改日期等排序那种。这个选择好之后，点击第二个箭头指的，显示出的关系图就是按照你选定的函数的出现方式。（升序，降序，出现顺序）</li><li> 接着就是调用关系是横着显示还是竖着显示；</li><li>再接着是设置。</li></ol></li></ol><p><img src="https://i.loli.net/2019/10/10/cZkgdznxXUWfowR.png" alt="SourceInsight1.png"></p><p><img src="https://i.loli.net/2019/10/10/ZKvNI78q164dm3H.png" alt="SourceInsight3.png"></p><p>还可以设置要查看的函数调用关系，是查看当前函数调用（calls）了哪些函数，调用关系显示几层。这里主要想提及的是 <code>View Relationship</code> 这里，这个选择直接决定了显示什么关系。可以看到，关系主要是用于 <code>Types（类型）、Functions（函数）、Variables（变量）、class（类）等</code> ， 需要注意的是，类的关系也可以展示，但是我更喜欢用 IDEA 的类继承关系。根据自己的需要，选择想要查看的关系图，如函数调用关系，那么要设置的是 <code>functions</code>，<code>Calls</code>表示查看这个函数开始调用了哪些，<code>calls and callers</code> 则表示此函数的调用 + 对此函数的调用。<code>reference </code> 表示引用。</p><p><img src="https://i.loli.net/2019/10/10/NibgmIKpLftDQcG.png" alt="SourceInsight4.png"></p><h3 id="IDEA中-显示函数的用法"><a href="#IDEA中-显示函数的用法" class="headerlink" title="IDEA中 显示函数的用法"></a>IDEA中 显示函数的用法</h3><p><code>Alt + F7</code>，下面会显示出哪里使用了这个函数。</p><h3 id="IDEA中-类中的函数及变量等概览"><a href="#IDEA中-类中的函数及变量等概览" class="headerlink" title="IDEA中 类中的函数及变量等概览"></a>IDEA中 类中的函数及变量等概览</h3><p><code>Alt + 7</code></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非暴力沟通摘录及观后感</title>
      <link href="/2019/10/06/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%E6%91%98%E5%BD%95%E5%8F%8A%E8%A7%82%E5%90%8E%E6%84%9F/"/>
      <url>/2019/10/06/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%E6%91%98%E5%BD%95%E5%8F%8A%E8%A7%82%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="chapter-1-—-让爱融入生活"><a href="#chapter-1-—-让爱融入生活" class="headerlink" title="chapter 1 — 让爱融入生活"></a>chapter 1 — 让爱融入生活</h3><blockquote><p>感激生活的赐予，而不贪心。</p></blockquote><p>对于一些事，是经历过的也好，期盼中的也好，总是想“如果怎样就好了”。会对已有的，不论好坏的结果有不满，会对未来未发生的，不论好坏的结果有不切实际的幻想。珍惜生活中得到的，就是最好的。</p><blockquote><p>虽然每个人的价值观和生活方式或许不同，但作为人却有着<strong>共同的感受和需要</strong>。这样，在发生矛盾和冲突的时候，运用非暴力沟通，我们将能专注于彼此的感受和需要，从而促进倾听、理解以及由衷的互助。</p></blockquote><p>举个很简单的例子，比如A喜欢B，并告诉了B，而B可能拒绝A，并且给A的理由是：我们不合适，我们三观有冲突，生活方式不一样等等；或者说A和B的交流不是很顺畅，A会和别人说，我和B三观不同，没什么好聊的。虽然这些都是需要考量的因素，也是可以理解的点。但是我还是很喜欢这句话，作为人，有着共同的感受和需要。不能因为一些先天的外界因素，限制了我们的发展，并片面化自己的交友或者生活。</p><blockquote><p>爱的能力取决于审美能力。</p></blockquote><p>有一双明察秋毫的眼睛太重要了。不管做啥事，都要擦亮你的眼睛。而“擦亮”却不是抹抹眼睛就可以的事，它需要我们培养一种审美能力。比如，如何让找到的男朋友，或者喜欢的男生不是渣男。在这一点上，我一直觉得自己是瞎子。但是在交朋友上，我感觉自己可以欣赏到各种美。</p><blockquote><p>非暴力指暴力消退后，自然流露的爱。</p></blockquote><blockquote><p>非暴力沟通的四个要素：</p><ol><li>观察</li><li>感受</li><li>需要</li><li>请求</li></ol></blockquote><p>对现状进行观察，表达自己的感受，了解是哪些需要（价值、愿望等）导致的需要，为了改善生活，提出请求。</p><p>对于别人的质疑，指责等，不要先想着如何去反驳，表达自己的感受，可以学着倾听，对于别人的问题，倾听其包含的情感和需要。通过问题，去了解对方的心灵和愤怒。让对方知道，我们确实是在感受着他们的感受。</p><h3 id="chapter-2-是什么蒙蔽了爱"><a href="#chapter-2-是什么蒙蔽了爱" class="headerlink" title="chapter 2 - 是什么蒙蔽了爱"></a>chapter 2 - 是什么蒙蔽了爱</h3><p><strong>道德评判</strong></p><blockquote><p>对他人的评价实际上反映了我们的需要和价值观。</p></blockquote><blockquote><p>分类和评判提倡的是暴力。</p></blockquote><blockquote><p>要是达不到自己的期待，我也会觉得自己有毛病。我一心想分析和确定错误的性质，而忽视自己和他人的需要。因此，如果女友想多一些体贴，那她就“太粘人了”。可是，如果我想多一些体贴，那她“冷漠得像个木头”。如果同事更关心细节，他就是“有强迫症”。反之，如果我更在乎细节，他就是“粗心大意”。</p></blockquote><blockquote><p>“暴力是不好的。杀人者是邪恶的。”然而，如果我们从小就学习爱的语言 ，我们将会直接说出我们的价值观，而不会指责他人。此时我们就会说:“对于使用暴力来解决问题，我很担心；我主张通过其他方式来解决冲突。”</p></blockquote><p><strong>进行比较</strong></p><blockquote><p>比较也是一种评判。</p></blockquote><p><strong>回避责任</strong></p><blockquote><p>我们可以用负责任的语言代替回避责任的语言。</p></blockquote><p>回避责任的语言包括：“我不得不”，“你让我”。在这个方面感觉自己做的还可以，因为性格的原因，其实很多事都是自己选择了之后做的。因为都会带有自己的目的性。比如，我要参加学生会，因为我想去组织活动，认识更多的人，最好是能遇见一个男朋友。但是我不想成为更高层管理负责的人，是因为我不想处理其中的社交关系。所有不得不做的事，而且已经做了的事，其背后一定是有满足自我的某种目的。所以，其实没什么不得不做的事。</p><blockquote><p>一旦意识不到我们是自己的主人，我们就成了危险人物。</p></blockquote><p>少一些唯唯诺诺，多一些果断和自己的想法。</p><p><strong>强人所难</strong></p><blockquote><p>长期以来，我们强调人性本恶以及通过教育来控制天性。这导致了我们对自己的感受和需要常常心存疑虑，以致不愿去体会自己的内心世界。</p></blockquote><blockquote><p>人们越是习惯于评定是非，他们也就越倾向于追随权威，来获得正确和错误的标准。一旦专注于自身的感受和需要，我们就不再是好努力和好属下。</p></blockquote><p>无需言，做自己。己所不欲，勿施于人。</p><h3 id="chapter-3-区分观察和评论"><a href="#chapter-3-区分观察和评论" class="headerlink" title="chapter 3 - 区分观察和评论"></a>chapter 3 - 区分观察和评论</h3><blockquote><p>不区分观察和评论，人们将倾向于听到批评。</p><p>不带评论的观察是人类智力的最高形式。</p></blockquote><p>观察是将事实描述出来，而评论会在事实的基础上加入个人情感。</p><h3 id="chapter-4-体会和表达感受"><a href="#chapter-4-体会和表达感受" class="headerlink" title="chapter 4 - 体会和表达感受"></a>chapter 4 - 体会和表达感受</h3><blockquote><p>示弱有助于解决冲突。</p></blockquote><blockquote><p>区分感受和自我评价。</p></blockquote><blockquote><p>为了清晰地表达感受，我们编制了以下的词汇表。<br>（1）下列词语可用来表达我们的需要得到满足时的感受:</p><p>兴奋，喜悦 ，欣喜， 甜蜜，精力充沛，兴高采烈<br>感激，感动，乐观，自信，振作，振奋，开心<br>高兴，快乐，愉快，幸福，陶醉，满足，欣慰，心旷神怡，喜出望外<br>平静，自在，舒适，放松，踏实，安全，温暖，放心，无忧无虑</p><p>（2）下列词语可用来表达我们的需要没有得到满足时的感受:</p><p>害怕，担心，焦虑，忧虑，着急，紧张，心神不宁，心烦意乱，忧伤，沮丧，灰心丧气，气馁，泄气，绝望，伤感，凄凉，悲伤，恼怒，愤怒，烦恼，苦恼，生气，厌烦，不满，不快，不耐烦，不高兴，震惊，失望，困惑，茫然，寂寞，孤独，郁闷，难过，悲观，沉重，麻木，精疲力尽，委靡不振，疲惫不堪，昏昏欲睡，无精打采，尴尬，惭愧，内疚妒忌，遗憾，不舒服</p></blockquote><p>不要总是你觉得，可以直接说出描述心情的形容词。</p><h3 id="chapter-5-感受的根源"><a href="#chapter-5-感受的根源" class="headerlink" title="chapter 5 - 感受的根源"></a>chapter 5 - 感受的根源</h3><blockquote><p>别人的行为可能会刺激我们，但并不是我们感受的根源。</p></blockquote><blockquote><p>非暴力沟通强调，感受的根源在于我们自身。我们的需要和期待，以及对他人言行的看法，导致了我们的感受。</p></blockquote><p>一般表达感受的形式是：他们做了XXX，我很XXX，因为我需要XXX。</p><blockquote><p>听到不中听的话时，我们可以有四种选择：1）责备自己；2）指责他人；3）体会自己的感受和需要；4）体会他人的感受和需要。</p></blockquote><blockquote><p>如果我们想利用他人的内疚，我们通常采取的办法是，把自己不快的感受归咎于对方。家长也许会和孩子说:“你成绩不好让爸爸妈妈伤透了心！”言下之意是，他们快乐或不快乐是孩子的行为造成的。看到父母的痛苦，孩子可能会感到内疚，并因此调整行为来迎合他们。遗憾的是，这种调整只是为了避免内疚，而非出自对学习的热爱。</p></blockquote><p>不要利用别人的内疚，把责任推到别人身上。因为，你只是得到了一时的妥协，而没有从根本上解决问题。</p><blockquote><p>批评往往暗含着期待。对别人的批评实际上间接表达了我们尚未满足的需要。</p></blockquote><p>之所以会将无法满足自己愿望的事归结给别人，是因为，自己有所期待，但是并未通过对他人的期待而被满足。比如国庆去看烟花，去了灯市口，而不是珠市口，没看到烟花的时候，内心是非常难过的，但是把这种难过归咎于给我们指路的人，刚开始不说清楚，我们都到了才说，因为只有这样的抱怨才能让我没有看到烟花这件事有一个解释。然而，可以表达的感受可以换成这样：我非常想看烟花，我去了他第一次给我们说的地点，我认为也可能会看到烟花，寻思着位置也差不多。</p><blockquote><p>如果我们不看重自己的需要，别人可能也不会。实际上，如果直接说出需要，获得积极回应的可能性就会增加。</p></blockquote><p>我累了，我想休息。而不是说自己今天干了什么什么一大堆没用的。</p><p>勇敢的表达自己的想法和需要，有时候就得牺牲别人的需要。</p><blockquote><p>为他人的情绪负责，牺牲自己迎合他人，代价实在很大。</p></blockquote><blockquote><p>对于大多数人来说，<strong>个人成长</strong>一般会经历三个阶段:（1）“情感的奴隶”—我们认为自己有义务使他人快乐；（2）“面目可憎”时期——此时，我们拒绝考虑他人的感受和需要；（3）“生活的主人”——我们意识到，虽然我们对自己的意愿、感受和行动负有完全的责任，但无法为他人负责。与此同时，我们还认识到，我们无法牺牲他人来满足自己的需要。</p></blockquote><blockquote><p>真诚待人比委屈求全更为可贵。如果别人感到不安，我们可以认真地倾听，但无须责备自己。</p></blockquote><h3 id="—随记—"><a href="#—随记—" class="headerlink" title="—随记—"></a>—随记—</h3><p>2019.10.8 - 今日学习速递 - 胡伟武老师的讲座摘录</p><p>我的感受：有的人视时间如金，而有的人却挥金如土。</p><blockquote><p>千里马的栅栏已经打开，不要眷恋原来的“草料”。</p><p>不以物喜，不以己悲；受辱不辩，闻谤不咎。</p><p>学而时习之，不亦乐乎。习是实践。</p><p>失败是成功之母，而学习是成功之父。</p><p>通过思考把握事物的简单性。</p><p>因戒生定，因定生惠。</p><p>成熟：当你取得成就不去说了，当受了委屈不去辩解。</p></blockquote><h3 id="chapter-6-请求帮助"><a href="#chapter-6-请求帮助" class="headerlink" title="chapter 6 - 请求帮助"></a>chapter 6 - 请求帮助</h3><p>今天看到的很多东西，都和自己息息相关，非常的受用，所以摘录了很多段，就不分开写了。</p><ul><li><p>不要总是提醒自己要避免出现什么，而是提醒自己主动做些什么。</p></li><li><p>我们提出的请求越具体越好。如果我们的意思含糊不清，别人就难以了解我们到底想要什么。此外，使用抽象的语言还会使我们无法深入了解自己。请求他人采取具体的行动将揭示我们的动机。</p></li><li><p>许多来向我求助的人后来发现，他们感到沮丧或灰心，很大程度上是因为他们不清楚自己对他人究竟有什么样的期待。</p></li><li><p>如果我们<strong>只是表达自己的感受</strong>，别人可能就不清楚我们想要什么。如果一个人<strong>提出了明确的请求，却没有提及感受和需要</strong>，也有能导致交流的困难。</p></li><li><p>就像那位乘火车去机场的先生，我们希望有人倾听并了解我们的处境。或者，我们期待的是如实的反馈—我们想了解他人的真实想法。当然，有时我们希望他人采取某种行动。对自己的认识越深刻，表达越清楚，我们就越可能得到称心的回应。</p></li><li><p>当对方给予反馈，表达我们的感激；如果对方不愿反馈，倾听他们的感受和需要。</p></li><li><p>了解他人的反应：</p><ul><li>对方此时此刻的感受</li><li>对方正在想什么</li><li>对方是否接受我们的请求</li></ul></li><li><p>参加集体讨论时，说清楚我们希望得到怎样的反馈，是至关重的。如果不清楚发言的目的，我们的讨论也许只是在浪费时间，而无满足任何人的需要。此外，如果不清楚发言者是否已经得到满意的答复，讨论就可能无目的地继续下去，而无法满足任何人的需要。</p><ul><li>“我不清楚你为什么要提到这篇文章。你是否可以告诉我们，你期待得到怎样的反馈呢？”这样的提醒也许就可以避免浪费宝贵的会议时间。</li></ul></li><li><p>如何区分命令和请求:请求没有得到满足时，提出请求的人如果批评和指责，那就是命令；如果想利用对方的内疚来达到目的，也是命令。</p></li><li><p>一旦人们认为我们是在强迫他们，他们就会不太想满足我们的愿望。</p></li><li><p>一旦人们相信我们看中彼此的感情，并能兼顾对方的需要，那么他们也就会相信我们所表达的愿望是请求而非命令。</p></li></ul><h3 id="chapter-7-用全身心倾听"><a href="#chapter-7-用全身心倾听" class="headerlink" title="chapter 7 - 用全身心倾听"></a>chapter 7 - 用全身心倾听</h3><p>今日份的依旧纯摘抄，让我想到了很多类似的场景。</p><p>比如舍友给我说：“我把我男朋友惹生气了，因为他有时候真的是太自信了”。我可能会急于表达自己的理解和关怀，回答：“没事的”，接着又觉得这样不行，又开始神补刀，“你下次不要这样说他啦，他也有自己的性格吧啦啦啦”。这样导致的后果就是舍友也不愿意和我继续分享她的感受了。学了这一章，我觉得这样说比较好：“你是有点讨厌他的自信？希望他能够多一点谦逊？”。  是这么个套路吗。。。问号.jpg。</p><ul><li>“尽管有种种相似之处，生活的每时每刻就像一个刚出生的婴儿，一张新的面孔，我们从未见过，也不可能再次见到。我们无法停留在过去，也无法预见我们的反应。我们需要不带成见地感受变化。我们需要用全身心去倾听。”</li><li>不要急着做什么，站在那里。</li><li>试图分析问题妨碍了我们与他人的联系。如果我们只关心别人说了什么，并考虑他的情况符合哪种理论，我们是在诊断人—我们并没有倾听他们。在非暴力沟通中，倾听他人意味着，放下已有的想法和判断，一心一意地体会他人。倾听的这种品质体现了它与理解以及同情之间的区别。</li><li>作家约瑟夫·坎伯（ Joseph Campbell）说道:“为了幸福，必须把‘别人怎么看我’这个问题放在一边。”一旦我们把所谓的批评和指责看作是来自他人的礼物—为处于痛苦中的人提供服务的机会，我们就会感到这种幸福。</li><li>联合国前秘书长汉马斯克德（ Dag Hammarskjold）曾经说道:“你越是留意自己内心的声音，就越能够听到别人的声音。”一旦我们能够敏锐地察觉并照顾自己的感受和需要，我们就有能力迅速调整好状态，来倾听他人如果做不到这一点，我们还有另外两种选择。<br>其中一种选择是大声地提出请求。不过，如果对方正处于激烈的情绪中，他也可能无法留意我们的感受和需要。这时，我们的另一种选择是，换一个环境。我们需要时间和间来调整状态，等平静下来了，再回来。</li></ul><h3 id="chapter-8-倾听的力量"><a href="#chapter-8-倾听的力量" class="headerlink" title="chapter 8 - 倾听的力量"></a>chapter 8 - 倾听的力量</h3><blockquote><p>非暴力沟通鼓励我们表达自己最深的感受和需要，因此，我们有时许会发现运用非暴力沟通是富有挑战性的。然而，通过倾听，我们将意识到他人的人性以及彼此的共通之处，这会使自我表达变得容易些。我们越是倾听他人语言背后的感受和需要，我们就越不怕与他们坦诚地沟通。我们最不愿意示弱的时候往往是因为担心失去控制想显得强硬的候。</p></blockquote><p>示弱有时候是一种人生智慧，尤其是我这样比较强势的女生。每个人都需要有台阶下，要有一种温和的心态和姿态去和别人交流，相处。</p><blockquote><p>绝望有时也许会给一个人带来灵感！<br>你和我们说，在一个生气的人面前，永远不要用‘不过’‘ “可是”，“但是”之类的词语。一开始，我很想为自己辩护，我想和他说，‘可是我们真的没房间’。幸好，在那时，我想起了那句话。我一直记得。</p></blockquote><p>说实话，从小和父母一起看那种刑侦片，或者谍战片，在电视屏幕里见识过太多人。有那种小偷，绑匪，毒贩子、毒枭等等，一直都很害怕电视中，绑架人质的事情发生在自己的身上。自己的长大，意味着电视上的画面，在自己身边，乃至自己身上发生的可能性都增加。在微博上会看到一些社会热点，有人突然拿着菜刀看向路人等等。对于这些恶意的事件，面对这些意外的伤害，我一直在思考，如果当事人是自己，该如何处理。看了这一章，我觉得，在一些极端情况下，我依然要相信人性的善，要倾听对方的感受和需要。有没有用我不知道，但我确定，如果鲁莽地挣扎，绝对没用。</p><blockquote><p>当别人说“不”的时候，我们常常会认为他们是在拒绝我们。有时，我们甚至还会觉得自己受到了伤害。然而如果我们能够体会他人的感受和需要，我们也许就会发现是什么使他们无法答应我们的请求。</p></blockquote><p>这让我想起了，我总是喜欢叫着别人和我一起做一些事，因为总觉得一个人有点孤单。但是我对于一起玩的人又很挑剔，所以我愿意叫着玩的也就那几个。有一次，我非常想请我的朋友和我一起去闲逛，但是当我一提出请求，她就拒绝了。当时我很生气，我觉得她已经和我关系不好了，她已经不再是以前那个时刻和我要好的朋友了。但是我什么也没说，她和我说，她早上6点下的火车，非常的劳累，一点也不想转悠了，只想在寝室休息。现在一想，是啊，她有自己的感受，我应该去理解她的感受，而不是因为她没有满足我的请求而迁怒于对方。还好，我没有做出伤害她的事。</p><blockquote><p>有的时候，谈话的气氛很沉闷。我们体会不到说话的人有怎样的感受和需要，也不知道他对我们有什么期待。这样的谈话是很累人的。它只是在浪费我们的时间，而无法帮助我们与他人加深联系。这种局面的出现往往是因为说话的人并不清楚自己的感受、需要和请求。怎么做才可以扭转这种局面，使谈话生动有趣呢？我的建议是，尽快提醒说话的人留意自己的感受和需要。等得越久，也就越难做到这一点。我们这样做并不是要以自我为中心，而是请求他人体会自身的状态。使谈话生动有趣的另一种方法是直接表达我们的愿望。</p></blockquote><p>少说废话，可能是现在的成年人必须要锻炼的一种素质。所以，为了向合格的成年人再迈向一步，要管住自己的嘴了。</p><h3 id="chapter-9-爱自己"><a href="#chapter-9-爱自己" class="headerlink" title="chapter 9 爱自己"></a>chapter 9 爱自己</h3><blockquote><p>主人公拒绝将他12岁的外甥交给儿童福利院。他郑重地说道:“我希望他准确无误地知道他是多么特殊的生命，要不，他在成长的过程中将会忽视这一点。我希望他保持清醒，并看到各种奇妙的可能。我希望他知道，一旦有机会，排除万难给世界一点触动是值得的。我还希望他知道为什么他是一个人，而不是一张椅子。</p></blockquote><blockquote><p>许多人陷于自我憎恨之中，而无法从失误中获益——失误揭示我们的局限性，并引导我们的成长。</p></blockquote><blockquote><p>即使我们有时通过严厉的自责“得到了教训”，我也会担心这种变化和学习的驱动力。我希望，我们的改变是出于对生命的爱，而不是出于羞愧或内疚这些具有负面影响的心理。</p></blockquote><blockquote><p>如果自我评价使我们羞愧并改变行为，我们也就允许自我憎恨来引导自己的成长和学习。羞愧是自我憎恨的一种形式，出于羞愧的行为不是自由而快乐的行为。即使我们试图更加友善和体贴，一旦人们意识到我们行为背后的羞愧或内疚，他们对这些行为的欣赏也就比不上那些只是出于爱的行为。</p></blockquote><blockquote><p>如果我们认为自己“应该”怎么样，在大多数的情况下，我们也就封闭了自我。因为“应该”意味着我们别无选择。这使我们感到无奈和沮丧。同时，又心有不甘，不愿屈服。<br>如果我们专注于需要是否到满足以及得到怎样的满足，我们就更有可能从自我评价中获益。</p></blockquote><blockquote><p>非暴力沟通鼓励我们直面人生的苦难:在遇到挫折时，充分体会人生的悲哀和内心的渴望。是的，感到遗憾是难免的。但它能帮助我们从经历中学习，而无须责备自己。我们意识到过去的行为违背了自己的需要及价值观，并允许这种觉察引发的情感充分流淌。一旦专注于尚未满足的需要，我们就会考虑如何满足它。反之，如果用苛刻的语言指责自己，我们不仅难以找到解决办法，而且容易陷于自我惩罚的痛苦中。</p></blockquote><h3 id="chapter-10-充分表达愤怒"><a href="#chapter-10-充分表达愤怒" class="headerlink" title="chapter 10 充分表达愤怒"></a>chapter 10 充分表达愤怒</h3><blockquote><p>我相信，人的行为总是服务于自身的需要及价值观—不论它是否能够实现目的，也不论我们事后是感到庆幸还是遗憾。</p></blockquote><blockquote><p>通过聆听自己的心声，我们就能发现心灵深处的需要。此时，我们就可以原谅自己。我们意识到，尽管过去的选择并不理想，但它也是为了实现内心的渴望。</p></blockquote><blockquote><p>爱惜自己的关键之一是同时包容那两个不同的“我”:一方面包容对过去的某种行为感到后悔的“我”，另一方面包容采取那种行为的我”。</p></blockquote><blockquote><p> 如果我不强调我与他人观念的不同，我就较容易接纳他们。特别是当我遇到一个有像他那样想法的人时，倾听他们的感受和需要，而不纠缠于他们的想法，我们的生活将会变得愉快得多。</p></blockquote><blockquote><p>于是，为了博得他人的喜爱，我们费尽心思、委曲求全。这是很可悲的。实际上，如果我们的行为只是出于对生命的爱，人们自然会心存感激。他们的感激也是在给我们确认:我们的行为有益于他们的生活。一旦如愿活出对生命的爱，我们所体会到的欢乐是他人的赞同永远无法给予的。</p></blockquote><blockquote><p>我确信，一旦生命的需要被忽视，我们的行动对社会来说极具危险，对个人来说则极为不幸。</p></blockquote><blockquote><p>做有乐趣的事情是可能的。我相信，我们越是投入服务生命的乐趣中———服务生命是唯一的目的，我们也就越爱自己。</p></blockquote><h3 id="chapter-11运用强制力避免伤害"><a href="#chapter-11运用强制力避免伤害" class="headerlink" title="chapter 11运用强制力避免伤害"></a>chapter 11运用强制力避免伤害</h3><blockquote><p>如果我不强调我与他人观念的不同，我就较容易接纳他们。特别是当我遇到一个有像他那样想法的人时，倾听他们的感受和需要，而不纠缠于他们的想法，我们的生活将会变得愉快得多。</p></blockquote><blockquote><p>如果在一个社会中，内疚被运用来控制人；那么，指责他人就容易成为一种习惯。同时，为了使这种手段奏效，我们可能就会认为一个人可以主导另一个人的情绪。</p></blockquote><blockquote><p>当我回想起那两天的经历时，我发现，我一开始就把第一个孩子看作是“被宠坏的孩子”。所以，他打到我时，我极为恼怒。我心里想:“这家伙太猖狂了！”我对第二个孩子的看法则不同，我把他看作是“软弱的孩子”。由于我比较担心这个孩子，当我的鼻子被他打伤时，我并没有责怪他。这段经历帮助我认识到，我生气的原因不在于别人做了什么，而在于我怎么看待对方及其行为。</p></blockquote><blockquote><p>如果人们认为自己的痛苦是由其他人造成的，并认为那些人应该受到谴责或惩罚，那么，就像这位年轻的囚犯那样，他们播下了暴力的种子。</p></blockquote><blockquote><p> 在受到指责时，绝大多数的人都无法把注意力放在对方的需要上。当然，指责他人有时可以使我们达到目的———出于害怕、内疚或惭愧，他们改变了自己的行为。<br>然而，以这样的方式来满足我们的需要，我们也是在使用暴力。为了解决眼前的问题，我们制造了新的问题。批评和指责使人倾向于自我保护并变得更有攻击性。这样，就长期而言，我们给自己增添了更多的麻烦。</p></blockquote><h3 id="chapter-12-重获生活的热情"><a href="#chapter-12-重获生活的热情" class="headerlink" title="chapter 12 重获生活的热情"></a>chapter 12 重获生活的热情</h3><h3 id="chapter-13-表达感激"><a href="#chapter-13-表达感激" class="headerlink" title="chapter 13 表达感激"></a>chapter 13 表达感激</h3><blockquote><p>以色列前总理 Golda Meir：“不要那么谦虚，因为你没有那么伟大。”</p></blockquote><blockquote><p> 在别人表达感激时，人们通常有两种截然不同的反应。一种是自我膨胀，相信我们比别人优越；一种是假谦虚，否定别人的欣赏，耸耸肩说：“哦，这没什么。”</p></blockquote><blockquote><p>指责别人是很容易的。人们常常觉得自己受到了指责，有时他们自己也同意，并开始恨自己—但这并不意味着他们会改变自己的行为。</p></blockquote><blockquote><p>一件值得做的事情即使做得不怎么样也是值得的。</p></blockquote><blockquote><p>在表达感激时，我们说出:（1）对我们有益的行为；（2）我们的哪些需要得到了满足；（3）我们的需要得到满足后，我们是什么样的心情。<br>当别人以这样的方式表达对我们的感激时我们可以与对方一起庆祝生命的美一既不自大，也不假谦虚。</p></blockquote><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>建议每次说话前都想想，多看看，多实践</p><p>附:非力沟通模式<br>1.诚实地表达自己，而不批评、指责<br>（1）观察<br>我所观察（看、听、回忆、想）到的有助于（或无助于）我的福<br>祉的具体行为:<br>“当我（看、听、想到我看到的/听到的）…<br>（2）感受<br>对于这些行为，我有什么样的感受（情感而非思想）<br>“我感到…<br>（3）需要<br>什么样的需要或价值（而非偏好或某种具体的行为）导致我那样的<br>感受:<br>“因为我需要/看重……”<br>（4）请求<br>清楚地请求（而非命令）那些能丰富我生命的具体行为，<br>“你是否愿意……？”<br>2.关切地倾听他人，而不解读为批评或指责<br>（1）观察<br>你所观察（看、听、回忆、想）到的有助于（或无助于）你的福<br>祉的具体行为:<br>“当你（看、听、想到你看到的/听<br>到的）<br>（2）感受<br>对于这些行为，你有什么样的感受（是情感而非思想）:<br>“你感到…吗？”<br>什么样的需要或价值（而非偏好或某种具体的行为）导致你那样的（3）需要<br>感受:<br>“因为你需要/看重…”<br>关切地倾听那些能丰富你生命的具体请求，而不解读为命令:<br>（4）请求<br>“所以，你想。。。 “</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具成长类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string-problems-easy</title>
      <link href="/2019/10/05/string-problems-easy/"/>
      <url>/2019/10/05/string-problems-easy/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h3 id="1108-Defanging-an-IP-Address"><a href="#1108-Defanging-an-IP-Address" class="headerlink" title="1108.Defanging an IP Address"></a>1108.Defanging an IP Address</h3><p><strong>题目描述：</strong></p><p>Given a valid (IPv4) IP <code>address</code>, return a defanged version of that IP address.</p><p>A <em>defanged IP address</em> replaces every period <code>&quot;.&quot;</code> with <code>&quot;[.]&quot;</code>.</p><p><strong>Example 1:</strong></p><pre><code>Input: address = &quot;1.1.1.1&quot;Output: &quot;1[.]1[.]1[.]1&quot;</code></pre><h4 id="solution1-遍历"><a href="#solution1-遍历" class="headerlink" title="solution1-遍历"></a>solution1-遍历</h4><ul><li>用一个新的串来记录结果，遍历原串，当遇到’.’时，结果串用”[.]”替代，否则用原串字符</li><li>时间：O(n),空间：O(n)</li><li>本来是想用string的库做，但是对于插入定位这件事就难倒我了。<ul><li>用iterator，用for循环去判断是否到结尾，但是只要插入元素，add.end()的iterator变了</li><li>用replace，也不行，insert 和 find 结合，编译总是显示 out of range，在codeblock上是没错的。</li></ul></li></ul><pre><code class="c++">class Solution &#123;public:    string defangIPaddr(string address) &#123;        string res = &quot;&quot;, str = &quot;[.]&quot;;        string::iterator it;        for(it = address.begin(); it != address.end(); it++)&#123;            if(*it == &#39;.&#39;)                res += str;            else                res += *it;        &#125;        return res;    &#125;&#125;;</code></pre><h3 id="709-To-Lower-Case"><a href="#709-To-Lower-Case" class="headerlink" title="709. To Lower Case"></a>709. To Lower Case</h3><p><strong>题目描述</strong>：</p><p>Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;Hello&quot;Output: &quot;hello&quot;</code></pre><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><ul><li>ascii码表：大写字母 ：65-90，小写字母：97-122</li></ul><pre><code class="C++">class Solution &#123;public:    string toLowerCase(string str) &#123;        int len = str.size();        for(int i = 0; i&lt; len; i++)&#123;            if(str[i] &lt;= 90 &amp;&amp; str[i] &gt;= 65)                str[i] += 32;        &#125;        return str;    &#125;&#125;;</code></pre><h3 id="804-Unique-Morse-Code-Words"><a href="#804-Unique-Morse-Code-Words" class="headerlink" title="804. Unique Morse Code Words"></a>804. Unique Morse Code Words</h3><p><strong>问题描述</strong></p><p>将字符串转换为摩尔斯电码表示，就是一种映射，返回的是结果中摩尔斯电码的不同的个数</p><p><strong>Example:</strong></p><pre><code>Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]Output: 2Explanation: The transformation of each word is:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;.</code></pre><h4 id="solution-集合set的使用"><a href="#solution-集合set的使用" class="headerlink" title="solution-集合set的使用"></a>solution-集合set的使用</h4><ul><li>看到那么长的映射，以为是考智力，找规律，直接放弃，看了别人的解法，不得不钦佩</li><li>每遍历一个单词，依次遍历其字符，并记录对应的国际摩尔斯电码，当一个单词遍历完，则拼接出单词对应的结果。把结果放入集合set中，因为unordered_set是无序的，比set快，且其中元素无重复。最后返回set集合的大小，就是不同的转换。</li><li>时间：O(n)，空间：O(2n)；n是单词个数</li></ul><pre><code class="C++">class Solution &#123;public:    int uniqueMorseRepresentations(vector&lt;string&gt;&amp; words) &#123;        vector&lt;string&gt;code&#123;&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;&#125;;        unordered_set&lt;string&gt;ret;//一提到找不同，首当其冲的就是集合                    for(string str : words)&#123;            string res = &quot;&quot;;            for(char c : str)&#123;                res += code[c - &#39;a&#39;];//这点很厉害，直接定位到数组中对应的元素            &#125;            ret.insert(res);        &#125;        return ret.size();    &#125;&#125;;</code></pre><h3 id="657-Robot-Return-to-Origin"><a href="#657-Robot-Return-to-Origin" class="headerlink" title="657. Robot Return to Origin"></a>657. Robot Return to Origin</h3><p><strong>题目描述：</strong></p><p>Valid moves are R (right), L (left), U (up), and D (down). If the robot  returns to the origin after it finishes all of its moves, return true.  Otherwise, return false.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;UD&quot;Output: true Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.</code></pre><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><ul><li>想要返回true，需要左右移动，上下移动的次数一样多</li></ul><pre><code class="C++">class Solution &#123;public:    bool judgeCircle(string moves) &#123;        int l = 0, u = 0;        for(char c : moves)&#123;            switch(c)&#123;                case &#39;L&#39;:l++;break;                case &#39;R&#39;:l--;break;                case &#39;U&#39;:u++;break;                case &#39;D&#39;:u--;break;            &#125;           &#125;        return l == u &amp;&amp; l == 0;            &#125;&#125;;</code></pre><h3 id="929-Unique-Email-Addresses"><a href="#929-Unique-Email-Addresses" class="headerlink" title="929. Unique Email Addresses"></a>929. Unique Email Addresses</h3><p><strong>题目描述</strong>：</p><p>For example, in <code>alice@leetcode.com</code>, <code>alice</code> is the local name, and <code>leetcode.com</code> is the domain name.</p><p>local name：如果有”.”，忽略，如果有”+”，第一个加号之后的都忽略，可用来过滤邮件（这两条规则对于domain name不适用）</p><p>返回能够收到邮件的不同地址个数。</p><p><strong>Example 1:</strong></p><pre><code>Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]Output: 2Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails</code></pre><h4 id="solution-遍历"><a href="#solution-遍历" class="headerlink" title="solution-遍历"></a>solution-遍历</h4><ul><li><p>将email地址分为local和doamin两部分处理，只有两部分都满足题目要求时，将处理的结果拼接成合法的地址，insert到set中，最后返回set中的地址个数。</p></li><li><p>时间：O(n)，n是email的个数；空间：O(n)</p></li><li><p>看别人比较快的代码，似乎domain部分不需要做判断</p></li></ul><pre><code class="C++">class Solution &#123;public:    int numUniqueEmails(vector&lt;string&gt;&amp; emails) &#123;        unordered_set&lt;string&gt;res; //用set存储唯一的地址                for(string email : emails)&#123;            int pos = email.find(&quot;@&quot;),len = email.size();            string ret1 = &quot;&quot;;                        string local(email,0,pos);            string domain(email,pos+1,len-pos);                        bool isLocal = checkLocal(local,ret1);            //bool isDomain = checkDomain(domain);            // &amp;&amp; isDomain            if(isLocal)&#123;                //cout&lt;&lt;ret1+&quot;@&quot;+domain&lt;&lt;endl;                 res.insert(ret1+&quot;@&quot;+domain);            &#125;                       &#125;        return res.size();            &#125;    bool checkLocal(string local, string &amp;ret1)&#123;        for(char c : local)&#123;            if(c == &#39;.&#39;)//点则跳过，                continue;            else if(c == &#39;+&#39;)//之后的都忽略                break;            else                ret1+=c;        &#125;        return true;    &#125;    //没看懂题目，domain里面原来可以有多个&#39;.&#39;    /*bool checkDomain(string domain)&#123;        for(char c : domain)&#123;            if((c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || c == &#39;.&#39;)//记得加等号！！！                continue;            else                return false;        &#125;        return true;    &#125;*/&#125;;</code></pre><h3 id="557-Reverse-Words-in-a-String-III"><a href="#557-Reverse-Words-in-a-String-III" class="headerlink" title="557. Reverse Words in a String III"></a>557. Reverse Words in a String III</h3><p><strong>题目描述</strong>：</p><p>Given a string, you need to reverse the order of characters in each  word within a sentence while still preserving whitespace and initial  word order.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;Let&#39;s take LeetCode contest&quot;Output: &quot;s&#39;teL ekat edoCteeL tsetnoc&quot;</code></pre><h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><pre><code class="C++">class Solution &#123;public:    string reverseWords(string s) &#123;        int len = s.size();        int beg = 0;        int pos = s.find(&quot; &quot;,0);//老年人的劝告，少用这种find空格的方式        while(pos != std::string::npos)&#123;            reverseWord(s,beg,pos-1);            beg = pos+1;            pos = s.find(&quot; &quot;,beg);        &#125;        reverseWord(s,beg,len-1);        return s;            &#125;    void reverseWord(string&amp; str,int beg, int en)&#123;        for(int i = beg,j = en; i &lt; j; i++,j--)&#123;            str[i] ^= str[j];            str[j] ^= str[i];            str[i] ^= str[j];        &#125;    &#125;&#125;;</code></pre><h3 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344. Reverse String"></a>344. Reverse String</h3><p>题目描述：</p><p>Write a function that reverses a string. The input string is given as an array of characters <code>char[]</code>.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>You may assume all the characters consist of <a href="https://en.wikipedia.org/wiki/ASCII#Printable_characters">printable ascii characters</a>.</p><p><strong>Example 1:</strong></p><pre><code>Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></pre><h4 id="solution1-按异或操作符实现元素交换"><a href="#solution1-按异或操作符实现元素交换" class="headerlink" title="solution1-按异或操作符实现元素交换"></a>solution1-按异或操作符实现元素交换</h4><ul><li>看运行时间，似乎也不是很有效</li><li>时间O(n)，空间O(1)</li><li>swap：和1的做法差不多，但是时间会少一些</li></ul><pre><code class="C++">class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        char tmp;        int len = s.size();        for(int i = 0; i &lt; len/2; i++)&#123;            tmp = s.at(i) ;            s.at(i) = s.at(len - i - 1);            s.at(len - i - 1) = tmp;        &#125;    &#125;&#125;;</code></pre><h4 id="solution2-用string的库函数-reverse"><a href="#solution2-用string的库函数-reverse" class="headerlink" title="solution2-用string的库函数.reverse"></a>solution2-用string的库函数.reverse</h4><pre><code class="C++">class Solution &#123;public:    void reverseString(vector&lt;char&gt;&amp; s) &#123;        reverse(s.begin(),s.end());    &#125;&#125;;</code></pre><h3 id="1170-Compare-Strings-by-Frequency-of-the-Smallest-Character"><a href="#1170-Compare-Strings-by-Frequency-of-the-Smallest-Character" class="headerlink" title="1170. Compare Strings by Frequency of the Smallest Character"></a>1170. Compare Strings by Frequency of the Smallest Character</h3><p><strong>题目描述</strong></p><p>Let’s define a function <code>f(s)</code> over a non-empty string <code>s</code>, which <strong>calculates the frequency of the smallest character</strong> in <code>s</code>. For example, if <code>s = &quot;dcce&quot;</code> then <code>f(s) = 2</code> because the smallest character is <code>&quot;c&quot;</code> and its frequency is 2.</p><p>Now, given string arrays <code>queries</code> and <code>words</code>, return an integer array <code>answer</code>, where each <code>answer[i]</code> is the number of words such that <code>f(queries[i])</code> &lt; <code>f(W)</code>, where <code>W</code> is a word in <code>words</code>.</p><p>answer的个数和queries的个数一样，值的范围是[0,w.size()];</p><p><strong>Example 2:</strong></p><pre><code>Input: queries = [&quot;bbb&quot;,&quot;cc&quot;], words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]Output: [1,2]Explanation: On the first query only f(&quot;bbb&quot;) &lt; f(&quot;aaaa&quot;). On the second query both f(&quot;aaa&quot;) and f(&quot;aaaa&quot;) are both &gt; f(&quot;cc&quot;).</code></pre><h4 id="solution-sort"><a href="#solution-sort" class="headerlink" title="solution-sort"></a>solution-sort</h4><ul><li>没有任何技术含量的，一步步按照人脑实现</li><li>先分别统计最小字符的个数，然后进行比较</li><li>时间：O(n^2)，n是字符的个数，空间：O(3n)，包括存储次数，以及结果的vector</li></ul><pre><code class="C++">class Solution &#123;public:    //计算每个字符串内最小的字符出现的次数        int numbers(string query)&#123;            int num1 = 1;            char tmp = query[0];            for(int i = 1; i&lt; query.size();i++)&#123;                if(query[i] == tmp)&#123;                    num1++;                &#125;else                    break;            &#125;            return num1;    &#125;        vector&lt;int&gt; numSmallerByFrequency(vector&lt;string&gt;&amp; queries, vector&lt;string&gt;&amp; words) &#123;                vector&lt;int&gt; q,w;            //分别计算queries和words中字符串的最小字符个数        for(string query:queries)&#123;            sort(query.begin(),query.end());             int numq = numbers(query);            q.push_back(numq);                    &#125;                    for(string word:words)&#123;            sort(word.begin(),word.end());                        int numw = numbers(word);             w.push_back(numw);        &#125;               //统计结果        //sort(q.begin(),q.end());//输出时不能改变原来的顺序        sort(w.begin(),w.end());            vector&lt;int&gt;res;        int lenw = w.size();        for(int numq : q)&#123;            int ret = 0;            for(int i = 0; i &lt; lenw; i++)&#123;                if(numq &lt; w[i])&#123;                    ret = lenw-i;                    break;                &#125;                                &#125;            res.push_back(ret);        &#125;        return res;    &#125;&#125;;</code></pre><h4 id="solution2-比较精巧，但是得仔细理解"><a href="#solution2-比较精巧，但是得仔细理解" class="headerlink" title="solution2-比较精巧，但是得仔细理解"></a>solution2-比较精巧，但是得仔细理解</h4><pre><code>class Solution &#123;public:    //用hash表的形式获取字符串的最小字符出现频率，这样就不需要对原串进行排序了    int getF(string s)&#123;        int f[26] = &#123;0,&#125;;        for(char c:s)&#123;            f[c-&#39;a&#39;]++;        &#125;        for(int i: f)&#123;            if(i &gt; 0)                return i;        &#125;        return 0;    &#125;        vector&lt;int&gt; numSmallerByFrequency(vector&lt;string&gt;&amp; queries, vector&lt;string&gt;&amp; words) &#123;        vector&lt;int&gt;fr(12,0);//用来统计words中，最小字符串的长度在1-10之间的个数        for(string word:words)&#123;            int f = getF(word);            fr[f]++;        &#125;        //从后向前统计，大于当前个数的最小字符串是多少个        for(int i = 9; i &gt;=0; i--)&#123;            fr[i] += fr[i+1];        &#125;                vector&lt;int&gt;res;        for(string query:queries)&#123;            int f = getF(query);            res.push_back(fr[f+1]);//fr必须是12，如果是11，当这里的f是10，那么访问fr[11]，需要的就是12个元素大小的空间        &#125;        return res;            &#125;&#125;;</code></pre><h3 id="824-Goat-Latin"><a href="#824-Goat-Latin" class="headerlink" title="824. Goat Latin"></a>824. Goat Latin</h3><p><strong>题目描述</strong></p><p>The rules of Goat Latin are as follows:</p><ul><li>If a word begins with a vowel (a, e, i, o, or u), append <code>&quot;ma&quot;</code> to the end of the word.<pre><code> For example, the word &#39;apple&#39; becomes &#39;applema&#39;.</code></pre></li><li>If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add <code>&quot;ma&quot;</code>.<pre><code> For example, the word `&quot;goat&quot;` becomes `&quot;oatgma&quot;`.</code></pre></li><li>Add one letter <code>&#39;a&#39;</code> to the end of each word per its word index in the sentence, starting with 1.<pre><code> For example, the first word gets `&quot;a&quot;` added to the end, the second word gets `&quot;aa&quot;` added to the end and so on.</code></pre></li></ul><p>Return the final sentence representing the conversion from <code>S</code> to Goat Latin. </p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;I speak Goat Latin&quot;Output: &quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot;</code></pre><h4 id="solution-string库函数使用，下标移动"><a href="#solution-string库函数使用，下标移动" class="headerlink" title="solution-string库函数使用，下标移动"></a>solution-string库函数使用，下标移动</h4><ul><li>主要思路：按照第一个字符是否为元音，分为两种处理方法<ul><li>是元音，直接在结尾添加ma</li><li>不是元音，将子串开头字符添加到结尾，删除开头字符，添加ma</li></ul></li><li>对于拼接好的单词，还需要根据这是第几个单词，在单词最后加入几个a，这个用cnt来记录当前处理的是第几个元素，生成cnt长度的新子串，添加在单词后即可。</li><li>时间：O(n)，n是单词的个数，空间：O(C)，C是a的个数</li></ul><pre><code class="C++">class Solution &#123;public:    void convert(string&amp; S,int beg, int pos)&#123;        switch(S[beg])&#123;                case &#39;a&#39;: case &#39;A&#39;:                case &#39;e&#39;: case &#39;E&#39;:                case &#39;i&#39;: case &#39;I&#39;:                case &#39;o&#39;: case &#39;O&#39;:                case &#39;u&#39;: case &#39;U&#39;:                    S.insert(pos,&quot;ma&quot;);                    break;                default:                    S.insert(pos,1,S[beg]);                    S.erase(beg,1);                    S.insert(pos,&quot;ma&quot;);                    break;                        &#125;    &#125;        string toGoatLatin(string S) &#123;        int pos = S.find(&quot; &quot;,0);        int beg = 0;        int cnt = 0;                while(pos!=std::string::npos )&#123;            cnt++;            convert(S,beg,pos);            pos = S.find(&quot; &quot;,pos);            string tmp(cnt,&#39;a&#39;);            S.insert(pos,tmp);                                beg = pos+cnt+1;            pos = S.find(&quot; &quot;,beg);        &#125;                cnt++;//处理最后一个元素                convert(S,beg,S.size());                int len = S.size();        string tmp(cnt,&#39;a&#39;);        S.insert(len,tmp);        return S;    &#125;&#125;;</code></pre><h3 id="521-Longest-Uncommon-Subsequence-I"><a href="#521-Longest-Uncommon-Subsequence-I" class="headerlink" title="521. Longest Uncommon Subsequence I"></a>521. Longest Uncommon Subsequence I</h3><p><strong>题目描述</strong></p><p>Given a group of two strings, you need to find the longest uncommon  subsequence of this group of two strings.<br>The longest uncommon subsequence is defined as the longest subsequence  of one of these strings and this subsequence should not be <strong>any</strong> subsequence of the other strings.</p><p>A <strong>subsequence</strong> is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty<br>string is a subsequence of any string.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;aba&quot;, &quot;cdc&quot;Output: 3Explanation: The longest uncommon subsequence is &quot;aba&quot; (or &quot;cdc&quot;), because &quot;aba&quot; is a subsequence of &quot;aba&quot;, but not a subsequence of any other strings in the group of two strings. </code></pre><h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h4><ul><li>看solution，完全是脑筋急转弯</li><li>按道理，要把两个串的所有子序列求出来，对比看有没有子序列才对吧？但是这种情况是指，有公共子序列。对于没有的情况，就是长度最长的串本身。</li><li>时间：O(1)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    int findLUSlength(string a, string b) &#123;        if(a == b)            return -1;        int len1 = a.size(),len2 = b.size();        return len1&gt;=len2?len1:len2;            &#125;&#125;;</code></pre><h3 id="917-Reverse-Only-Letters"><a href="#917-Reverse-Only-Letters" class="headerlink" title="917. Reverse Only Letters"></a>917. Reverse Only Letters</h3><p><strong>题目描述</strong></p><p>Given a string <code>S</code>, return the “reversed” string where all  characters that are not a letter stay in the same place, and all letters reverse their positions.</p><p><strong>Example 2:</strong></p><pre><code>Input: &quot;a-bC-dEf-ghIj&quot;Output: &quot;j-Ih-gfE-dCba&quot;</code></pre><h4 id="solution1-双指针遍历，交换"><a href="#solution1-双指针遍历，交换" class="headerlink" title="solution1-双指针遍历，交换"></a>solution1-双指针遍历，交换</h4><ul><li>最左，最右双指针遍历<ul><li>遇到非字母的，则跳过</li><li>只有当两个都是字母时交换；</li></ul></li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    string reverseOnlyLetters(string S) &#123;        int len = S.size();        int left = 0, right = len-1;        while(left &lt; right)&#123;            char l = S[left] ,r = S[right];            if(isLetter(l)  &amp;&amp; isLetter(r))&#123;                char tmp = S[left];                S[left] = S[right];                S[right] = tmp;                left++;                right--;            &#125;else if(!isLetter(l) &amp;&amp; !isLetter(r))&#123;                left++;                right--;            &#125;else if(!isLetter(l))                left++;            else                right--;        &#125;        return S;            &#125;    bool isLetter(char s)&#123;        if((s &gt;= &#39;a&#39; &amp;&amp; s &lt;= &#39;z&#39;) || (s &gt;=&#39;A&#39; &amp;&amp; s &lt;= &#39;Z&#39;) )            return true;        else             return false;    &#125;&#125;;</code></pre><h4 id="solution2-stack"><a href="#solution2-stack" class="headerlink" title="solution2-stack"></a>solution2-stack</h4><ul><li>看解答，发现还是很有意思的一个思路，因为需要逆序字符串，因此可以用栈，这道题目就是将字符串逆序输出，其他字符保持在原位置不变。</li><li>时间：O(2n),需要扫描两边原字符串，空间：O(n)，额外的stack及返回字符串</li></ul><pre><code class="C++">class Solution &#123;public:    bool isLetter(char s)&#123;        if((s &gt;= &#39;a&#39; &amp;&amp; s &lt;= &#39;z&#39;) || (s &gt;=&#39;A&#39; &amp;&amp; s &lt;= &#39;Z&#39;) )            return true;        else             return false;    &#125;        string reverseOnlyLetters(string S) &#123;        stack&lt;char&gt; tmp;        for(char c:S)&#123;            if(isLetter(c))                tmp.push(c);        &#125;        string res;        for(char c:S)&#123;            if(isLetter(c))&#123;                res.append(1,tmp.top());                tmp.pop();            &#125;else                res.append(1,c);              &#125;        return res;    &#125;&#125;;</code></pre><h3 id="788-Rotated-Digits"><a href="#788-Rotated-Digits" class="headerlink" title="788. Rotated Digits"></a>788. Rotated Digits</h3><p><strong>题目描述</strong></p><p>A number is valid if each digit remains a digit after rotation. 0, 1,  and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9  rotate to each other, and the rest of the numbers do not rotate to any  other number and become invalid.</p><p>Now given a positive number <code>N</code>, how many numbers X from <code>1</code> to <code>N</code> are good?</p><p><strong>Example</strong>:</p><pre><code>Input: 10Output: 4Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.</code></pre><h4 id="solution-dp记录表"><a href="#solution-dp记录表" class="headerlink" title="solution-dp记录表"></a>solution-dp记录表</h4><ul><li>本以为代码越敲，就会渐入佳境，结果却是：连题目都读不懂了呜呜呜</li><li>这道题乍得一看有点难，看了别人的解法才知道题目想表达的意思。</li><li>越来越大的数字都是由小数字组成的，那么通过读小数字是否为good num就可以判断大数是否为good</li><li>当数字为good时，必须包含2||5||6||9，同时可以包含0，1，8</li><li>只包含0，1，8 时只能说是valid的，不能是good的</li><li>当数字包含 3，4，7时，一定是invalid的</li><li>时间：O(n)，n是数字的个数，空间，O(n)</li></ul><pre><code class="C++">class Solution &#123;public:    int rotatedDigits(int N) &#123;        int dp[N+1] = &#123;0,&#125; ;        int cnt = 0;        for(int i = 0; i &lt;= N;i++)&#123;        if(i &lt; 10)&#123;            if(i == 0 || i == 1 || i == 8)                dp[i] = 1;            else if(i == 2 || i == 5 || i == 6 || i == 9)&#123;                       dp[i] = 2;                 cnt++;            &#125;        &#125;else&#123;            int a = dp[i/10], b = dp[i%10];            if(a == 1 &amp;&amp; b == 1)                dp[i] = 1;            else if(a &gt;= 1 &amp;&amp; b &gt;= 1)&#123;                dp[i] = 2;//说明这个数的组成是2，5，6，9，0，1，8                cnt++;                               &#125;                  &#125;        &#125;        return cnt;    &#125;&#125;;</code></pre><h3 id="696-Count-Binary-Substrings"><a href="#696-Count-Binary-Substrings" class="headerlink" title="696. Count Binary Substrings"></a>696. Count Binary Substrings</h3><p><strong>题目描述</strong></p><p>Give a string <code>s</code>, count the number of non-empty  (contiguous) substrings that have the same number of 0’s and 1’s, and  all the 0’s and all the 1’s in these substrings are grouped  consecutively.  </p><p>Substrings that occur multiple times are counted the number of times they occur.</p><p><strong>Example 2:</strong></p><pre><code>Input: &quot;10101&quot;Output: 4Explanation: There are 4 substrings: &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;01&quot; that have equal number of consecutive 1&#39;s and 0&#39;s.</code></pre><h4 id="solution-线性扫描"><a href="#solution-线性扫描" class="headerlink" title="solution-线性扫描"></a>solution-线性扫描</h4><ul><li>遇到相同的就加，遇到不同的就开始统计，看这种连续性是几个</li><li>相当于把1和0分成group</li><li>时间：O(n),空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    int countBinarySubstrings(string s) &#123;        int len = s.size();        int pre = 0,cur = 1, sum = 0;//pre是上一个group中相同元素的个数，cur是当前的，这就是相当于对0和1分组        for(int i = 1; i &lt; len; i++)&#123;            if(s[i] == s[i-1])&#123;                cur++;            &#125;else&#123;                sum += min(cur,pre);                pre = cur;                cur = 1;            &#125;                    &#125;        sum += min(cur,pre);        return sum;    &#125;&#125;;</code></pre><h3 id="937-Reorder-Data-in-Log-Files"><a href="#937-Reorder-Data-in-Log-Files" class="headerlink" title="937. Reorder Data in Log Files"></a>937. Reorder Data in Log Files</h3><p><strong>题目描述</strong></p><p>Reorder the logs so that all of the letter-logs come before any  digit-log.  The letter-logs are ordered lexicographically ignoring  identifier, with the identifier used in case of ties.  The digit-logs  should be put in their original order.</p><p>Return the final order of the logs.</p><p><strong>Example 1:</strong></p><pre><code>Input: logs = [&quot;dig1 8 1 5 1&quot;,&quot;let1 art can&quot;,&quot;dig2 3 6&quot;,&quot;let2 own kit dig&quot;,&quot;let3 art zero&quot;]Output: [&quot;let1 art can&quot;,&quot;let3 art zero&quot;,&quot;let2 own kit dig&quot;,&quot;dig1 8 1 5 1&quot;,&quot;dig2 3 6&quot;]</code></pre><h4 id="solution-stable-sort"><a href="#solution-stable-sort" class="headerlink" title="solution-stable_sort"></a>solution-stable_sort</h4><ul><li>通过对标识符后的第一个字符进行比较，得出是isalpha or isdigit</li><li>isalpha,则进入结果vector，否则，进入临时vector<ul><li>这样分开装的原因是，两者的排序要求不同，对于前者，则需要对标识符之外的串进行比较，而对于后者，则简单的排在前者后面就可以。</li></ul></li><li>比较花时间的地方就是：如何对vector中的字符串，去掉某部分后进行大小比较，用comparator，要注意的是：cmp函数写在类内需要用static关键字修饰，类外则可以不用。</li><li>时间：O(n)，n是字符串的个数，空间：O(n)，两部分用于存储字符串的vector</li></ul><pre><code>bool cmp(string str1, string str2)&#123;        int pos1 = str1.find(&#39; &#39;);        int pos2 = str2.find(&#39; &#39;);        string sa = str1.substr(pos1+1);        string sb = str2.substr(pos2+1);        if(sa.compare(sb) == 0)//如果除了标识符之外的地方相等，那么就要对标识符也做判断进行排序了            return str1 &lt; str2;        else            return sa &lt; sb;    &#125;class Solution &#123;public:    //很迷，就一个static搞了我半个小时,如果放在类内作为比较函数，则必须要加static    /*    static bool cmp(string str1, string str2)&#123;        int pos1 = str1.find(&#39; &#39;);        int pos2 = str2.find(&#39; &#39;);        return str1.substr(pos1+1) &lt; str2.substr(pos2+1);    &#125;    */    vector&lt;string&gt; reorderLogFiles(vector&lt;string&gt;&amp; logs) &#123;        vector&lt;string&gt;res;        vector&lt;string&gt;tmp;                for(string str:logs)&#123;            int pos = str.find(&#39; &#39;);//find还可以用来查找某个完整的单词呢·就是string了            if(isdigit(str[pos+1]))                tmp.push_back(str);            else                res.push_back(str);        &#125;        stable_sort(res.begin(),res.end(),cmp);//不仅要比较，对于后面都相等的，还需要保持原来的顺序         for(string s:tmp)&#123;            res.push_back(s);        &#125;        return res;    &#125;&#125;;</code></pre><h3 id="1071-Greatest-Common-Divisor-of-Strings"><a href="#1071-Greatest-Common-Divisor-of-Strings" class="headerlink" title="1071. Greatest Common Divisor of Strings"></a>1071. Greatest Common Divisor of Strings</h3><p>For strings <code>S</code> and <code>T</code>, we say “<code>T</code> divides <code>S</code>“ if and only if <code>S = T + ... + T</code>  (<code>T</code> concatenated with itself 1 or more times)</p><p>Return the largest string <code>X</code> such that <code>X</code> divides str1 and <code>X</code> divides str2.</p><h4 id="solution-gcd"><a href="#solution-gcd" class="headerlink" title="solution-gcd"></a>solution-gcd</h4><ul><li>就是两个整数的最大公约数的变形，还做了一个多小时。。。。蠢啊</li><li>自己写的代码也一眼难尽，丑陋！</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    string gcdOfStrings(string str1, string str2) &#123;        //使得较长串始终为第一个串,这tm都能写错，这谁顶得住？？        if(str1.size() &lt; str2.size())&#123;            string tmp = str2;            str2 = str1;            str1 = tmp;        &#125;        int len2 = str2.size();        //==0，表示两个字符串相等        //&gt;0，表示被比较字符串小        if(str1.compare(0,len2,str2) != 0)            return &quot;&quot;;                if(str2.empty())            return str1;                return gcdOfStrings(str2,str1.substr(len2));    &#125;&#125;;</code></pre><h4 id="solution-gcd-1"><a href="#solution-gcd-1" class="headerlink" title="solution-gcd"></a>solution-gcd</h4><ul><li>别人的解释，对于两个串，S1 = nT，S2 = mT，n&gt;m，S3 = (n-m)T = xT; S1 = xT, S2 = mT,…,直到S2为空，返回S1，因为S1始终是长一点的那个。</li></ul><pre><code class="C++">class Solution &#123;public:    string gcdOfStrings(string str1, string str2) &#123;        int len2 = str2.size();        if(str1.size() &lt; len2)            return gcdOfStrings(str2,str1);        if(str2.empty())            return str1;        if(str1.compare(0,len2,str2) != 0)            return &quot;&quot;;        return gcdOfStrings(str1.substr(len2),str2);//str2始终是短的那个，所以一直在后面    &#125;&#125;;</code></pre><h3 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. Roman to Integer</h3><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p><pre><code>Symbol       ValueI             1V             5X             10L             50C             100D             500M             1000</code></pre><p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><p><strong>Example 5:</strong></p><pre><code>Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</code></pre><ul><li>总的来说，解题思路是，结果是每一位的和，但是存在加完了前面的需要减去的情况，比如IV，对于这种特例，两种解决方案。</li></ul><h3 id="solution1-hash-map"><a href="#solution1-hash-map" class="headerlink" title="solution1-hash_map"></a>solution1-hash_map</h3><ul><li>从后向前遍历，如果s[i] &lt; s[i+1]，那么需要减去s[i]，否则加上就行。</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    int romanToInt(string s)&#123;        unordered_map&lt;char,int&gt; M = &#123;&#123;'I',1&#125;,                                     &#123;'V',5&#125;,                                     &#123;'X',10&#125;,                                     &#123;'L',50&#125;,                                     &#123;'C',100&#125;,                                     &#123;'D',500&#125;,                                     &#123;'M',1000&#125;&#125;;        int sum = M[s.back()];        for(int i = s.size() - 2; i &gt;= 0; i--)&#123;            if(M[s[i]] &lt; M[s[i+1]])                sum -= M[s[i]];            else                 sum += M[s[i]];        &#125;        return sum;    &#125;&#125;;</code></pre><h3 id="solution2"><a href="#solution2" class="headerlink" title="solution2-"></a>solution2-</h3><ul><li>先搜索字符串内有没有这类组合，有的话分别减去2，20，200，接着从前向后遍历，依次相加即可；因为加的过程中会多加</li><li>时间：O(n)，空间：O(2n)</li></ul><pre><code class="C++">class Solution &#123;public:    int romanToInt(string s) &#123;        int sum = 0;        if(s.find(&quot;IV&quot;,0) != string::npos) sum-=2;//原本是加4，但是后面遍历加的时候是先加了1，又加了5，就是多加了2        if(s.find(&quot;IX&quot;,0) != string::npos) sum-=2;        if(s.find(&quot;XL&quot;,0) != string::npos) sum-=20;        if(s.find(&quot;XC&quot;,0) != string::npos) sum-=20;        if(s.find(&quot;CD&quot;,0) != string::npos) sum-=200;        if(s.find(&quot;CM&quot;,0) != string::npos) sum-=200;                for(char c: s)&#123;            switch(c)&#123;                case &#39;I&#39;:sum+=1;break;                case &#39;V&#39;:sum+=5;break;                case &#39;X&#39;:sum+=10;break;                case &#39;L&#39;:sum+=50;break;                case &#39;C&#39;:sum+=100;break;                case &#39;D&#39;:sum+=500;break;                case &#39;M&#39;:sum+=1000;break;                                &#125;        &#125;        return sum;            &#125;&#125;;</code></pre><h3 id="520-Detect-Capital"><a href="#520-Detect-Capital" class="headerlink" title="520. Detect Capital"></a>520. Detect Capital</h3><p><strong>题目描述</strong></p><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p><p>We define the usage of capitals in a word to be right when one of the following cases holds:</p><ol><li>All letters in this word are capitals, like “USA”.</li><li>All letters in this word are not capitals, like “leetcode”.</li><li>Only the first letter in this word is capital, like “Google”.</li></ol><p> Otherwise, we define that this word doesn’t use capitals in a right way.  </p><h4 id="solution-4"><a href="#solution-4" class="headerlink" title="solution"></a>solution</h4><ul><li>字符串的前两位决定了接下来的字符串需要是大写还是小写才能合法，如果是大写，那么转入判断大写的函数，一旦发现小写就返回false，反之亦然。</li><li>注意要判断 word 只有一个字符的特例</li><li>时间：O(n)，空间：(1)</li></ul><pre><code class="C++">class Solution &#123;public:    bool detectCapitalUse(string word) &#123;        if(word.size() == 1)            return true;        if(word[0] &gt;= &#39;A&#39; &amp;&amp; word[0] &lt;= &#39;Z&#39;)&#123;            if(word[1] &gt;= &#39;A&#39; &amp;&amp; word[1] &lt;= &#39;Z&#39;)                return isUpper(word.substr(2));            else                 return isLower(word.substr(2));        &#125;        else             return isLower(word.substr(1));            &#125;    bool isUpper(string str)&#123;        for(char c:str)&#123;            if(c &lt; &#39;A&#39; || c &gt; &#39;Z&#39;)                return false;        &#125;        return true;    &#125;    bool isLower(string str)&#123;        for(char c:str)&#123;            if(c &lt; &#39;a&#39; || c &gt; &#39;z&#39;)                return false;        &#125;        return true;    &#125;&#125;;</code></pre><h3 id="606-Construct-String-from-Binary-Tree"><a href="#606-Construct-String-from-Binary-Tree" class="headerlink" title="606. Construct String from Binary Tree"></a>606. Construct String from Binary Tree</h3><p>You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.</p><p><strong>Example 2:</strong></p><pre><code>Input: Binary tree: [1,2,3,null,4]       1     /   \    2     3     \        4 Output: &quot;1(2()(4))(3)&quot;</code></pre><ul><li>需要注意的是，对于字符串使用“+”,则连续拼接的不能是两个常字符串，需要把整数转换为字符串<ul><li>在整数后面+””强制类型转换为字符串</li><li>to_string(整数)</li><li>ostringstre</li><li>sprintf等</li></ul></li></ul><h4 id="solution1-递归，先序遍历"><a href="#solution1-递归，先序遍历" class="headerlink" title="solution1-递归，先序遍历"></a>solution1-递归，先序遍历</h4><ul><li>每到一个节点，只考虑以这个节点为根的子树</li><li>三种情况<ul><li>左右孩子都没有，则返回当前值即可</li><li>有左孩子，但是没有右孩子，给左孩子加上括号，遍历左孩子即可</li><li>有左右孩子，给左孩子及右孩子加括号，分别遍历</li></ul></li><li>值得注意的是，没有单独考虑有右孩子，没左孩子的情况，这是因为，左孩子不管有没有，都不需要特殊处理，是需要加括号的，而右孩子没有的情况下，是没有括号的。</li></ul><pre><code class="C++">class Solution &#123;public:    string tree2str(TreeNode* t) &#123;        if(t == NULL)            return &quot;&quot;;        string str = to_string(t-&gt;val);//拼接的时候一直有问题，必须转成字符串？？？？？fuck，我的一个小时。。。                if((t-&gt;left) == NULL &amp;&amp; (t-&gt;right) == NULL)            return  str;         if((t-&gt;right) == NULL)            return str + &quot;(&quot; + tree2str(t-&gt;left) + &quot;)&quot;;        return str + &quot;(&quot; + tree2str(t-&gt;left) + &quot;)(&quot; + tree2str(t-&gt;right) + &quot;)&quot;;    &#125;&#125;;</code></pre><h4 id="solution2-stack-1"><a href="#solution2-stack-1" class="headerlink" title="solution2-stack"></a>solution2-stack</h4><ul><li>先序遍历，顺序为根，左，右</li><li>对每一个未访问的当前节点，设置为已访问，res+=”(“ + to_string(val)</li><li>对当前节点的左右孩子进行判断，还是三种情况：<ul><li>如果是有右孩子但是没左孩子，那么结果中直接加上”()”，不需要将元素入栈</li><li>如果有右孩子，右孩子入栈</li><li>如果有左孩子，左孩子入栈，这样的先后顺序使得左孩子可以先被访问</li></ul></li><li>每一步只处理一个节点，当前栈顶节点，被访问过则弹出，没被访问过则访问</li><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="C++">class Solution &#123;public:    string tree2str(TreeNode* t) &#123;        if(t == NULL)            return &quot;&quot;;        stack&lt;TreeNode*&gt; s;        set&lt;TreeNode*&gt; visited;        string res = &quot;&quot;;        s.push(t);                while(!s.empty())&#123;            t = s.top();            if(visited.find(t) != visited.end())&#123;                s.pop();                res+= &quot;)&quot;;                //cout&lt;&lt;res&lt;&lt;endl;            &#125;else&#123;                visited.insert(t);                res+=&quot;(&quot; + to_string(t-&gt;val);                if(t-&gt;left == NULL &amp;&amp; t-&gt;right != NULL)                    res+=&quot;()&quot;;                if(t-&gt;right != NULL)//先push右边，再push左边，这样就可以先访问左边，后右边                    s.push(t-&gt;right);                if(t-&gt;left != NULL)                    s.push(t-&gt;left);            &#125;        &#125;        return res.substr(1,res.size()-2);//为了通用性，给第一个元素也是加了左右括号，最后要去掉    &#125;            &#125;;</code></pre><h3 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383. Ransom Note"></a>383. Ransom Note</h3><p><strong>题目描述</strong></p><p>ransom note 可以被magazine 构造，就是看 magazine中拥有的字符，是否足够形成ransome note，不用管字母顺序</p><p><strong>example</strong></p><pre><code>canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</code></pre><h4 id="solution1-库函数调用"><a href="#solution1-库函数调用" class="headerlink" title="solution1-库函数调用"></a>solution1-库函数调用</h4><ul><li>有点类似原串中找子序列的感觉，依次比较就完事了，结果却是理解错题目了。。</li><li>不用管字母出现的次序</li><li>时间：O(n)，空间：O(1)，效率非常低</li></ul><pre><code class="C++">class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;           for(char c : ransomNote)&#123;            int pos = magazine.find(c);            if(pos != string::npos)                magazine.erase(pos,1);            else                return false;        &#125;        return true;    &#125;&#125;;</code></pre><h4 id="solution2-map-数组"><a href="#solution2-map-数组" class="headerlink" title="solution2-map\数组"></a>solution2-map\数组</h4><ul><li>对原串中有的字符进行映射，依次累加对应字符的次数</li><li>对匹配串中的字符进行映射，一旦字符对应次数小于=0，则说明没法匹配了，返回false</li></ul><pre><code class="C++">/*class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        unordered_map&lt;char,int&gt; maga(26);        for(char c: magazine)&#123;            maga[c]++;        &#125;        for(char c : ransomNote)&#123;            if(maga[c] &lt;= 0 )                return false;            maga[c]--;        &#125;        return true;    &#125;&#125;;*/class Solution &#123;public:    bool canConstruct(string ransomNote, string magazine) &#123;        int maga[26] = &#123;0,&#125;;        for(char c: magazine)&#123;            maga[c-&#39;a&#39;]++;        &#125;        for(char c : ransomNote)&#123;            if(maga[c-&#39;a&#39;] &lt;= 0 )                return false;            maga[c-&#39;a&#39;]--;        &#125;        return true;    &#125;&#125;;</code></pre><h3 id="387-First-Unique-Character-in-a-String"><a href="#387-First-Unique-Character-in-a-String" class="headerlink" title="387. First Unique Character in a String"></a>387. First Unique Character in a String</h3><p><strong>题目描述</strong></p><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p><p><strong>example</strong></p><pre><code>s = &quot;loveleetcode&quot;,return 2.</code></pre><h4 id="solution-map"><a href="#solution-map" class="headerlink" title="solution-map"></a>solution-map</h4><ul><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="C++">class Solution &#123;public:    int firstUniqChar(string s) &#123;        int len = s.size();        int cnt[26] = &#123;0,&#125;;        for(char c:s)            cnt[c-&#39;a&#39;]++;        //因为要找出第一个单独出现的字符，那么遍历原串就可以是原来的顺序啊 ~~~你怎么这么笨，map仅仅作为一个查询的东西        for(int i = 0 ; i &lt; len; i++)&#123;            if(cnt[s[i]-&#39;a&#39;] == 1)                return i;        &#125;        return -1;    &#125;&#125;;</code></pre><h3 id="541-Reverse-String-II"><a href="#541-Reverse-String-II" class="headerlink" title="541. Reverse String II"></a>541. Reverse String II</h3><p><strong>题目描述</strong></p><p>Given a string and an integer k, you need to reverse the first k  characters for every 2k characters counting from the start of the string. </p><p>If there are less than k characters left, reverse all of them. </p><p>If there are less than 2k but greater than or equal to k characters,  then reverse the first k characters and left the other as original.</p><p><strong>Example:</strong></p><pre><code>Input: s = &quot;abcdefg&quot;, k = 2Output: &quot;bacdfeg&quot;</code></pre><h4 id="solution-5"><a href="#solution-5" class="headerlink" title="solution"></a>solution</h4><ul><li>将字符串按照2K分组（可能有余数，可能没有），对每个组内的前k个做逆转</li><li>对于最后一个不足2k的，单独处理<ul><li>有k个，逆转</li><li>不够k个，全逆转！！！仔细读题目谢谢！</li></ul></li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    string reverseStr(string s, int k) &#123;        int len = s.size();        if(len &lt; k)&#123;            reverse(s,0,len-1);//对于结束的点要注意            return s;        &#125;        //这种情况很容易忽略,都是不看题目的锅        if(len &lt; 2*k)&#123;            reverse(s,0,k-1);        &#125;                    //len至少是大于2k的        int cnt = len/(2*k);                int start = 0;        for(int i = 0; i &lt; cnt; i++)&#123;            start = 2*i*k;            reverse(s,start,start+k-1);        &#125;        start += 2*k;        if(len - start &gt;= k)            reverse(s,start,start+k-1);        if(len - start &lt; k)            reverse(s,start,len -1);                return s;    &#125;        void reverse(string&amp; s, int start, int en)&#123;        for(int i = start, j = en; i &lt; j; i++,j--)&#123;            s[i] ^= s[j];            s[j] ^= s[i];            s[i] ^= s[j];        &#125;    &#125;&#125;;</code></pre><h4 id="solution2-1"><a href="#solution2-1" class="headerlink" title="solution2"></a>solution2</h4><pre><code class="C++">class Solution &#123;public:    string reverseStr(string s, int k) &#123;        int start = 0;        int len = s.size();        while(start &lt; len)&#123;            if(start + k &lt; len)                reverse(s.begin()+start, s.begin()+start+k );            else                reverse(s.begin()+start,s.end());            start += k + k;         &#125;        return s;    &#125;&#125;;</code></pre><h3 id="345-Reverse-Vowels-of-a-String"><a href="#345-Reverse-Vowels-of-a-String" class="headerlink" title="345. Reverse Vowels of a String"></a>345. Reverse Vowels of a String</h3><p><strong>Example 1:</strong></p><pre><code>Input: &quot;hello&quot;Output: &quot;holle&quot;</code></pre><h4 id="solution-双指针"><a href="#solution-双指针" class="headerlink" title="solution- 双指针"></a>solution- 双指针</h4><ul><li>分别向前，向后扫描，交换元音字母</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    bool isVowel(char c)&#123;        if(c == &#39;a&#39; || c == &#39;A&#39;|| c == &#39;e&#39;|| c == &#39;E&#39;|| c == &#39;i&#39;|| c == &#39;I&#39;|| c == &#39;o&#39;|| c == &#39;O&#39; || c == &#39;u&#39; || c == &#39;U&#39;)            return true;        else            return false;    &#125;    string reverseVowels(string s) &#123;                int len = s.size();        int i = 0, j = len-1;        while(i &lt; j)&#123;            while(i &lt; j &amp;&amp; !isVowel(s[i]))&#123;                    i++;            &#125;             while(i &lt; j &amp;&amp; !isVowel(s[j]))&#123;                                  j--;            &#125;            if(i &lt; j)&#123;                cout&lt;&lt;s[i]&lt;&lt;&quot;:&quot;&lt;&lt;s[j]&lt;&lt;endl;                char tmp = s[i];                s[i] = s[j];                s[j] = tmp;                            &#125;            i++;            j--;                &#125;        return s;    &#125;  &#125;;</code></pre><h3 id="551-Student-Attendance-Record-I"><a href="#551-Student-Attendance-Record-I" class="headerlink" title="551. Student Attendance Record I"></a>551. Student Attendance Record I</h3><p><strong>题目描述</strong></p><p>You are given a string representing an attendance record for a student. The record only contains the following three characters:  </p><ol><li><strong>‘A’</strong> : Absent. </li><li><strong>‘L’</strong> : Late.</li><li> <strong>‘P’</strong> : Present. </li></ol><p> A student could be rewarded if his attendance record doesn’t contain <strong>more than one ‘A’ (absent)</strong> or <strong>more than two continuous ‘L’ (late)</strong>.    </p><h4 id="solution-统计"><a href="#solution-统计" class="headerlink" title="solution-统计"></a>solution-统计</h4><ul><li> 时间：O(n)，空间：O(1)</li><li>题目得仔细看，一不小心就写错了</li></ul><pre><code class="C++">class Solution &#123;public:    bool checkRecord(string s) &#123;        int len = s.size();        int cntA = 0;        for(int i = 0; i &lt; len; i++)&#123;            if(s[i] == &#39;A&#39;)                cntA++;        &#125;        if(cntA &gt; 1 || s.find(&quot;LLL&quot;) != string::npos)            return false;        else            return true;        &#125;&#125;;</code></pre><h4 id="solution2-if-else"><a href="#solution2-if-else" class="headerlink" title="solution2-if-else"></a>solution2-if-else</h4><ul><li>别人写的，还没有理解其妙处</li></ul><pre><code class="C++">class Solution &#123;public:    bool checkRecord(string s) &#123;        int l = 0, a = 0;        for(char c:s)&#123;            if(c == &#39;A&#39;)                a++;                        if(c == &#39;L&#39;)//为啥这里不可以用if else？c不是只能等于一个数？我知道了，对于连续的L，会一直计数，然后下面的if会判断是否已经到了不合格的时候，一旦不连续，则直接被置0，从头开始                l++;            else                l = 0;            if(a &gt; 1 || l &gt; 2)                return false;        &#125;        return true;    &#125;&#125;;</code></pre><h3 id="415-Add-Strings"><a href="#415-Add-Strings" class="headerlink" title="415. Add Strings"></a>415. Add Strings</h3><p><strong>题目描述</strong></p><p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as string, return the sum of <code>num1</code> and <code>num2</code></p><h4 id="solution-6"><a href="#solution-6" class="headerlink" title="solution"></a>solution</h4><ul><li>就是小学生加法，一步步加，比如 A+B，需要考虑A长度，B长度，以及进位</li><li>这么简单的题，也能耗个几天才做完，自己写的代码里有一半都有点冗余，所以直接放参考别人写的了</li><li>每次只需要考虑当前位的A[i],B[j],carry</li><li>时间：O(n)，空间：O(n)，n表示相加的数最长长度</li></ul><pre><code class="C++">class Solution &#123;public:    string addStrings(string num1, string num2) &#123;        string res = &quot;&quot;;            int sum = 0;        int i = num1.size()-1, j = num2.size()-1,carry = 0;        while(i &gt;= 0 || j &gt;= 0 || carry == 1)&#123;            int x = i&lt;0?0:num1[i]-&#39;0&#39;;            int y = j&lt;0?0:num2[j]-&#39;0&#39;;            sum = x+y+carry;            carry = sum/10;            res+=to_string(sum%10);            i--;            j--;        &#125;        reverse(res.begin(),res.end());        return res;    &#125;&#125;;</code></pre><h3 id="67-Add-Binary"><a href="#67-Add-Binary" class="headerlink" title="67. Add Binary"></a>67. Add Binary</h3><p><strong>题目描述</strong></p><p>Given two binary strings, return their sum (also a binary string).</p><p><strong>Example 2:</strong></p><pre><code>Input: a = &quot;1010&quot;, b = &quot;1011&quot;Output: &quot;10101&quot;</code></pre><h4 id="solution-类似string的加法"><a href="#solution-类似string的加法" class="headerlink" title="solution-类似string的加法"></a>solution-类似string的加法</h4><ul><li>需要考虑的就是a[i]，b[j]，carry</li></ul><pre><code class="C++">class Solution &#123;public:    string addBinary(string a, string b) &#123;        int i = a.size()-1,j = b.size()-1;        int carry = 0;        string res = &quot;&quot;;        while(i &gt;= 0 || j &gt;= 0 || carry == 1 )&#123;            int sum = carry;            if(i &gt;= 0)&#123;                sum += a[i]-&#39;0&#39;;                i--;            &#125;            if(j &gt;=0 )&#123;                sum += b[j]-&#39;0&#39;;                j--;            &#125;            res += to_string(sum%2);            carry = sum/2;         &#125;        reverse(res.begin(),res.end());        return res;           &#125;&#125;;</code></pre><h3 id="925-Long-Pressed-Name"><a href="#925-Long-Pressed-Name" class="headerlink" title="925. Long Pressed Name"></a>925. Long Pressed Name</h3><p><strong>题目描述</strong></p><p>name是真名字，typed是不小心有多打的，typed是不是真的多打的</p><h4 id="solution-7"><a href="#solution-7" class="headerlink" title="solution"></a>solution</h4><ul><li>因为typed中有长重复输入，那么如果它是name的长输入，长度一定是大于等于name的，如果两者是相等的，直接返回成功。</li><li>遍历typed，将typed中的连续相同字符用cnt表示为一个group</li><li>遍历name，依次探测typed中 group 的元素个数以及元素本身是否匹配</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    bool isLongPressedName(string name, string typed) &#123;        if(name == typed)            return true;                int len1= name.size(),len2 = typed.size();        if(len1 &gt; len2)            return false;                int i = 0, j = 0;        while(i &lt; len1 &amp;&amp; j &lt; len2)&#123;            if(name[i] != typed[j])                return false;            i++;            j++;            int cnt = 0;            int typeTmp = typed[j-1],nameTmp = name[i-1];            while((typed[j] == typeTmp ) &amp;&amp; (j &lt; len2))&#123;                cnt++;                j++;            &#125;            while((name[i] == nameTmp) &amp;&amp; (i &lt; len1))&#123;                if(cnt &gt; 0)&#123;                    cnt--;                    i++;                &#125;else                    return false;            &#125;        &#125;        return i == len1 &amp;&amp; j == len2;    &#125;&#125;;</code></pre><h3 id="819-Most-Common-Word"><a href="#819-Most-Common-Word" class="headerlink" title="819. Most Common Word"></a>819. Most Common Word</h3><p><strong>题目描述</strong></p><p>Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. </p><p>Words in the list of banned words are given in lowercase, and free of  punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.</p><p><strong>Example:</strong></p><pre><code>Input: paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;banned = [&quot;hit&quot;]Output: &quot;ball&quot;</code></pre><h4 id="solution-8"><a href="#solution-8" class="headerlink" title="solution"></a>solution</h4><ul><li>做题之前先想清楚再做，每次都是，要不做一半，发现理解错题意了，要不就是做到最后，越做越乱</li><li>新语法：sstringstream，map的make_pair</li><li>思路就是：<ul><li>首先把paragraph做处理，把其他punctuation都变为“ ”，在这个过程中，把大写都转换为小写。因为在banned中的单词都是小写。这里要注意的是，把逗号之类的转换为空格，加上本来就存在的空格，会出现两个空格的清空，用string的find空格，会出错！！！</li><li>遍历段落中的单词，记录出现次数最多并且不再banned中的<ul><li>这里的一个技巧点，并不是总需要一步一步向下走，像这种一边查看是否在banned中，一边就可以去比较出现次数，出现次数一旦是最多的，就可以记录，而不是先将所有的单词出现次数记录一遍，然后再去遍历这个次数，找出最多</li></ul></li></ul></li><li>因为用到了在banned中find的操作，因此将vector转换为set了</li><li>要返回的是string，这个string的次数还要出现最多，因此选用map作为存储中间结果的数据结构</li><li>时间：O(n+m),空间：O(n+m)，n和m分别为para和banned的大小</li></ul><pre><code class="C++">class Solution &#123;public:    string mostCommonWord(string para, vector&lt;string&gt;&amp; banned) &#123;        unordered_set&lt;string&gt;s(banned.begin(),banned.end());        unordered_map&lt;string,int&gt;mymap;        int len = para.size();        for(char &amp;c : para)            c = isalpha(c)?tolower(c):&#39; &#39;;               pair&lt;string,int&gt; res(&quot;&quot;,0);        istringstream iss(para);        string word;       while(iss &gt;&gt; word)&#123;            if((s.find(word) == s.end()) &amp;&amp; (++mymap[word] &gt; res.second))                res = make_pair(word,mymap[word]);        &#125;               return res.first;    &#125;&#125;;</code></pre><h3 id="443-String-Compression"><a href="#443-String-Compression" class="headerlink" title="443. String Compression"></a>443. String Compression</h3><p><strong>Example 1:</strong></p><pre><code>Input:[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]Output:Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]Explanation:&quot;aa&quot; is replaced by &quot;a2&quot;. &quot;bb&quot; is replaced by &quot;b2&quot;. &quot;ccc&quot; is replaced by &quot;c3&quot;.</code></pre><h4 id="solution-9"><a href="#solution-9" class="headerlink" title="solution"></a>solution</h4><ul><li>思路比较简单，但是有点难写</li><li>考虑两种情况<ul><li>连续出现的字符，首先定位一个字符，接着一直向后扫描</li><li>相邻两个字符不一致（这里比较时用的是：当前字符和下一个字符）/已经到了字符末尾<ul><li>记录当前字符，记录当前字符出现的次数</li></ul></li></ul></li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    int compress(vector&lt;char&gt;&amp; chars) &#123;        int len = chars.size();                int cur = 0, newIndex = 0;//cur：当前比较的字符，newIndex：是新记录的vector，因为新的结果大小 &lt;= 原vector，因此可以一边遍历重复使用，最后返回index        for(int i = 0; i&lt; len; i++)&#123;            if(i+1 == len || chars[i] != chars[i+1])&#123;                chars[newIndex++] = chars[i];                                 //记录当前重复字符出现的次数，对于只出现一次的，则没有这步                if(cur &lt; i)&#123;                    string cnt = to_string(i-cur+1);                    for(char c: cnt)                        chars[newIndex++] = c;                &#125;                              cur = i+1;            &#125;        &#125;        return newIndex;         &#125;&#125;;</code></pre><h3 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h3><p><strong>题目描述</strong></p><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><h4 id="solution2-辅助栈"><a href="#solution2-辅助栈" class="headerlink" title="solution2-辅助栈"></a>solution2-辅助栈</h4><ul><li>如果是左括号，进栈，如果是右括号，匹配栈顶是否为对应的左括号</li><li>时间：O(n)，空间：O(n)-辅助栈</li></ul><pre><code class="C++">class Solution &#123;public:    bool isValid(string s) &#123;        stack&lt;char&gt;ch;        for(int i = 0; i &lt; s.size(); i++)&#123;            if(s[i] == &#39;(&#39; || s[i] == &#39;&#123;&#39; || s[i] == &#39;[&#39;)                ch.push(s[i]);            else&#123;                if(ch.empty()) return false;//这个很重要，要弹出，首先就要判断栈是否为空                if(s[i] == &#39;)&#39; &amp;&amp; ch.top() != &#39;(&#39;)                    return false;                if(s[i] == &#39;&#125;&#39; &amp;&amp; ch.top() != &#39;&#123;&#39;)                    return false;                if(s[i] == &#39;]&#39; &amp;&amp; ch.top() != &#39;[&#39;)                    return false;                                ch.pop();            &#125;               &#125;        return ch.empty();             &#125;&#125;;</code></pre><h3 id="434-Number-of-Segments-in-a-String"><a href="#434-Number-of-Segments-in-a-String" class="headerlink" title="434. Number of Segments in a String"></a>434. Number of Segments in a String</h3><p><strong>题目描述</strong></p><p>Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.</p><p><strong>Example:</strong></p><pre><code>Input: &quot;Hello, my name is John&quot;Output: 5</code></pre><h4 id="solution-查找空格-错误"><a href="#solution-查找空格-错误" class="headerlink" title="solution-查找空格-错误"></a>solution-查找空格-错误</h4><ul><li>这道题就是在考察各种特殊情况<ul><li>结尾有没有空格</li><li>字符串为空</li><li>只有一个字符串</li></ul></li><li>事实证明我写的这个不行，突然想到了前几天用到的istringstream</li></ul><pre><code class="C++">class Solution &#123;public:    int countSegments(string s) &#123;        if(s.empty())            return 0;        int cnt = 0;        istringstream ss(s);        string w;        while(ss&gt;&gt;w)&#123;            cnt++;        &#125;        return cnt;      &#125;&#125;;</code></pre><h3 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125. Valid Palindrome"></a>125. Valid Palindrome</h3><p><strong>题目描述</strong></p><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;A man, a plan, a canal: Panama&quot;Output: true</code></pre><h4 id="solution1"><a href="#solution1" class="headerlink" title="solution1"></a>solution1</h4><ul><li>对原字符串进行处理，注意题目的意思包括字符和数字</li><li>判断是否为回文</li><li>时间：O(n),空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    bool isPalindrome(string s) &#123;        if(s.empty())            return true;                int len = s.size();        for(int i = 0; i &lt; len; i++)&#123;            char c = s[i];            //s[i] = isalpha(c)?tolower(s[i]):&#39;&#39;;//&#39; &#39;不知道为啥不能在这里放                        if(isalpha(c))                s[i] = tolower(c);            else if(isdigit(c))&#123;                continue;            &#125;            else                s[i] = &#39; &#39;;                          &#125;                 int k = 0, j = len-1;                 while(k &lt; j)&#123;            while(s[k] == &#39; &#39; &amp;&amp; k &lt; j)  k++;                          while(s[j] == &#39; &#39; &amp;&amp; k &lt; j)  j--;                            if(s[k] != s[j])                return false;            k++;            j--;//一定要记得在这里更新循环值        &#125;       return true;            &#125;&#125;;</code></pre><h4 id="solution2-2"><a href="#solution2-2" class="headerlink" title="solution2"></a>solution2</h4><ul><li>isnumalp()：既可以判断是否为数字，又可以判断是否为字母</li><li>transform()：对大小写的转换</li></ul><pre><code class="C++">class Solution &#123;public:    bool isPalindrome(string s) &#123;        if(s.empty())            return true;        transform(s.begin(),s.end(),s.begin(),::tolower);                int i = 0, j = s.size()-1;        while(i &lt; j)&#123;            bool flag1 = isAlphaNumeric(s[i]), flag2 = isAlphaNumeric(s[j]);                        if(flag1 &amp;&amp; flag2)&#123;                if(s[i] == s[j])&#123;                    i++;                    j--;                &#125;else                    return false;                                &#125;else if(flag1)&#123;                j--;            &#125;else if(flag2)&#123;                i++;            &#125;else&#123;                i++;                j--;            &#125;        &#125;        return true;           &#125;    bool isAlphaNumeric(char c)&#123;        if((c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) ||(c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;))            return true;        else            return false;    &#125;&#125;;</code></pre><h3 id="680-Valid-Palindrome-II"><a href="#680-Valid-Palindrome-II" class="headerlink" title="680. Valid Palindrome II"></a>680. Valid Palindrome II</h3><p> <strong>题目描述</strong></p><p>Given a non-empty string <code>s</code>, you may delete <strong>at most</strong> one character.  Judge whether you can make it a palindrome. </p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;abca&quot;Output: True</code></pre><h4 id="solution-10"><a href="#solution-10" class="headerlink" title="solution"></a>solution</h4><ul><li><p>回文就是正着反着读出来都一样</p></li><li><p>出栈读取和原字符串一样，这里的区别是，可以有一次机会，某个字符可以不是回文</p></li><li><p>这里有个问题就是，在遍历过程中，当两个字符不一致的时候，到达是哪一个字符向前走一个，因此，想到了递归</p></li><li><p>不断地缩小问题，双指针，一个从前往后，一个从后往前，每次比较两个字符   - 如果相等，则缩小范围</p><ul><li>如果不相等，则向左或者向右缩小范围 </li></ul></li><li><p>时间：O(n)，空间：O(n)</p></li></ul><pre><code class="C++">class Solution &#123;public:    bool isEqual(string s, int beg, int en)&#123;         //cout&lt;&lt;s.substr(beg,en-beg+1)&lt;&lt;endl;        /* // 内存超了        if(beg &gt; en)            return true;        if(s[beg] == s[en])            return isEqual(s, beg+1, en-1);        else            return false;                      */         for(int i = beg, j = en; i &lt; j ; i++, j--)&#123;            if(s[i] != s[j])                return false;        &#125;        return true;                     &#125;        bool validPalindrome(string s) &#123;        int len = s.size();        int beg = 0, en = len-1;                while(beg &lt;= en)&#123;            if(s[beg] != s[en])&#123;                return (isEqual(s,beg+1,en)) || (isEqual(s,beg,en-1));            &#125;                beg++;            en--;        &#125;                return true;           &#125;&#125;;</code></pre><h3 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28. Implement strStr()"></a>28. Implement strStr()</h3><p><strong>题目描述</strong></p><p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p><p><strong>Example 1:</strong></p><pre><code>Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2</code></pre><p><strong>solution</strong></p><pre><code class="C++">class Solution &#123;public:    int strStr(string haystack, string needle) &#123;        if(needle.empty() || haystack == needle)            return 0;        int len1 = haystack.size(),len2= needle.size();        if( len1 &lt; len2 )            return -1;        int pos = haystack.find(needle,0);        if(pos != string::npos)            return pos;        else            return -1;        &#125;&#125;;</code></pre><h3 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h3><p><strong>题目描述</strong></p><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p><p><strong>Example 1:</strong></p><pre><code>Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;</code></pre><h4 id="solution-11"><a href="#solution-11" class="headerlink" title="solution"></a>solution</h4><ul><li>依次遍历vector，依次比较每个单词对应的元素,用set中元素是unique的特性来存储相同元素</li><li>时间：有一个排序的过程，O(Nlog(N))?，双层循环：O(n*N)，n是最短字符串的长度，N是vector的大小</li><li>空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    static bool cmp(const string&amp; s1, const string&amp; s2)&#123;        return s1.size() &lt; s2.size();    &#125;    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;        int vLen = strs.size();        if(strs.empty())            return &quot;&quot;;                if( vLen == 1)            return strs[0];                sort(strs.begin(),strs.end(),cmp);//表示最长公共前缀是最短的那个字符串,直接用sort是对字符本身的排序，而这里需要的是对字符串的长度进行排序        int sLen = strs[0].size();        //cout&lt;&lt;sLen&lt;&lt;endl;                        for(int i = 0; i&lt; sLen; i++)&#123;            char tmp = strs[0][i];            for(int j = 1; j &lt; vLen; j++)&#123;                if(strs[j][i] != tmp)                    return strs[0].substr(0,i);;            &#125;         &#125;                return strs[0];            &#125;&#125;;</code></pre><h3 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a>58. Length of Last Word</h3><p><strong>题目描述</strong></p><p>Given a string <em>s</em> consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word in the string.</p><h4 id="solution-12"><a href="#solution-12" class="headerlink" title="solution"></a>solution</h4><ul><li>看别人的代码，总有一种胜读十年书的感觉</li><li>时间：O(n)，空间：O(1)</li><li>note:isblank()</li><li>让别人的智慧来熏陶一下自己，自己的代码就放在后面来激励一下自己吧</li></ul><pre><code class="C++">class Solution &#123;public:    int lengthOfLastWord(string s) &#123;        if(s.empty())            return 0;        int i = s.size()-1;        while(i &gt;= 0 &amp;&amp; isblank(s[i]))            i--;        int len = 0;        while(i &gt;= 0 &amp;&amp; !isblank(s[i]))&#123;            len++;            i--;        &#125;        return len;    &#125;&#125;;</code></pre><pre><code class="c++">class Solution &#123;public:    int lengthOfLastWord(string s) &#123;        if(s.empty())            return 0;        int len = s.size();        int i = len-1;        while(i &gt;= 0 &amp;&amp; s[i] == &#39; &#39;) i--;        if(i &lt; 0)            return 0;                int start = i;        while(i &gt;= 0)&#123;            if(s[i] == &#39; &#39;)//这里是统计最后一个单词的停止地方                return start - i;        &#125;            i--;        return start - i;    &#125;&#125;;</code></pre><h3 id="686-Repeated-String-Match"><a href="#686-Repeated-String-Match" class="headerlink" title="686. Repeated String Match"></a>686. Repeated String Match</h3><p><strong>题目描述</strong></p><p>Given two strings A and B, find the minimum number of times A has to  be repeated such that B is a substring of it. If no such solution,  return -1.</p><p>For example, with A = “abcd” and B = “cdabcdab”.</p><p>Return 3, because by repeating A three times (“abcdabcdabcd”), B is a  substring of it; and B is not a substring of A repeated two times  (“abcdabcd”).</p><h4 id="solution-13"><a href="#solution-13" class="headerlink" title="solution"></a>solution</h4><ul><li>B是A*k的子串，求最小的k</li><li>首先肯定需要A的长度大于等于B，之后比较B是否包含在A内</li><li>当长度是k时不包含，则再加一个A如果还不包含，那指定不包含了</li><li>时间：O(n)，空间：O(n)：n是字符的个数</li></ul><pre><code class="c++">class Solution &#123;public:    int repeatedStringMatch(string A, string B) &#123;        if(A.find(B) != string::npos)            return 1;                int time = 1;        string resA = A;        while(resA.size() &lt; B.size())&#123;            resA += A;//这里不能是A的自加，因为A变化后，下次加的是其新值            time++;        &#125;        int pos1 = resA.find(B);        if(pos1 != string::npos)            return time;                resA += A;        int pos2 = resA.find(B);        if(pos2 != string::npos)            return time+1;                return -1;    &#125;&#125;;</code></pre><h3 id="859-Buddy-Strings"><a href="#859-Buddy-Strings" class="headerlink" title="859. Buddy Strings"></a>859. Buddy Strings</h3><p><strong>题目描述</strong></p><p>Given two strings <code>A</code> and <code>B</code> of lowercase letters, return <code>true</code> if and only if we can swap two letters in <code>A</code> so that the result equals <code>B</code>.</p><p><strong>Example 1:</strong></p><pre><code>Input: A = &quot;ab&quot;, B = &quot;ba&quot;Output: trueInput: A = &quot;aa&quot;, B = &quot;aa&quot;Output: true</code></pre><h4 id="solution1-遍历-1"><a href="#solution1-遍历-1" class="headerlink" title="solution1-遍历"></a>solution1-遍历</h4><ul><li>A、B的长度不等，那么一定不可能相等</li><li>A、B长度为2，A[1] == B[0] &amp;&amp; A[0] == B[1]</li><li>如果两者都相等，除非有个元素是重复出现过，否则也不可以。</li><li>主要思路是：依次比较A和B的每个元素，如果第一次不相等，则记录位置，等到第二次不相等的时候，看A，B不相等的元素是否和第一次不相等位置的元素正好匹配</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    bool buddyStrings(string A, string B) &#123;        int lenA = A.size(), lenB = B.size();        if(lenA != lenB)            return false;        if(lenA == 2)            return (A[1] == B[0]) &amp;&amp; (A[0] == B[1]);        if(A == B)            return hasDup(A);//对于相等的A和B，当且仅当A有重复元素时，可以交换相同元素，否则，不可以                    int i = 0,first = 0;//first记录第一次不一致的位置        bool flag = false,flag1 = false;//flag为true时表示已经有过不一致,flag1为true表示有过第二次不一致，而且已经有过一次交换的机会了，不能再有不一致了        while(i &lt; lenA)&#123;            if(A[i] == B[i])&#123;                i++;            &#125;else if(flag)&#123;                if(!flag1  &amp;&amp; A[first] == B[i] &amp;&amp; B[first] == A[i])&#123;                     i++;                     flag1 = true;                &#125;else                    return false;            &#125;else&#123;                flag = true;                first = i;                i++;            &#125;        &#125;        return true;;       &#125;        bool hasDup(string s)&#123;        int len = s.size();        for(int i = 0; i &lt; len-1; i++)&#123;            if(s.find(s[i],i+1) != string::npos)                return true;        &#125;        return false;    &#125;   &#125;;</code></pre><h4 id="solution2-利用额外空间"><a href="#solution2-利用额外空间" class="headerlink" title="solution2-利用额外空间"></a>solution2-利用额外空间</h4><ul><li>主要的不同就是<ul><li>对于相同的两个字符串，判断是否有重复元素，用了set</li><li>对于不同的元素位置的记录，使用了vector</li></ul></li><li>时间：O(n)，都是一遍扫描，空间：O(n)：用到了set，vector</li></ul><pre><code class="C++">class Solution &#123;public:    bool buddyStrings(string A, string B) &#123;        int lenA = A.size(), lenB = B.size();        if(lenA != lenB)            return false;        //这里我第一个想到的就是set，但是不知道怎么用，看了别人写的，简直太机智了        if(A == B)&#123;            if(set&lt;char&gt;(A.begin(), A.end()).size() &lt; A.size())                 return true;//这里只判断了有重复元素的情况        &#125;        vector&lt;int&gt; index;        int i = 0;         while(i &lt; lenA)&#123;            if(A[i] != B[i])                index.push_back(i);            i++;        &#125;        //size == 2这点是判断没有重复元素的情况        return (index.size()==2) &amp;&amp; (A[index[0]] == B[index[1]]) &amp;&amp; (A[index[1]] == B[index[0]]);    &#125;&#125;; </code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my first article</title>
      <link href="/2019/10/03/my-first-article/"/>
      <url>/2019/10/03/my-first-article/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么使用-hexo-框架搭建个人博客？"><a href="#为什么使用-hexo-框架搭建个人博客？" class="headerlink" title="为什么使用 hexo 框架搭建个人博客？"></a>为什么使用 hexo 框架搭建个人博客？</h3><p>&emsp; 正如“点击头像”后的 Why Blog 中所说，想拥有一个可以做个人学习成长记录的博客网站。</p><p>&emsp; 跟着网上的教程，用 jeklly 搭建博客时，是直接在 github 上操作，fork 了别人的模板，因为懂的太少，发现别人的 demo 总是修改不干净，也不知道别人做了一些什么样的人性化设置，就很难受。放弃了…看到了hexo搭建教程，十一国庆节放假用了一天试了一下，成功！<br>ps：还是要找靠谱的博客，非常感谢开源和分享知识的大家！</p><h3 id="当前效果是如何展示的？"><a href="#当前效果是如何展示的？" class="headerlink" title="当前效果是如何展示的？"></a>当前效果是如何展示的？</h3><ul><li><p>本博客使用了 Hexo，它是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></li><li><p>本博客使用了<a href="https://github.com/yelog/hexo-theme-3-hexo">叶落阔提供的 hexo theme</a>（即 3-hexo），来渲染网页内容。themes 相当于整个框架中可插拔的配置。</p></li><li><p>配置都写在 _config.yml 中。hexo init 后的文件夹称作 hexo 项目的根目录；各个 theme 目录下也有一个当前主题的 _config.yml。</p></li><li><p>参考 <a href="https://www.cnblogs.com/shwee/p/11421156.html">洪卫的博客</a>： 1. 安装必要的软件，如 git, npm, nodejs, hexo 等；2. 生成 hexo 框架的必要代码；3. 启动本地服务器查看效果。此时的效果是 themes 文件夹下默认的 landscape 展示。</p></li><li><p>参考<a href="https://github.com/yelog/hexo-theme-3-hexo">开源的 3-hexo</a>，将 3-hexo clone 到 themes 文件夹下，再次启动本地服务器查看效果。此时的效果都是demo，里面涉及了很多原作者的个人配置，如用户名等。</p></li><li><p>参考<a href="http://yelog.org/2017/03/23/3-hexo-instruction/">3-hexo 的使用说明</a> 配置 hexo 根目录&amp; theme 下的 _config.yml。可以写简单的demo.md 去看看各种配置的效果。</p></li><li><p>参考<a href="https://www.cnblogs.com/shwee/p/11421156.html">洪卫的博客</a>，将 hexo 部署到GitHub。就可以在xx.github.io 上看到了 用github pages 托管的网页。</p></li><li><p>使用 hexo d 上传部署到 github 的其实是 hexo 编译后的文件，是用来生成网页的，不包含源文件。也就是上传的是在本地目录里自动生成的.deploy_git里面。但是为了备份源文件（即各种.md文档）以及多终端协同使用笔记，参考<a href="https://www.zhihu.com/question/21193762/answer/489124966">直上云霄的回答</a>，用一个新的分支管理源文件，做备份。而 hexo 项目的根目录下的 _config.yml 中 deploy 配置的分支是master。因此 hexo d 时 master 分支会自动变。要同步源文件分支需要手动git<br>add 等进行管理。</p></li></ul><h3 id="博客生成与部署"><a href="#博客生成与部署" class="headerlink" title="博客生成与部署"></a>博客生成与部署</h3><ul><li>首先生成： <code>hexo g </code>，然后在本地预览 <code>hexo s</code>，最后部署在github上<code>hexo d</code></li><li>这是我的第一篇博客，为什么用 npm i hexo-deployer-git 不能生成一个放图片的文件夹呢？</li></ul><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><ul><li>对于一些配置，需要在最上面标识，包括 categories，tags等<ul><li>比如公式的使用，在每篇文档开头设置mathjax： $v_i$</li></ul></li></ul><pre><code class="C++">#include&lt;iostream&gt;using namespace std;int main()&#123;    return 0;&#125;</code></pre><blockquote><p>从小的 demo 开始，一步步累加。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> problem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList-problems-easy</title>
      <link href="/2019/08/28/LinkedList-problems-easy/"/>
      <url>/2019/08/28/LinkedList-problems-easy/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><pre><code class="c++">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */</code></pre><h3 id="876-Middle-of-the-Linked-List"><a href="#876-Middle-of-the-Linked-List" class="headerlink" title="876.Middle of the Linked List"></a>876.Middle of the Linked List</h3><p><strong>题目描述：</strong></p><p>Given a non-empty, singly linked list with head node head, return a middle node of linked list.<br>If there are two middle nodes, return the second middle node.</p><p><strong>Example</strong> :</p><pre><code>Input: [1,2,3,4,5,6]Output: Node 4 from this list (Serialization: [4,5,6])Since the list has two middle nodes with values 3 and 4, we return the second one.</code></pre><h4 id="Solution-1-遍历"><a href="#Solution-1-遍历" class="headerlink" title="Solution 1-遍历"></a>Solution 1-遍历</h4><ul><li>将链表遍历一遍，得到链表的长度，求出中间节点的位置，重新从头开始遍历，输出中间节点。</li></ul><p>时间：O(2n)，空间O(1)？</p><pre><code class="c++">class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        if(head == NULL)            return NULL;        ListNode* tmp = head;        int cnt = 0;        while(tmp != NULL)&#123;            cnt++;            tmp = tmp-&gt;next;        &#125;        int i = cnt/2;        tmp = head;        while(i != 0)&#123;            tmp = tmp-&gt;next;            i--;        &#125;        return tmp;    &#125;&#125;;</code></pre><h4 id="Solution-2-快慢指针"><a href="#Solution-2-快慢指针" class="headerlink" title="Solution 2-快慢指针"></a>Solution 2-快慢指针</h4><ul><li>这个本来是想到了，但是自己不知道为什么演算错了。。。要考虑奇偶个数的情况；</li></ul><p>时间：O(n/2)，空间O(1)-快慢指针</p><pre><code class="c++">class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        if(head == NULL)            return NULL;        ListNode* slow = head, *fast = head;                //快指针比慢指针快一倍的速度，不是两个。。。        while(slow-&gt;next != NULL &amp;&amp; fast-&gt;next != NULL)&#123;            //奇数个元素            if(fast-&gt;next-&gt;next != NULL)&#123;                fast = fast-&gt;next-&gt;next;                slow = slow-&gt;next;            &#125;else&#123;                //返回方法一                fast = fast-&gt;next;                slow = slow-&gt;next;                //return slow-&gt;next;  //返回方法二            &#125;        &#125;        return slow;    &#125;&#125;;</code></pre><h4 id="Solution-3-辅助数组"><a href="#Solution-3-辅助数组" class="headerlink" title="Solution 3-辅助数组"></a>Solution 3-辅助数组</h4><ul><li><p>使用数组把所有元素放进去，按照数组随机存取的特性，直接定位到元素，这样就不是原来链接起来的链表了,用空间换时间。</p></li><li><p>时间O(n)，空间O(n)-vec用的空间</p></li></ul><pre><code class="c++">class Solution &#123;public:    ListNode* middleNode(ListNode* head) &#123;        if(head == NULL)            return NULL;        vector&lt;ListNode*&gt;vec&#123;head&#125;;//注意初始化是&#123;&#125;，不是[]                ListNode* cur = vec.back();        while(cur-&gt;next != NULL)&#123;            vec.push_back(cur-&gt;next);            cur = cur-&gt;next;                    &#125;        return vec[vec.size()/2];//相对于第一种的优点就是考虑到了数组的随机访问快    &#125;&#125;;</code></pre><h3 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h3><p><strong>题目描述：</strong></p><p>Reverse a singly linked list.</p><p><strong>Example:</strong></p><pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><h4 id="solution1-迭代"><a href="#solution1-迭代" class="headerlink" title="solution1-迭代"></a>solution1-迭代</h4><ul><li>主要目的是不要让链表断了，用三个指针分别表示当前节点，前一个，后一个.</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="c++">class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if(head == NULL)            return NULL;                ListNode *cur=NULL,*pre=NULL,*post=NULL;        cur=head;        while(cur!=NULL)   //要注意判断条件        &#123;            post=cur-&gt;next;            cur-&gt;next=pre;            pre=cur;            cur=post;        &#125;             return pre;            &#125;&#125;;//这个和上面的差不多，根本不是递归，就是迭代吧/*class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if(head == NULL)            return NULL;                ListNode *cur=NULL,*pre=NULL,*post=NULL;        cur=head;        return reverse(pre,cur,post);    &#125;    ListNode* reverse(ListNode* pre, ListNode* cur, ListNode* post)&#123;        if(cur == NULL)            return pre;        post = cur-&gt;next;        cur-&gt;next = pre;        pre  = cur;        return reverse(pre,post,post);    &#125;&#125;;*/</code></pre><h4 id="Solution2-递归"><a href="#Solution2-递归" class="headerlink" title="Solution2-递归"></a>Solution2-递归</h4><ul><li>主要是要理解递归。边界条件，cur == NULL则链表是空的，cur-&gt;next == NULL意味着链表已经到最后一个节点了，那么这个节点是新的head，开始返回。</li><li>递归时会为每个参数变量压栈，返回后就是当时的cur，那么cur的next是逆转的节点，这个节点的next就是cur。思路参考<a href="https://www.youtube.com/watch?v=MRe3UsRadKw">https://www.youtube.com/watch?v=MRe3UsRadKw</a></li><li>做的时候难点在于：指针的理解，<code>**</code>的理解及传参，以及如何改变head指针。</li><li>时间：O(n)，空间：O(n)-因为递归而使用的栈空间    </li></ul><pre><code class="c++">class Solution &#123;public:    ListNode* reverseList(ListNode* head) &#123;        if(head == NULL)            return NULL;                ListNode *cur = head;        reverse(cur,&amp;head);        return head;    &#125;     void reverse(ListNode* cur,ListNode** head)&#123;         if(cur-&gt;next == NULL)&#123;             *head = cur;             return ;         &#125;         reverse(cur-&gt;next,head);         cur-&gt;next-&gt;next = cur;         cur-&gt;next = NULL;     &#125;&#125;;</code></pre><h3 id="237-Delete-Node-in-a-Linked-List"><a href="#237-Delete-Node-in-a-Linked-List" class="headerlink" title="237.Delete Node in a Linked List"></a>237.Delete Node in a Linked List</h3><p><strong>题目描述：</strong></p><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p><p>Given linked list – head = [4,5,1,9], which looks like following:</p><p><img src="https://assets.leetcode.com/uploads/2018/12/28/237_example.png" alt="img"></p><p><strong>Example 1:</strong></p><pre><code>Input: head = [4,5,1,9], node = 5Output: [4,1,9]Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</code></pre><h4 id="solution-值替换"><a href="#solution-值替换" class="headerlink" title="solution-值替换"></a>solution-值替换</h4><ul><li>因为尾节点不为空：所以可以不删除当前节点，而是删除后一个节点。把给定当前节点，想要找到要删除节点的前一个节点，只能从头遍历;</li><li>将后一个节点的值赋值给当前节点，并让当前节点指向下下个节点，从而删除下个节点</li><li>如果要删除尾节点元素，那么就不能这样做，必须给head，从头向后遍历。</li></ul><pre><code class="c++">class Solution &#123;public:    void deleteNode(ListNode* node) &#123;        /*        node-&gt;val = node-&gt;next-&gt;val;        ListNode* tmp = node-&gt;next;        node-&gt;next =  node-&gt;next-&gt;next;        delete(tmp);   //还是应该把这个指针释放掉，不然会内存泄漏，但不这样写也能通过    */        auto next = node-&gt;next;//直接操作指针        *node = *next;        delete next;       &#125;&#125;;</code></pre><h3 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21.Merge Two Sorted Lists"></a>21.Merge Two Sorted Lists</h3><p><strong>题目描述：</strong></p><p>Merge two sorted linked lists and return it as a new list. The new  list should be made by splicing together the nodes of the first two  lists.</p><p><strong>Example:</strong> </p><pre><code>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><h4 id="solution1-迭代-1"><a href="#solution1-迭代-1" class="headerlink" title="solution1-迭代"></a>solution1-迭代</h4><ul><li>面对list的问题，可以尝试一个dummyHead，避免对特殊情况的处理</li></ul><pre><code class="c++">class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        ListNode *pNewHead = NULL; //合并后新的头结点        ListNode *pTail = NULL;      //不断连接新节点的尾节点                ListNode *pl1 = l1, *pl2 = l2;                if(l1 == NULL)   //对于特殊情况：两个链表为空做判断，都为空时这句话就可以捕获到            return l2;        else if(l2 == NULL)            return l1;        else&#123;            if((l1-&gt;val) &lt; (l2-&gt;val))&#123;                pNewHead = l1;                l1 = l1-&gt;next;            &#125;else&#123;                pNewHead = l2;                l2 = l2-&gt;next;            &#125;            &#125;                pTail = pNewHead;        while(l1 != NULL &amp;&amp; l2 !=NULL)&#123;            if((l1-&gt;val) &lt; (l2-&gt;val))&#123;                pTail-&gt;next = l1;                pTail = pTail-&gt;next;                l1 = l1-&gt;next;            &#125;else&#123;                pTail-&gt;next = l2;                pTail = pTail-&gt;next;                l2 = l2-&gt;next;            &#125;                 &#125;                //对于两个链表不一样长的情况做处理 ，因为是直接在链表本身上做连接，不是新创建一条链表，所以这里剩下的节点只需要一个指针指向即可，不需要遍历连接。        if(l1 != NULL)&#123;            pTail-&gt;next = l1;        &#125;        if(l2 != NULL)&#123;            pTail-&gt;next = l2;        &#125;                    return pNewHead;     &#125;    &#125;;</code></pre><h4 id="solution2-递归"><a href="#solution2-递归" class="headerlink" title="solution2-递归"></a>solution2-递归</h4><p>因为在递归调用的过程当中，系统为每一层的返回点、局部量等开辟了栈来存储，因此递归次数过多容易造成栈溢出。所以选择递归时要慎重。思路看代码吧~</p><pre><code class="c++">class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;        if(l1 == NULL)            return l2;        if(l2 == NULL)            return l1;                if((l1-&gt;val) &lt; (l2-&gt;val))&#123;            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);            return l1; //就是cur节点，一直指向当前链表的尾节点        &#125;else&#123;            l2-&gt;next = mergeTwoLists(l1,l2-&gt;next);            return l2;        &#125;                        &#125;&#125;;</code></pre><h3 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83.Remove Duplicates from Sorted List"></a>83.Remove Duplicates from Sorted List</h3><p><strong>题目描述：</strong></p><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p><p><strong>Example 1:</strong></p><pre><code>Input: 1-&gt;1-&gt;2Output: 1-&gt;2</code></pre><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><ul><li>看清楚题目，不要求把重复的所有元素都删除</li><li>cur表示当前节点，依次和下一个节点比较，如果值一样，则与下一个节点比较，并每次删除一个值一样的节点</li><li>时间：O(n)，必须从头遍历到尾，空间：O(1)</li></ul><pre><code class="c++">class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if(head == NULL)            return NULL;        ListNode* cur = head;       // ListNode* tmp = NULL;        while(cur)&#123;            while(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)&#123;               // tmp = cur-&gt;next;                cur-&gt;next = cur-&gt;next-&gt;next;                //delete(tmp);            &#125;            cur = cur-&gt;next;        &#125;        return head;    &#125;&#125;;</code></pre><h3 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141.Linked List Cycle"></a>141.Linked List Cycle</h3><p><strong>题目描述</strong></p><p>Given a linked list, determine if it has a cycle in it.</p><p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p><p><strong>Example 1:</strong></p><pre><code>Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where tail connects to the second node.</code></pre><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><h4 id="solution1—快慢指针"><a href="#solution1—快慢指针" class="headerlink" title="solution1—快慢指针"></a>solution1—快慢指针</h4><ul><li>第一种解法就是快慢指针，而且只需要O(1)空间，O(n)时间，但是奇怪的是，我因为指针指向原因，错了三次？</li></ul><pre><code class="c++">class Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        if(head == NULL || head-&gt;next == NULL)            return false;                ListNode* slow = head, *fast = head-&gt;next;        while(fast != slow)&#123;            if(fast == NULL || fast-&gt;next == NULL)&#123;                return false;            &#125;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;        &#125;        return true;    &#125;</code></pre><h4 id="solution2-辅助集合"><a href="#solution2-辅助集合" class="headerlink" title="solution2-辅助集合"></a>solution2-辅助集合</h4><ul><li>检查某个节点是否被第二次访问，使用hash表，查看当前元素在hash表中是否存在，则需要find函数(set)</li><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="c++">class Solution &#123;public:    bool hasCycle(ListNode *head) &#123;        if(head == NULL || head-&gt;next == NULL)            return false;                ListNode* tmp = head;        set&lt;ListNode*&gt;mySet;        mySet.insert(tmp);        tmp = tmp-&gt;next;                while(tmp != NULL)&#123;            if(mySet.find(tmp) == mySet.end())&#123;                mySet.insert(tmp);                tmp = tmp-&gt;next;            &#125;else                return true;        &#125;        return false;    &#125;&#125;;</code></pre><h3 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234.Palindrome Linked List"></a>234.Palindrome Linked List</h3><p><strong>题目描述</strong></p><p>Given a singly linked list, determine if it is a palindrome.</p><p>回文是指：正向和反向读取得到的是一样的</p><p><strong>Example 1:</strong></p><pre><code>Input: 1-&gt;2Output: false</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: 1-&gt;2-&gt;2-&gt;1Output: true</code></pre><h4 id="solution1-辅助栈"><a href="#solution1-辅助栈" class="headerlink" title="solution1-辅助栈"></a>solution1-辅助栈</h4><ul><li>遍历链表，使用栈存储，再次遍历链表，和出栈的元素比较</li><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="c++">class Solution &#123;public:    bool isPalindrome(ListNode* head) &#123;        if(head == NULL || head-&gt;next == NULL)            return true;                stack&lt;int&gt;node;        ListNode* tmp = head;        while(tmp != NULL)&#123;            node.push(tmp-&gt;val);            tmp = tmp-&gt;next;        &#125;        tmp = head;        while(tmp != NULL)&#123;            int v = node.top();            if(tmp-&gt;val != v)                return false;            node.pop();            tmp = tmp-&gt;next;        &#125;                    return true;    &#125;</code></pre><h4 id="solution2-递归-1"><a href="#solution2-递归-1" class="headerlink" title="solution2-递归"></a>solution2-递归</h4><ul><li>边界条件：cur == NULL，返回true</li><li>用一个指针指在链表头；递归不断执行，到了链表结尾，然后出栈，不断返回，表头指针不断往前走，也是一个后面和前面比较的过程。但是我在想，怎么能让它比较到中间的时候就停止呢？</li><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="c++">class Solution &#123;public:    ListNode* temp ;        bool isPalindrome(ListNode* head) &#123;        if(head == NULL || head-&gt;next == NULL)            return true;        temp = head;        return check(head);    &#125;    bool check(ListNode* p)&#123;        if(p == NULL)            return true;        bool isPal = check(p-&gt;next) &amp; (p-&gt;val == temp-&gt;val);        temp = temp-&gt;next;                return isPal;     &#125;&#125;;</code></pre><h3 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="203.Remove Linked List Elements"></a>203.Remove Linked List Elements</h3><p><strong>题目描述</strong></p><p>Remove all elements from a linked list of integers that have value <strong>val</strong>.</p><p><strong>Example:</strong></p><pre><code>Input:  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6Output: 1-&gt;2-&gt;3-&gt;4-&gt;5</code></pre><h4 id="solution-遍历"><a href="#solution-遍历" class="headerlink" title="solution-遍历"></a>solution-遍历</h4><ul><li>删除具有相同值的元素。因为要删除，所以需要记录当前元素的上一个，才能把指针连接到下一个<br>为了处理头结点，引入dummyHead。或者直接，用cur-&gt;next和值做比较</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    ListNode* removeElements(ListNode* head, int val) &#123;        if(head == NULL)            return NULL ;        ListNode* dummyHead = new ListNode(0);        dummyHead-&gt;next = head;        ListNode* pre = dummyHead, *cur = head;                while(cur != NULL)&#123;            if(cur-&gt;val == val)&#123;                pre-&gt;next = cur-&gt;next;                cur = pre-&gt;next;            &#125;else&#123;                pre = cur;                cur = cur-&gt;next;                            &#125;                 &#125;        return dummyHead-&gt;next;                    &#125;&#125;;</code></pre><h3 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160.Intersection of Two Linked Lists"></a>160.Intersection of Two Linked Lists</h3><p><strong>题目描述</strong></p><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" alt="img"></p><p>begin to intersect at node c1.</p><h4 id="solution1-求长度"><a href="#solution1-求长度" class="headerlink" title="solution1-求长度"></a>solution1-求长度</h4><ul><li>求出两个链表的长度，因为两个链表可能不一样长，则让长的那个先走几步，然后两个一起走，去比较是否有一致的节点</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="c++">class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        if(headA == NULL || headB == NULL)            return NULL;        //查询链表长度        ListNode* p1 = headA, *p2 = headB;        int lenA = 0, lenB = 0;        while(p1 != NULL)&#123;            lenA++;            p1 = p1-&gt;next;        &#125;        while(p2 != NULL)&#123;            lenB++;            p2 = p2-&gt;next;        &#125;        //将长的那个链表定位到与短链表一样长的地方        p1 = headA, p2 = headB;        int step = (lenA&gt;lenB)?(lenA-lenB):(lenB-lenA);        if(lenA &gt;= lenB)&#123;            while(step)&#123;                p1 = p1-&gt;next;                step--;            &#125;        &#125;else&#123;            while(step)&#123;                p2 = p2-&gt;next;                step--;            &#125;        &#125;        //开始同时遍历并比较两个链表的节点        while(p1 != NULL &amp;&amp; p2 != NULL)&#123;            if(p1 != p2)&#123;//判断的是节点是否相同，不是节点的值                p1 = p1-&gt;next;                p2 = p2-&gt;next;            &#125;            else                return p1;          &#125;        return NULL;            &#125;&#125;;</code></pre><h4 id="solution2—辅助栈"><a href="#solution2—辅助栈" class="headerlink" title="solution2—辅助栈"></a>solution2—辅助栈</h4><ul><li>如果有交集，那么倒着遍历时第一个不一样的节点就是分岔处。</li><li>顺序遍历，将元素分别存储在辅助的栈中。依次从栈中弹出元素比较</li><li>时间：O(n)，空间：O(n)</li><li>没写。。。</li></ul><h4 id="solution3-链表粘合"><a href="#solution3-链表粘合" class="headerlink" title="solution3-链表粘合"></a>solution3-链表粘合</h4><pre><code class="c++">class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        if(headA == NULL || headB == NULL)            return NULL;        ListNode *p1 = headA, *p2 = headB;        //只有拼接后的两条链都遍历完，才结束        while(p1 != NULL &amp;&amp; p2 != NULL &amp;&amp; p1 != p2)&#123;            p1 = p1-&gt;next;            p2 = p2-&gt;next;            if(p1 == p2)                return p1;            if(p1 == NULL)  p1 = headB;            if(p2 == NULL)  p2 = headA;        &#125;        return p1;//p1 == p2 的情况是两条链的公共节点是第一个的时候，不会执行while里面的语句，否则，在有前缀节点的情况下，一定是在循环内找到交点。如果没有交点，则p1是返回NULL    &#125;&#125;;</code></pre><h3 id="707-Design-Linked-List"><a href="#707-Design-Linked-List" class="headerlink" title="707. Design Linked List"></a>707. Design Linked List</h3><p><strong>题目描述：</strong></p><p>Design your implementation of the linked list. You can choose to use  the singly linked list or the doubly linked list. A node in a  singly linked list should have two attributes: <code>val</code> and <code>next</code>. <code>val</code> is the value of the current node, and <code>next</code> is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute <code>prev</code> to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p><p>Implement these functions in your linked list class:</p><ul><li>get(index) : Get the value of the <code>index</code>-th node in the linked list. If the index is invalid, return <code>-1</code>.</li><li>addAtHead(val) : Add a node of value <code>val</code> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li><li>addAtTail(val) : Append a node of value <code>val</code> to the last element of the linked list.</li><li>addAtIndex(index, val) : Add a node of value <code>val</code> before the <code>index</code>-th node in the linked list. If <code>index</code> equals to  the length of linked list, the node will be appended to the end of  linked list. If index is greater than the length, the node will not be  inserted. If index is negative, the node will be inserted at the head of  the list.</li><li>deleteAtIndex(index) : Delete the <code>index</code>-th node in the linked list, if the index is valid.</li></ul><p><strong>Example</strong>:</p><p><strong>Note:</strong></p><ul><li>All values will be in the range of <code>[1, 1000]</code>.</li><li>The number of operations will be in the range of <code>[1, 1000]</code>.</li><li>Please do not use the built-in LinkedList library.</li></ul><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>这道题对我来说最大的挑战不是思路，是C++语法的问题。<br>首先是不知道在类里面怎么去声明一个节点的类型，一个是不知道构造函数怎么用了，汗。。。<br>别人的思路的一个亮点：因为题目中要求了使用了头、尾，还有index的合法与不合法，所以设置三个全局变量head,tail,len, 在更新节点数量的时候要记着把len值做改变。</p><pre><code class="c++">class MyLinkedList &#123;private:    struct ListNode&#123;        int val;        ListNode* next;        ListNode(int v):val(v),next(NULL)&#123;&#125;    &#125;;    ListNode* head;    ListNode* tail;    int len ;    public:    /** Initialize your data structure here. */    MyLinkedList() &#123;        head = NULL;        tail = NULL;        len = 0;    &#125;        /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */    int get(int index) &#123;        if(index &gt;= len || index &lt; 0)            return -1;        ListNode* p  = head;            for(int i = 0;i &lt; index; i++)&#123;            p = p-&gt;next;        &#125;        return p-&gt;val;           &#125;    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */    void addAtHead(int val) &#123;        ListNode* newHead = new ListNode(val);        newHead-&gt;next = head;        head = newHead;        if(len == 0)            tail = newHead;        ++len;    &#125;        /** Append a node of value val to the last element of the linked list. */    void addAtTail(int val) &#123;        ListNode* newTail = new ListNode(val);        if(len == 0)&#123;            head = newTail;            tail = newTail;        &#125;                    tail-&gt;next = newTail;        tail = newTail;        newTail-&gt;next = NULL;        ++len;    &#125;        /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */    void addAtIndex(int index, int val) &#123;        if(index == len)            addAtTail(val);        else if(index &gt; len)            return ;        else if(index &lt;= 0)            addAtHead(val);        else&#123;            ListNode* p = head;            ListNode* newNode = new ListNode(val);            //找到要插入index的前一个节点，这样直接操作前一个节点的指向即可，所以是index-1，删除同理            for(int i = 0; i &lt; index-1;i++)&#123;                p = p-&gt;next;            &#125;            newNode-&gt;next = p-&gt;next;            p-&gt;next = newNode;            ++len;        &#125;                        &#125;        /** Delete the index-th node in the linked list, if the index is valid. */    void deleteAtIndex(int index) &#123;        if(index &lt; 0 || index &gt;= len)            return ;                ListNode* tmp = NULL;//用来做delete操作，在OJ中，我发现不用delete也可以，但是为了养成好习惯，建议始终把不要的节点delete掉，以免内存泄漏                //如果删除头节点,删除完就可以return了        if(index == 0)&#123;            tmp = head;            head = head-&gt;next;            delete tmp;            --len;            return;        &#125;        ListNode* p = head;        for(int i = 0; i &lt; index-1; i++)&#123;            p = p-&gt;next;        &#125;        //删除尾节点        if(index == len-1)            tail = p;                tmp = p-&gt;next;        p-&gt;next = p-&gt;next-&gt;next;        delete tmp;                --len;    &#125;&#125;;/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linkedList </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack-problems-easy</title>
      <link href="/2019/08/23/stack-problems-easy/"/>
      <url>/2019/08/23/stack-problems-easy/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h3 id="1021-Remove-Outermost-Parentheses"><a href="#1021-Remove-Outermost-Parentheses" class="headerlink" title="1021.Remove Outermost Parentheses"></a>1021.Remove Outermost Parentheses</h3><p>题目描述太复杂的情况下看看给的case就大概知道题意了</p><p><strong>Example 2:</strong></p><pre><code>Input: &quot;(()())(())(()(()))&quot;Output: &quot;()()()()(())&quot;Explanation: The input string is &quot;(()())(())(()(()))&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;.After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;.</code></pre><h4 id="solution1-记录左括号个数，分割primitive串"><a href="#solution1-记录左括号个数，分割primitive串" class="headerlink" title="solution1-记录左括号个数，分割primitive串"></a>solution1-记录左括号个数，分割primitive串</h4><ul><li>因为是一道和栈相关的题目，所以第一反应就是使用栈，比如”(()())(())”，设定一个全局遍历s0(“()”)；遇到”(“进栈，遇到”)”时，栈顶的匹配”(“出栈；如果此时栈为空，那么说明最后出栈的那对是外层括号，不计入最终的结果，直接开始遍历下一个元素。否则，res+=s0; 这种方法很闹心的一个地方是，对于”(()(()))”没法做。</li><li>另一种解法就是现在的解法，抛开stack，用string的知识来做。为的是找到最外层的括号，那么就从左向右遍历字符串，并用cnt记录当前左括号的个数，如果有匹配的右括号，则cnt–，有左括号时cnt++，当cnt==0时，即表示当前的右括号是外层括号，那么就把这个外层括号剥去，中间的加入res，那么此时有了待加入字符串的结束为止，还需要一个起始位置，则用start来表示，相当于字符串的截取。每次有了新的子串，start则初始化为新的起始位置。</li><li>时间O(n)，空间：O(n)——存储结果</li></ul><pre><code class="C++">class Solution &#123;public:    string removeOuterParentheses(string S) &#123;        int len = S.size();        string res = &quot;&quot;;             int cnt = 1;//记录左括号的个数，当有右括号与左括号匹配时，减一        int start = 0;//整个串被分为多个primative的串，记录每次新primative串的开始位置              for(int i = 1; i &lt; len;i++)&#123;            if(S[i] == &#39;(&#39;)&#123;                cnt++;            &#125;else&#123;                cnt--;            &#125;                         if(cnt == 0)&#123;                if(i - start &gt;1)&#123;                    string tmp(S.begin()+start+1,S.begin()+i);                    res += tmp;                &#125;                start = i+1;            &#125;        &#125;        return res;          &#125;&#125;;</code></pre><h4 id="solution2"><a href="#solution2" class="headerlink" title="solution2-"></a>solution2-</h4><ul><li>别人的解法，和上面的思路差不多，但是只用open去记录当前的字符是否是结果的一部分。<br>（我的比这个看起来复杂，主要是被题目给的example引导着做复杂了。即先找出整个大括号包含的字符串，再去除外面的那层，看这个解法，完全可以边走边判断）</li><li>open的数值意义：当前没有匹配的左括号的个数，左括号时加，右括号时减</li><li>如果open&gt;0 &amp;&amp; c == ‘(‘，那么加入res，open++</li><li>如果c == ‘)’ &amp;&amp; open &gt;1，那么加入res，open–；大于1的目的是把最外层的去掉</li><li>时间：O(n)，空间：O(n)——存储结果</li></ul><pre><code class="c++">class Solution &#123;public:    string removeOuterParentheses(string S) &#123;        int open = 0;        string res = &quot;&quot;;        for(char c:S)&#123;            if(c == &#39;(&#39; &amp;&amp; open++ &gt; 0) res += c; //最外面的左括号跳过            if(c == &#39;)&#39; &amp;&amp; open-- &gt; 1 ) res += c;                   &#125;        return res;    &#125;&#125;;</code></pre><h3 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047.Remove All Adjacent Duplicates In String"></a>1047.Remove All Adjacent Duplicates In String</h3><p><strong>题目描述</strong></p><p>Given a string <code>S</code> of lowercase letters, a <em>duplicate removal</em> consists of choosing two adjacent and equal letters, and removing them.</p><p>We repeatedly make duplicate removals on S until we no longer can.</p><p>Return the final string after all such duplicate removals have been made.  It is guaranteed the answer is unique.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;abbaca&quot;Output: &quot;ca&quot;Explanation: For example, in &quot;abbaca&quot; we could remove &quot;bb&quot; since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is &quot;aaca&quot;, of which only &quot;aa&quot; is possible, so the final string is &quot;ca&quot;.</code></pre><h4 id="solution1-反向遍历，栈"><a href="#solution1-反向遍历，栈" class="headerlink" title="solution1-反向遍历，栈"></a>solution1-反向遍历，栈</h4><ul><li>每次将压入的元素和栈顶元素比较，如果一致就是重复，则新元素不入栈，栈顶元素出栈，这样可以很好的把中间有其他相同元素隔开的多个相同元素找出来。</li><li>反向遍历只是为了正向输出结果</li><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="c++">class Solution &#123;public:    string removeDuplicates(string S) &#123;        stack&lt;char&gt;s;        int len = S.size();        string res = &quot;&quot;;                for(int i = len-1; i &gt;= 0 ; i--)&#123;            if(!s.empty())&#123;                if(s.top() == S[i])&#123;                    s.pop();                &#125;else&#123;                    s.push(S[i]);                &#125;            &#125;else&#123;                s.push(S[i]);            &#125;             &#125;        while(!s.empty())&#123;            res += s.top();            s.pop();        &#125;           return res;       &#125;</code></pre><h4 id="solution2-用string变相作为栈"><a href="#solution2-用string变相作为栈" class="headerlink" title="solution2-用string变相作为栈"></a>solution2-用string变相作为栈</h4><ul><li>这种写法，应该对string中的方法有充足的了解</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution &#123;public:    string removeDuplicates(string S) &#123;        string res = &quot;&quot;;        for(char c : S)&#123;            if(res.size() &amp;&amp; res.back() == c)                 res.pop_back();//凡是涉及到删除元素的操作，都要首先判断是否有元素            else                res.push_back(c);           &#125;        return res;    &#125;&#125;;</code></pre><h3 id="682-Baseball-Game"><a href="#682-Baseball-Game" class="headerlink" title="682.Baseball Game"></a>682.Baseball Game</h3><ul><li>“C”表示无效前一轮分数，“D”表示将前一轮有效分数乘2作为本轮分数，“+”表示将前两轮的分数之和作为本轮分数。</li></ul><p><strong>Example 1:</strong></p><pre><code>Input: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]Output: 30Explanation: Round 1: You could get 5 points. The sum is: 5.Round 2: You could get 2 points. The sum is: 7.Operation 1: The round 2&#39;s data was invalid. The sum is: 5.  Round 3: You could get 10 points (the round 2&#39;s data has been removed). The sum is: 15.Round 4: You could get 5 + 10 = 15 points. The sum is: 30.</code></pre><h4 id="solution-辅助栈，字符串处理"><a href="#solution-辅助栈，字符串处理" class="headerlink" title="solution-辅助栈，字符串处理"></a>solution-辅助栈，字符串处理</h4><ul><li>完全按照人脑思维，对每个字符可能的情况进行判断</li><li>需要注意的就是，输入是一个字符串的数组，即数组中每个元素为字符串，当score为整数，且位数多于两位，则需要一个个遍历，算出字符串对应的整数。手动的算了。这里要注意有负数的情况。</li><li>时间：O(n)，空间：O(2)——一个辅助栈</li></ul><pre><code class="C++">class Solution &#123;public:    int calPoints(vector&lt;string&gt;&amp; ops) &#123;        stack&lt;int&gt;score;                for(string s : ops)&#123;            char c = s[0];                        if(c == &#39;C&#39;)&#123;                score.pop();            &#125;else if(c == &#39;D&#39;)&#123;                int tmp = score.top();                score.push(tmp*2);            &#125;else if(c == &#39;+&#39;)&#123;                int tmp1 = score.top();                score.pop();                int cur = tmp1 + score.top();                score.push(tmp1);                score.push(cur);            &#125;else&#123;                int num = 0;                bool flag = false;//是否为负数                for(char c : s)&#123;                    if(c == &#39;-&#39;)&#123;                        flag = true;                        continue;                    &#125;                    int val = c - &#39;0&#39;;                    num = num*10 + val;                &#125;                if(flag)                    score.push(-num);                else                     score.push(num);            &#125;         &#125;        int sum = 0;        while(!score.empty())&#123;            sum += score.top();            score.pop();        &#125;        return sum;    &#125;</code></pre><h4 id="solution2-vector"><a href="#solution2-vector" class="headerlink" title="solution2-vector"></a>solution2-vector</h4><ul><li>我简直就是一个被残害的少年，为什么想不开总是用stack，既不能随机访问，还得控制顺序</li><li>语法：STL 算法求和<ul><li>int sum = accumulate(score.begin(),score.end(),10);//以10为基础开始加</li><li>string sum = accumulate(v.begin() , v.end() , string(“ “));将字符串连接起来</li></ul></li><li>找到了一个C++11里面字符串转整数的操作stoi(s,0,10)——将s从第0位开始，转换成10进制数。</li><li>判断是否为数字：isdigit()</li></ul><pre><code class="C++">class Solution &#123;public:    int calPoints(vector&lt;string&gt;&amp; ops) &#123;        vector&lt;int&gt;score;        int index = 0;        for(string s : ops)&#123;            if(isdigit(s[0]) || s[0] == &#39;-&#39;)&#123;               score.push_back(stoi(s));                            &#125;else if(s == &quot;+&quot;)&#123;                score.push_back(score[index]+score[index-1]);            &#125;else if(s == &quot;D&quot;)&#123;                score.push_back(score[index]*2);            &#125;else&#123;                score.pop_back();            &#125;        index = score.size()-1;        &#125;        return accumulate(score.begin(),score.end(),0);            &#125;&#125;;</code></pre><h3 id="844-Backspace-String-Compare"><a href="#844-Backspace-String-Compare" class="headerlink" title="844.Backspace String Compare"></a>844.Backspace String Compare</h3><p><strong>题目描述</strong></p><p>Given two strings <code>S</code> and <code>T</code>, return if they are equal when both are typed into empty text editors. <code>#</code> means a backspace character.</p><p><strong>Example :</strong></p><pre><code>Input: S = &quot;ab##&quot;, T = &quot;c#d#&quot;Output: trueExplanation: Both S and T become &quot;&quot;.Input: S = &quot;a#c&quot;, T = &quot;b&quot;Output: falseExplanation: S becomes &quot;c&quot; while T becomes &quot;b&quot;.</code></pre><h4 id="solution1-辅助栈"><a href="#solution1-辅助栈" class="headerlink" title="solution1-辅助栈"></a>solution1-辅助栈</h4><ul><li>想先比较一下两个字符串的大小，但是不行，因为如果一个比另一个多个#，也返回true；比如”ab##””c#d##”;</li><li>最朴素的做法就是用两个辅助栈,当遇到’#’且栈不为空时就pop，否则入栈，然后从栈中依次弹出元素，比较是否相等，最后还要判断栈内有没有剩余元素 。</li><li>时间O(n)，空间O(n)</li></ul><pre><code class="C++">class Solution &#123;public:    bool backspaceCompare(string S, string T) &#123;        stack&lt;char&gt; s;        stack&lt;char&gt; t;                for(int i = 0; i &lt; S.size(); i++)&#123;            if(S[i] == &#39;#&#39;)&#123;                if(!s.empty())&#123;                    s.pop();                &#125;            &#125;else                s.push(S[i]);                          &#125;                for(int j = 0; j&lt; T.size(); j++)&#123;            if(T[j] == &#39;#&#39;)&#123;                if(!t.empty())                    t.pop();            &#125;else                t.push(T[j]);                        &#125;        while(!s.empty() &amp;&amp; !t.empty())&#123;            if(s.top() != t.top())                return false;            s.pop();            t.pop();        &#125;        if(!s.empty() || !t.empty())            return false;//一个栈内元素比另一个的多        return true;    &#125;</code></pre><h4 id="solution2-双指针"><a href="#solution2-双指针" class="headerlink" title="solution2-双指针"></a>solution2-双指针</h4><ul><li>从后向前遍历，用count记录出现过的‘#’</li><li>如果count &gt; 0 &amp;&amp; 当前是一个非‘#’，说明可以对这个进行删除，count–；</li><li>如果当前是 ‘#’，则count++</li><li>否则比较两个元素，如果不相等，则false</li><li>测试用例需要考虑‘#’对的位置，最开头，中间，结尾，两个字符串长度不一样。能想出这种做法，并且把边界条件控制的很好的人，也是绝了。</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">/*class Solution &#123;public:    bool backspaceCompare(string S, string T) &#123;        stack&lt;char&gt; s;        stack&lt;char&gt; t;        int lens = S.size();        int lent = T.size();        for(int i = 0; i &lt; lens; i++)&#123;            if(S[i] == &#39;#&#39;)&#123;                if(!s.empty())&#123;                    s.pop();                &#125;            &#125;else                s.push(S[i]);                          &#125;                for(int j = 0; j&lt; lent; j++)&#123;            if(T[j] == &#39;#&#39;)&#123;                if(!t.empty())                    t.pop();            &#125;else                t.push(T[j]);                        &#125;        while(!s.empty() &amp;&amp; !t.empty())&#123;            if(s.top() != t.top())                return false;            s.pop();            t.pop();        &#125;        if(!s.empty() || !t.empty())            return false;//一个栈内元素比另一个的多        return true;    &#125;&#125;;*/class Solution &#123;public:    bool backspaceCompare(string S, string T) &#123;        int i = S.size()-1;        int j = T.size()-1;        int countS = 0,countT = 0;                //存在两个字符串不一样长的情况        while(i &gt;= 0 || j &gt;= 0)&#123;            while(i &gt;= 0 &amp;&amp; (S[i] == &#39;#&#39; || countS &gt; 0))&#123;                if(S[i] == &#39;#&#39;)&#123;                    countS++;                &#125;else&#123;                    countS--;                &#125;                i--;            &#125;            while(j &gt;=0 &amp;&amp; (T[j] == &#39;#&#39; || countT &gt; 0))&#123;                if(T[j] == &#39;#&#39;)&#123;                    countT++;                &#125;else&#123;                    countT--;                &#125;                j--;            &#125;                        if(i &lt; 0 || j &lt; 0)                return i == j;                            if(S[i] != T[j])                return false;            else&#123;                 i--;                 j--;            &#125;                   &#125;               return i == j;    &#125;&#125;;</code></pre><h3 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232.Implement Queue using Stacks"></a>232.Implement Queue using Stacks</h3><pre><code class="C++">class MyQueue &#123;public:    stack&lt;int&gt;s1;    stack&lt;int&gt;s2;            /** Initialize your data structure here. */    MyQueue() &#123;&#125;        /** Push element x to the back of queue. */    void push(int x) &#123;        s1.push(x);    &#125;        /** Removes the element from in front of queue and returns that element. */    int pop() &#123;        while(!s1.empty())&#123;            s2.push(s1.top());            s1.pop();         &#125;        int res = s2.top();        s2.pop();        while(!s2.empty())&#123;            s1.push(s2.top());            s2.pop();        &#125;          return res;       &#125;        /** Get the front element. */    int peek() &#123;        while(!s1.empty())&#123;            s2.push(s1.top());            s1.pop();         &#125;        int res = s2.top();        while(!s2.empty())&#123;            s1.push(s2.top());            s2.pop();        &#125;          return res;       &#125;        /** Returns whether the queue is empty. */    bool empty() &#123;        if(s1.empty())            return true;        else            return false;    &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */</code></pre><h3 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225.Implement Stack using Queues"></a>225.Implement Stack using Queues</h3><pre><code class="C++">class MyStack &#123;public:    queue&lt;int&gt;q;    /** Initialize your data structure here. */    MyStack() &#123;&#125;        /** Push element x onto stack. */    void push(int x) &#123;        q.push(x);    &#125;        /** Removes the element on top of the stack and returns that element. */    int pop() &#123;        int res = q.back();        int len = q.size();        queue&lt;int&gt;tmp;        while(len &gt; 1)&#123;            tmp.push(q.front());            q.pop();            len--;        &#125;        q.pop();        while(!tmp.empty())&#123;            q.push(tmp.front());            tmp.pop();        &#125;        return res;    &#125;        /** Get the top element. */    int top() &#123;        return q.back();    &#125;        /** Returns whether the stack is empty. */    bool empty() &#123;        return q.empty();    &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */</code></pre><h3 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155.Min Stack"></a>155.Min Stack</h3><pre><code class="c++">/*solution- 用一个全局变量来保存最小值，这样可以在常数时间内返回最小值- 在push(),pop()时，更新minElenm*/class MinStack &#123;public:    int minElem = 0x7fffffff;    stack&lt;int&gt; s;    /** initialize your data structure here. */    MinStack() &#123;    &#125;        void push(int x) &#123;        s.push(x);        if(x &lt; minElem)            minElem = x;    &#125;        void pop() &#123;        int x = s.top();        s.pop();        if(x == minElem)&#123;            minElem = 0x7fffffff;            stack&lt;int&gt; tmp;            while(!s.empty())&#123;                int t = s.top();                s.pop();                tmp.push(t);                                if(t &lt; minElem)&#123;                    minElem = t;                &#125;            &#125;            while(!tmp.empty())&#123;                s.push(tmp.top());                tmp.pop();            &#125;                    &#125;            &#125;        int top() &#123;        return s.top();    &#125;        int getMin() &#123;        return minElem;    &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */</code></pre><h3 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20.Valid Parentheses"></a>20.Valid Parentheses</h3><p><strong>题目描述</strong></p><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;([)]&quot;Output: false</code></pre><h4 id="错！solution1-cnt统计左括号个数"><a href="#错！solution1-cnt统计左括号个数" class="headerlink" title="错！solution1-cnt统计左括号个数"></a>错！solution1-cnt统计左括号个数</h4><ul><li>用cnt计数，分别表示三种括号的左括号个数，当有右括号时，cnt–，左括号时，cnt++。但是”({)”这种，无法正确判断。——只能用于只有一种括号的情况</li><li>时间：O(n)，空间：O(1)</li></ul><h4 id="solution2-辅助栈"><a href="#solution2-辅助栈" class="headerlink" title="solution2-辅助栈"></a>solution2-辅助栈</h4><ul><li>如果是左括号，进栈，如果是右括号，匹配栈顶是否为对应的左括号</li><li>时间：O(n)，空间：O(n)-辅助栈</li></ul><pre><code class="c++">class Solution &#123;public:    bool isValid(string s) &#123;        stack&lt;char&gt;ch;        for(int i = 0; i &lt; s.size(); i++)&#123;            if(s[i] == &#39;(&#39; || s[i] == &#39;&#123;&#39; || s[i] == &#39;[&#39;)                ch.push(s[i]);            else&#123;                if(ch.empty()) return false;//这个很重要，要弹出，首先就要判断栈是否为空                if(s[i] == &#39;)&#39; &amp;&amp; ch.top() != &#39;(&#39;)                    return false;                if(s[i] == &#39;&#125;&#39; &amp;&amp; ch.top() != &#39;&#123;&#39;)                    return false;                if(s[i] == &#39;]&#39; &amp;&amp; ch.top() != &#39;[&#39;)                    return false;                                ch.pop();            &#125;               &#125;        return ch.empty();             &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
