<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从头搭建以太坊私链</title>
      <link href="/2019/10/19/%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/"/>
      <url>/2019/10/19/%E4%BB%8E%E5%A4%B4%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h3 id="安装geth-通过源码编译安装"><a href="#安装geth-通过源码编译安装" class="headerlink" title="安装geth -通过源码编译安装"></a>安装geth -通过源码编译安装</h3><p>参考<a href="https://media.consensys.net/how-to-build-a-private-ethereum-blockchain-fbf3904f337" target="_blank" rel="noopener">这个</a>文档</p><ol><li><p><code>[haiki@localhost ~]$ mkdir ethereum</code></p></li><li><p><code>[haiki@localhost ~]$ cd ethereum</code></p></li><li><p><code>[haiki@localhost ethereum]$ git clone https://github.com/ethereum/go-ethereum.git</code></p></li><li><p><code>cd go-ethereum</code></p></li><li><p><code>make geth</code> 进行编译，得到可执行程序，得到编译结尾如下图，则表示编译成功。</p><p><img src="https://i.loli.net/2019/10/19/xMKDnI1kmlCSZNR.jpg" alt="makeGrth.JPG"></p></li><li><p>按照上图提示，需要在执行make的当前目录下执行 <code>./build/bin/geth</code>去安装 geth。此时，我所在的目录是 <code>/home/haiki/ethereum/go-ethereum</code>，如果已经进入到了 <code>/home/haiki/ethereum/go-ethereum/build/bin</code>，可以直接 <code>./geth</code>进行安装。其中，加 <code>./</code> 表示执行当前目录下的 geth 可执行文件。</p></li><li><p>现在，相当于 <code>/home/haiki/ethereum/go-ethereum/build/bin</code>目录下已经有了geth 这个可执行程序，相当于 windows 下的 .exe程序，在这个 bin 目录下，执行 <code>geth version</code>，查看安装是否成功，出现下图，则成功。</p><p><img src="https://i.loli.net/2019/10/19/ZGx3cWEPrCjQnYH.jpg" alt="gethVersion.JPG"></p></li><li><p>如果要使用这个程序，那么需要总是把geth所在的路径包含上，这时候，可以设置一个全局的环境变量，在哪里都可以执行用geth命令。</p><ol><li><code>vim /home/haiki/.bashrc</code></li><li><code>export GETHPATH=/home/haiki/ethereum/go-ethereum/build</code>，在原来的  <code>PATH</code>上加一个 <code>geth</code> 的路径： <code>export PATH=$GOPATH/bin:$GOROOT/bin:$PATH:$GETHPATH/bin</code></li><li>此时，在任何目录下（不必须是 <code>geth</code> 所在的目录下），执行 <code>geth version</code>都可以出现上图的结果。</li></ol></li></ol><ol><li><p>创建账户，作为区块链节点的coinbase</p><ol><li><p><code>[haiki@localhost ~]$ geth account new</code>，按照提示，输入密码（这里是123456）。这个密码不能忘记，忘记没有找回选项。</p></li><li><p>按照屏幕显示的结果，即下图，可以知道，得到的地址，密钥文件的存放路径，以及一些安全提示信息。</p><ul><li>地址是 <code>0x0475eA0D：qb7f5D2d676284fe37DE062cA72EA35d6</code></li></ul><p><img src="https://i.loli.net/2019/10/19/OQra2vlzexKj6Fu.jpg" alt="gethAccountNew.JPG"></p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> 私链 </tag>
            
            <tag> geth </tag>
            
            <tag> go环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>speedyMurmurs源码分析Dynamic部分</title>
      <link href="/2019/10/16/speedyMurmurs%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Dynamic%E9%83%A8%E5%88%86/"/>
      <url>/2019/10/16/speedyMurmurs%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Dynamic%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>Dynamic.class</p><pre><code class="java">&quot;SKIP_EXISTING_DATA_FOLDERS&quot;, &quot;false&quot;&quot;MAIN_DATA_FOLDER&quot;,&quot;./data/&quot;String path = &quot;../data/&quot;;@param args    0: run //使用第几组数据    1: config (0- SilentWhispers, 7- SpeedyMurmurs, 10-MaxFlow)    2: steps previously completed  if(step==0){    graph =  path+&quot;finalSets/dynamic/jan2013-lcc-t0.graph&quot;;//Number of Nodes:93502,Number of Edges: 331096    trans = path+&quot;finalSets/dynamic/jan2013-trans-lcc-noself-uniq-1.txt&quot;; &lt;四元组&gt;    newlinks = path+&quot;finalSets/dynamic/jan2013-newlinks-lcc-sorted-uniq-t0.txt&quot;;&lt;四元组&gt;}//对于SW，参数分别表示：图数据，name，交易，新边，类型（SW/SM/Max），第几组数据case 0: runDynSWSM(new String[] {graph, &quot;SW-P&quot;+(step+1),trans ,  newlinks, &quot;0&quot;, &quot;&quot;+run}); break;//对于SMcase 7: runDynSWSM(new String[] {graph, &quot;SM-P&quot;+(step+1), trans ,  newlinks, &quot;7&quot;, &quot;&quot;+run}); break;//对于MaxFlowcase 10: runMaxFlow(graph, trans, &quot;M-P&quot;+(step+1), newlinks, 165.55245497208898*1000); break;</code></pre><pre><code class="java">runDynSWSM(String[] args)&quot;SERIES_GRAPH_WRITE&quot;, &quot;&quot;+true&quot;SKIP_EXISTING_DATA_FOLDERS&quot;, &quot;false&quot;graph,name,trans,add,type,iepoch = 165.55245497208898*1000;max = 1;//一笔交易的尝试次数就是1次dyn,multi//对于SW，分别是false，true，对于SM，分别是true，false    ra = new TreerouteSilentW();        ParameterList.key = &quot;TREE_ROUTE_TDRAP&quot;        ParameterList.parameters = new Parameter[0];        Treeroute.rand = new Random();    ra = new TreerouteTDRAP();        ParameterList.key = &quot;TREE_ROUTE_SILENTW&quot;         ParameterList.parameters = new Parameter[0];        Treeroute.rand = new Random();double req = 165.55245497208898*2;int[] roots = {64,36,43};//直接给定下来了。。。Partitioner part = new RandomPartitioner();    Partitioner.name = &quot;RANDOM_PARTITIONER&quot;;    RandomPartitioner.rand = new Random();Network net = new ReadableFile(name, name,graph,null);</code></pre><pre><code class="java">//网络读取数据的参数//name = &quot;SW-P&quot;+(step+1)/&quot;SM-P&quot;+(step+1)/&quot;M-P&quot;+(step+1)Network net = new ReadableFile(name, name,graph,null);    ReadableFile.filename = graph;    ParameterList.key = &quot;READABLE_FILE_&quot; + name;    ParameterList.parameters = {[&quot;NODES&quot;:93502]};    Network.node = 93502;    Network.transformations = new Transformation[0];</code></pre><pre><code class="java">//具体的ra算法CreditNetwork cred = new CreditNetwork(trans, name, epoch, ra, dyn, multi, req, part, roots, max, add);    public CreditNetwork(String file, String name, double epoch, Treeroute ra, boolean dynRep,             boolean multi, double requeueInt, Partitioner part, int[] roots, int max, String links){        this(file,name,epoch,ra,dynRep, multi, requeueInt, part, roots, max, links, true);    }        ParameterList.key = &quot;CREDIT_NETWORK&quot;；        ParameterList.parameters = new Parameter[]{new StringParameter(&quot;NAME&quot;, name),                 new DoubleParameter(&quot;EPOCH&quot;, epoch),                new StringParameter(&quot;RA&quot;, ra.getKey()),                 new BooleanParameter(&quot;DYN_REPAIR&quot;, dynRep),                 new BooleanParameter(&quot;MULTI&quot;, multi),                 new IntParameter(&quot;TREES&quot;, roots.length),                new DoubleParameter(&quot;REQUEUE_INTERVAL&quot;, requeueInt),                 new StringParameter(&quot;PARTITIONER&quot;, part.getName()),                new IntParameter(&quot;MAX_TRIES&quot;,max)});        CreditNetwork.epoch = epoch;        CreditNetwork.ra = ra;        CreditNetwork.multi = multi;        CreditNetwork.dynRepair = dynRep;        transactions = this.readList(file);        CreditNetwork.requeueInt = requeueInt;        CreditNetwork.part = part;        CreditNetwork.roots = roots;        CreditNetwork.maxTries = max;        if (links != null){            this.newLinks = this.readLinks(links);    //把新边信息存起来</code></pre>]]></content>
      
      
      <categories>
          
          <category> 论文相关总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> speedymurmurs </tag>
            
            <tag> payment routing </tag>
            
            <tag> 路由算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>speedyMurmurs源码分析</title>
      <link href="/2019/10/11/speedyMurmurs%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/10/11/speedyMurmurs%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>Static.main</p><h3 id="Config文件的读取"><a href="#Config文件的读取" class="headerlink" title="Config文件的读取"></a>Config文件的读取</h3><pre><code class="java">String defaultConfigFolder = &quot;./config/&quot;;Config.overwrite(String key, String value) &lt;speedy\src\gtna\util\Config.java&gt;    if properties == null  // Properties extends Hashtable&lt;Object,Object&gt;        Config.init() //将./config中的所有.properties文件内容加载到properties中；先得到./config下的文件夹绝对路径            Config.initWithFolders    //然后得到各文件夹下的.properties文件绝对路径                Config.initWithFiles //读取.properties文件                        Config.addFile                    Util.toStringArray(v)    //用来把存储在vector中的文件绝对路径转换成字符数组string[]    overwrite.put(key,val);// HashMap&lt;String, String&gt; overwrite;</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><pre><code class="java">@param args 0: run (integer 0-19)   //对应于20组交易数据， 1: config (0: LM-MUL-PER(SilentWhispers), 1: LM-RAND-PER, 2: LM-MUL-OND, 3:LM-RAND-OND, 4: GE-MUL-PER, 5: GE-RAND-PER, 6: GE-MUL-OND, 7:GE-RAND-OND (SpeedyMurmurs), 8: ONLY-MUL-PER, 9:ONLY-RAND-OND, 10: max flow)  2: #transaction attempts             //交易重新发送次数，跑的时候使用了2；对比实验是1-10 3: #embeddings/trees (integer &gt; 0)         //用了3；对比实验是1-7transList = &quot;../data/finalSets/static/sampleTr-&quot; + i + &quot;.txt&quot;; &lt;src,dst,val,time&gt;graph = &quot;../data/finalSets/static/ripple-lcc.graph&quot;;//&lt;节点：相邻节点1；相邻节点2...相邻节点n&gt;degFile = &quot;../data/finalSets/static/degOrder-bi.txt&quot;;//是排序的，每一行的数代表对应行度数的节点index&lt;度数为i的节点&gt;name = &quot;STATIC&quot;;    //实验名称epoch = 1000;    //每1000笔交易算一个epochtl = 2 * epoch;    //重试交易的时间间隔up = false; //无update</code></pre><pre><code class="java">//为不同树上的路径分配路由的资金数Partitioner part = new RandomPartitioner();    //实例化Partitioner    RandomPartitioner.rand =  new Random();    Partitioner.name = &quot;RANDOM_PARTITIONER&quot;;</code></pre><pre><code class="java">// 选择生成树的根节点// 其中，random表示随机选取root节点，当为false时，使用最大度的方法，即在degFile中选择前trees个节点。//如果使用随机，则使用i（当前是第几个run）作为随机种子初始化rand，之后遍历文件得到最大度，以最大度为界，随机出root（rand.nextInt）Misc.selectRoots(String file, boolean random, int trees, int seed)        Misc.selectRoots(degFile, random:false, trees, i)</code></pre><pre><code class="java">//实例化不同的路由算法RATreeroute sW = new TreerouteSilentW();    Metric.key = &quot;TREE_ROUTE_SILENTW&quot;;    Metric.parameters = new Parameter[0];    Treeroute.rand = new Random();Treeroute voute = new TreerouteTDRAP();//TreerouteTDRAP继承TreerouteNH，TreerouteNH继承Treeroute    TreerouteNH        Metric.key = &quot;TREE_ROUTE_TDRAP&quot;;        Metric.parameters = new Parameter[0];        Treeroute.rand = new Random();Treeroute only = new TreerouteOnly();    Metric.key = &quot;TREE_ROUTE_ONLY&quot;;    Metric.parameters = new Parameter[0];    Treeroute.rand = new Random();</code></pre><pre><code class="java">// 各种路由的参数组合实例化//vary dynRepair, multi, routing algo -&gt; 8 poss + 2 treeonly versions// String[] com = { &quot;SW-PER-MUL&quot;, &quot;SW-PER&quot;, &quot;SW-DYN-MUL&quot;, &quot;SW-DYN&quot;, &quot;V-PER-MUL&quot;, &quot;V-PER&quot;, &quot;V-DYN-MUL&quot;, &quot;V-DYN&quot;, &quot;TREE-ONLY1&quot;, &quot;TREE-ONLY1&quot; };//三种不同的路由算法，使用不同的组合，实例化CreditNetwork    CreditNetwork silentW = new CreditNetwork(transList, name, epoch, sW, false, true, tl, part, roots, tries, up);     public CreditNetwork(String file, String name, double epoch, Treeroute ra, boolean dynRep,             boolean multi, double requeueInt, Partitioner part, int[] roots, int max, boolean up){        this(file,name,epoch,ra,dynRep, multi, requeueInt, part, roots, max, null,up);//调用本类中的重载函数    }            public CreditNetwork(String file, String name, double epoch, Treeroute ra, boolean dynRep,                 boolean multi, double requeueInt, Partitioner part, int[] roots, int max, String links, boolean up)            Metric                ParameterList.key = &quot;CREDIT_NETWORK&quot;；                ParameterList.parameters = new Parameter[]{                        new StringParameter(&quot;NAME&quot;, name),                         new DoubleParameter(&quot;EPOCH&quot;, epoch),                        new StringParameter(&quot;RA&quot;, ra.getKey()),                         new BooleanParameter(&quot;DYN_REPAIR&quot;, dynRep),                         new BooleanParameter(&quot;MULTI&quot;, multi),                         new IntParameter(&quot;TREES&quot;, roots.length),                        new DoubleParameter(&quot;REQUEUE_INTERVAL&quot;, requeueInt),                         new StringParameter(&quot;PARTITIONER&quot;, part.getName()),                        new IntParameter(&quot;MAX_TRIES&quot;,max)});</code></pre><pre><code class="java">//network实例化，加载图数据，节点个数，文件夹//Config.overwrite(&quot;READABLE_FILE_&quot; + folder + &quot;_NAME_SHORT&quot;, name); 初始化当前网络的名称// String[] com = { &quot;SW-PER-MUL&quot;, &quot;SW-PER&quot;, &quot;SW-DYN-MUL&quot;, &quot;SW-DYN&quot;, &quot;V-PER-MUL&quot;, &quot;V-PER&quot;, &quot;V-DYN-MUL&quot;, &quot;V-DYN&quot;, &quot;TREE-ONLY1&quot;, &quot;TREE-ONLY1&quot; };Network network = new ReadableFile(com[config], com[config], graph, t:null);    public ReadableFile(String name, String folder, String filename,Transformation[] t)        this(name, folder, filename, new Parameter[0], t);        ReadableFile(String name, String folder, String filename, Parameter[] parameters, Transformation[] t)            ParameterList.key = &quot;READABLE_FILE_&quot; + folder;            ParameterList.parameters = new IntParameter(&quot;NODES&quot;, nodes);//这个nodes数是从graph中的第二行得到的67149            Network.nodes = nodes;            Network.transformations = transformations;//null</code></pre><pre><code class="java">//这里是整个程序真正的关键执行入口处，series的实例化//Metric[] m = new Metric[] { silentW, silentWnoMul, silentWdyn, silentWdynNoMul, vouteMulnoDyn, voutenoDyn, vouteMul,voutenoMul, treeonly1, treeonly2 };Series.generate(network, new Metric[] { m[config] }, i, i);Series generate(Network nw, Metric[] metrics, int startRun,int endRun)        Series s = new Series(nw, metrics);        s.network = network;        s.metrics = metrics;        s.mainDataFolder = Config.get(&quot;MAIN_DATA_FOLDER&quot;);//生成数据的文件夹，./data/static/，这个在config文件中是./data，但是程序运行一开始就overwrite成./data/static了    folder.mkdirs();    //older = new File(s.getFolder());生成 ./data/static/READABLE_FILE_SW-PER-MUL-67149/，用的是network对象    folder.mkdirs();    //folder = new File(s.getFolder(m)); 由metric对象，得到文件名称 &quot;CREDIT_NETWORK-9个参数&quot;，见CreditNetwork    Series.generateRun(s, run);</code></pre><pre><code class="java">//创建文件夹，图数据读取Series.generateRun(s, run);        System.out.println(&quot;\n&quot; + run + &quot;:&quot;);    ArrayList&lt;Single&gt; runtimes = new ArrayList&lt;Single&gt;();    ArrayList&lt;Single&gt; etc = new ArrayList&lt;Single&gt;();    File folder = new File(s.getSeriesFolderRun(run));//这里得到的folder应该是./data/static/READABLE_XXX_/0...19    输出：G: SW-PER-MUL(N = 67149)//使用timer输出的一段话，记录图生成时间，意指graph or generate    Graph g = s.getNetwork().generate();//ReadableFile,生成图，ripple-lcc.graph中有节点和边的信息了，这里需要用ripple-lcc-CREDIT_LINKS.graph加载权重信息，即添加图的properties        ReadableFile.generate();            Graph graph = new GtnaGraphReader().readWithProperties(this.filename);//filename是graph的绝对路径，这里是读取creditlinks的权值信息                readWithProperties(filename, properties);//GraphReader.java; properties是ripple-lcc-CREDIT_LINKS.graph的绝对路径                    GraphProperty property = (GraphProperty) ClassLoader.getSystemClassLoader().loadClass(className).newInstance();//感觉是CreditLink类的实例化                    String key = property.read(prop);// CreditLinks.read(filename);//将所有的权值信息保存在CreditLink.weights中，并返回key值CREDIT_LINKS                    graph.addProperty(key, property);//key = REDIT_LINKS，即ripple-lcc-CREDIT_LINKS.graph中的key            graph.setName(this.getDescription());                Graph.name = ???    runtimes.add(new Single(&quot;G_RUNTIME&quot;, timer.getRuntime()));//./data/static/READABLE_V-ROUTE_67149/0...19/runtime.txt：G_RUNTIME=0.54    输出：P: CREDIT_LINKS//意指 properties    folder = new File(s.getMetricFolder(run, m));//folder.mkdirs();//CREDIT_NETWORK-STATIC-1000.0-TREE_ROUTE_SILENTW-false-true-3-2000.0-RANDOM_PARTITIONER-2    输出：M：CNET(name=STATIC,epoch=1000,ra-Tree=XXX,dr=XX,mul=XX,trees=X,ri=XX,part=XXX,mt=XX)    m.computeData(g, s.getNetwork(), metrics);    runtimes.add(new Single(m.getRuntimeSingleName(), timer.getRuntime()));//runtime.txt:CREDIT_NETWORK-STATIC-1000.0-TREE_ROUTE_SILENTW-false-true-1-2000.0-RANDOM_PARTITIONER-2_RUNTIME=86.41    m.writeData(s.getMetricFolder(run, m));//CreditNetwork.java;把生成的结果数据写入文件夹；folder是CREDIT_NETWORK-STATIC-1000.0-TREE_ROUTE_SILENTW-false-true-3-2000.0-RANDOM_PARTITIONER-2下的各个.txt文件    SingleList singleList = new SingleList(m, m.getSingles());//this.metric = metric; this.singles = singles;this.map = new HashMap&lt;String, Single&gt;();        m.getSingles()；//得到每个single            return new Single[]{m_av, m_Re_av, m_S_av, m_F_av,p_av, p_Re_av, p_S_av, p_F_av, reL_av, ls_av, s_av, s1, s, pP_av, pPF_av, pPNF_av, rt,d1,d2,d3};    singleList.write(s.getSinglesFilenameRun(run, m));//写入_singles.txt文件    SingleList rt = new SingleList(null, runtimes);    rt.write(s.getRuntimesFilenameRun(run));// runtimes.txt 文件写入    //etc文件写入    int mb = 1024 * 1024;    Runtime runtime = Runtime.getRuntime();    double used = (runtime.totalMemory() - runtime.freeMemory()) / mb;    etc.add(new Single(&quot;MEMORY_USED&quot;, used));    SingleList etcSl = new SingleList(null, etc);    etcSl.write(s.getEtcFilename(run));</code></pre><pre><code class="java">//路由，执行交易，统计各项数据m.computeData(g, s.getNetwork(), metrics);    Treeembedding embed = new Treeembedding(&quot;T&quot;,60,roots, MultipleSpanningTree.Direct.TWOPHASE);{        this(name,pad,roots.length,turnSelector(roots),1,false, dir);    }        Treeembedding(String name, int pad, int k, String rootSelector, double p, boolean depth, MultipleSpanningTree.Direct dir)            ParameterList.key = &quot;TREE_EMBEDDING&quot;;        ParameterList.parameters = new Parameter[]{                    new StringParameter(&quot;NAME&quot;, name), //&quot;T&quot;                    new IntParameter(&quot;PAD&quot;, pad),                     new IntParameter(&quot;TREES&quot;,k),                     new StringParameter(&quot;ROOT&quot;,rootSelector),//就是把root的索引拼接起来，1-2-3这样                    new DoubleParameter(&quot;P&quot;,p), //1                    new BooleanParameter(&quot;DEPTH&quot;, depth), //false                    new StringParameter(&quot;PARENT_DIR&quot;,dir.name())}//TWOPHASE        Transformation.times = 1;        Treeembedding.padding = pad;        Treeembedding.trees = k;        rand = new Random();        Treeembedding.rootSelector = rootSelector;        Treeembedding.p = p;        Treeembedding.depth = depth;        Treeembedding.dir = dir;    if (!g.hasProperty(&quot;SPANNINGTREE_0&quot;)){            g = embed.transform(g); //给这个图生成规定的生成树，先进入Treeembedding.java，生成生成树。之后又进入spanningtree.java，给生成树的每个节点生成坐标        }    //读取交易列表，0: decide which is next transaction: previous one or new one? and add new links if any    //1: check if and how many spanning tree re-construction took place since last transaction        //do 1 (!) re-computation if there was any &amp; set stabilization cost        //如果不是实时动态修复，那么就是periodical的，SilentWhispers为代表，需要每过一个epoch计算生成树，和坐标,需要记录生成树的稳定开销。        //这里对于SM是没有开销的，因为它在静态情况下是没有新边的加入，生成树是不需要变化的        //计算开销的方法:            for (int j = epoch_old +1; j &lt;= epoch_cur; j++){                stabMes.add(this.roots.length*2*this.computeNonZeroEdges(g, edgeweights));//树的个数*2*非零的边数            }            //有些度量的计算方法完全看不懂啊。。。。    //2: execute the transaction，分为 Multi 和 Adhoc    if (this.multi){        results = this.routeMulti(cur, g, nodes, exclude, edgeweights);    } else {        results = this.routeAdhoc(cur, g, nodes, exclude, edgeweights);    }    //re-queue if necessary    //3 update metrics accordingly        path = this.inc(path, results[1]); //results[1]应该是一个比较大的数吧，在这里可以做Index？？？        reLand = this.inc(reLand, results[2]);//receiver-land        landSen = this.inc(landSen, results[3]);// land - sender        mes = this.inc(mes, results[4]);        del = this.inc(del, results[5]);        //成功情况下        mesAll = this.inc(mesAll, cur.mes);        pathAll = this.inc(pathAll, cur.path);        pathSucc = this.inc(pathSucc, results[1]);        mesSucc = this.inc(mesSucc, results[4]);        delSucc = this.inc(delSucc, results[5]); //delay        pathSF = this.inc(pathSF, val);        pathSsF[j-6] = this.inc(pathSsF[j-6], val);    //4 post-processing: remove edges set to 0, update spanning tree if dynRapir    if (this.dynRepair &amp;&amp; zeroEdges != null)         // 找到zeroEdges，对于边的src，dest，在生成树中是孩子节点的那个，做为repair的subroot        cur_stab = cur_stab + this.repairTree(nodes, sp, coords, cut, (CreditLinks) g.getProperty(&quot;CREDIT_LINKS&quot;));//开销就是边的改动        if (!this.update){                this.weightUpdate(edgeweights, originalWeight);//因为是静态的，这里就不会对原CreditLink中的值做改变            }    /SM是所有的交易都执行完，执行这个        if (this.dynRepair){            stabMes.add(cur_stab);        }            //compute metrics，使用Distribution</code></pre><pre><code class="java">//生成树的生成和坐标的生成g = embed.transform(g);public Graph transform(Graph g)//这些参数可以直接参见Treeembedding    Transformation tbfs = new MultipleSpanningTree(this.rootSelector,this.trees, rand,this.p,this.depth, this.dir);        ParameterList.key = &quot;SPANNINGTREE_BFS&quot;;        ParameterList.parameters = new Parameter[] {                     new StringParameter(&quot;ROOT_SELECTOR&quot;, rootSelector),                     new BooleanParameter(&quot;RANDOM_ORDER&quot;,true),                     new StringParameter(&quot;ONED&quot;,oneD.name())});        Transformation.times = 1;        MultipleSpanningTree.rootSelector = rootSelector;        randomorder = true;        MultipleSpanningTree.rand = rand;        MultipleSpanningTree.trees = k;        MultipleSpanningTree.p = p;        MultipleSpanningTree.d = depth;        MultipleSpanningTree.oneDSel = oneD;//TWOPHASE    g = tbfs.transform(g);//MultipleSpanningTree.transform(g) //多个生成树，确定根节点，孩子父亲节点        CreditLinks: Map&lt;Edge, double[]&gt; weights;//graph-lcc-CREDIT_LINKS        int[] r = this.selectRoot(graph, rootSelector);//又把1-2-3这种形式给分成了｛1，2，3｝        //对于所有的节点        if (this.oneDSel ==  Direct.TWOPHASE){            l = potParents(graph, nodes[i], Direct.NONE, edgeweights).length;//得到的是当前节点的无重复的相邻节点的个数，不对边做剔除                case NONE: return potChildren(g, n, Direct.NONE, ew);                    ew.getPot(in[j], n.getIndex()) &gt; 0        }        //对于不同的生成树        //分别得到根节点的入边，出边，筛选出容量大于0的节点，统计出与此节点双向的合法节点：即出和入相同的节点        int[] out = potChildren(graph, nodes[roots[i]], this.oneDSel, edgeweights);// this.oneDSel ==  Direct.TWOPHASE    //给生成树赋值坐标，根节点是空，其他节点的坐标是&lt;其父节点的坐标+随机数&gt;        //pad coordinates            //coordinate 是二维数组，第一维的长度就是节点数，第二维的长度取决于当前节点在生成树中的的层数            // 对于根节点，二维长度为0，对于第一层的节点，二维长度为1...对于 padding 则是将所有的第二维数组，填充为一样长度</code></pre><pre><code class="java">/**     * routing using a multi-part computation: costs are     * i) finding path (one-way, but 3x path length as each neighbor needs to sign its predecessor and successors)     * ii) sending shares to all landmarks/roots from receiver      * iii) sending results to sender from all landmarks/roots     * iv) testing paths (two-way)     * v) updating credit (one-way)     * @return {success?0:-1, sum(pathlength), receiver-landmark, landmarks-sender,overall message count, delay, p1, p2,...}     */    results = this.routeMulti(cur, g, nodes, exclude, edgeweights);int[] routeMulti(Transaction cur, Graph g, Node[] nodes, boolean[] exclude, CreditLinks edgeweights)        //对于不同的三棵树，在每颗树上找路径    paths[j] = ra.getRoute(src, dest, j, g, nodes, exclude);        initRoute(); //对于SW，置 up 为true，up是向上（到根）找路的意思；对于TreerouteOnly，无代码        int next = this.nextHop(src, nodes,destC,dest,exclude,pre);            //首先计算src 到 root 的路径            index = sp.getParent(cur);            //再计算 root 到 dst 的路径，找出最近的；父亲只有一个，但是孩子有很多个，要选最好的那个            int[] out = sp.getChildren(cur);            int dbest = this.getCPL(dest, this.coords[cur]);//计算src和dest坐标的相同位数，再在孩子节点中找比离 dest 更近的节点            //返回从 src 到 dest 的路径，有可能找不到路，即没有下一跳，此时需要判断，path的最后一个值是否为dest    //compute the  minimum credit along the paths，计算找到的每个树的路径上的最小值    double w = edgeweights.getPot(l,k);//对路径上的所有边，求最小    //partition transaction value，将一笔交易要转移的val，拆分成每个路径上合适的金额    vals = part.partition(g, src,dest,cur.val,mins);        //首先将一个 val， 随机的分成 trees 份，然后再根据每条路上的最小值进行调整        //对于某棵树上没有找到路，那么其最小值就是0，这样以来，就是在其他树的路径上去平分了    //check if transaction works：    //如果这棵树上有路，检查更新后的边权重是否满足原来的Creditlinks的最大最小要求，进行更新creditlinks的wt[1]    //如果所有的路径上都成功，将更新后，那些容量为0的边记录一下        CreditNetwork.zeroEdges.add(new Edge(src,dst));    //compute metrics    int[] res = new int[6+this.roots.length];//前6个是固定的要统计的值，后roots.length个值分别是各个树上的路    res[0] = success?0:-1;    res[1] = 统计总的路径长度;res[6+j] = paths[j].length-1;/-(paths[j].length-2);    //receiver-landmarks    //the sender and receiver both send only one message to each landmark forwarded by all nodes on the shortest path to the landmark.    int d = sp.getDepth(dest);    res[2] = res[2]+d*paths.length; //统计paths.length个值分别是各个树上的路；    //landmarks-sender    int d = sp.getDepth(src);    res[3] = res[3]+d;    //overall message count    res[4] = res[1]+res[2]+res[3];    res[4] = res[4]+2*(paths[j].length-1);//累加    //delay 与src，dest 的depth 有关，具体怎么算的实在是看不明白</code></pre>]]></content>
      
      
      <categories>
          
          <category> 论文相关总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> speedymurmurs </tag>
            
            <tag> payment routing </tag>
            
            <tag> 路由算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2019/10/10/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/10/10/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<ul><li><p><a href="https://zhuanlan.zhihu.com/p/40133139" target="_blank" rel="noopener">Linux 任务后台运行 —screen常用命令</a></p></li><li><p><a href="https://blog.csdn.net/hejunqing14/article/details/50338161" target="_blank" rel="noopener">用screen 在后台运行程序</a></p><ul><li>Linux使用screen之后terminal就没法往上走看前面的输出内容了，<code>ctrl a+[</code> 然后使用上下                                                         </li></ul></li><li><p><a href="https://blog.csdn.net/stormbjm/article/details/9086163" target="_blank" rel="noopener">linux下添加用户并赋予root权限</a></p><ul><li><a href="http://blog.chinaunix.net/uid-26000296-id-3496103.html" target="_blank" rel="noopener">linux新建用户与权限修改</a></li></ul></li><li><p><a href="https://blog.csdn.net/li_101357/article/details/46778827" target="_blank" rel="noopener">useradd 与adduser的区别</a></p><ul><li>用 addusr 比较好，如果用usradd，加 -m 参数，这样可以生成一个自己用户的目录</li></ul></li><li><p><a href="https://www.biaodianfu.com/linux-configure-make-make-install.html" target="_blank" rel="noopener">Linux软件安装 ./configure,make,make install的作用</a></p></li><li><p><a href="https://cnbin.github.io/blog/2015/06/22/linux-slash-configure-prefix-ming-ling/" target="_blank" rel="noopener">Linux ./configure –prefix 命令</a></p></li><li><p><a href="https://juejin.im/" target="_blank" rel="noopener">Golang环境变量设置详解</a></p></li><li><p><a href="https://www.jianshu.com/p/4e699ff478a5" target="_blank" rel="noopener">go环境变量配置 (GOROOT和GOPATH)</a></p><ul><li>GOROOT：是go的安装目录</li><li>GOPATH的值不能与GOROOT相同。用于指定我们的开发工作区(workspace),是存放源代码、测试文件、库静态文件、可执行文件的工作。</li></ul></li><li><p><a href="https://cnbin.github.io/blog/2015/06/22/linux-xiu-gai-huan-jing-bian-liang-path/" target="_blank" rel="noopener">Linux 修改环境变量 PATH</a></p></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="/2019/10/10/java/"/>
      <url>/2019/10/10/java/</url>
      
        <content type="html"><![CDATA[<ul><li><p><code>int[] num = new int[0];</code> 开辟一个大小为 0（即 <code>num.length == 0</code> ） 的空间，可以在 <code>empty array</code>上遍历，但是不能在 <code>null</code> array 上遍历。</p></li><li><p><code>readline();</code> 参见脱坑指南 <a href="https://blog.csdn.net/swingline/article/details/5357581#commentBox" target="_blank" rel="noopener">被readLine()折腾了一把</a></p></li><li><p><code>.txt</code> 文件一定要用 <code>notepad++</code> 看，用电脑自带的记事本，看起来不会空行之类的，所有数据堆成一片。</p></li><li><p><a href="https://blog.csdn.net/ustcjackylau/article/details/42454779" target="_blank" rel="noopener">java Queue中 remove/poll, add/offer, element/peek区别</a></p></li><li><p><a href="https://blog.csdn.net/foart/article/details/4295645" target="_blank" rel="noopener">Java Math的 floor,round和ceil的总结</a></p></li><li><p><a href="https://blog.csdn.net/u010255818/article/details/52733256" target="_blank" rel="noopener">java中Properties类的操作</a></p></li><li><p><a href="https://www.iteye.com/blog/tristan-wang-647729" target="_blank" rel="noopener">Java读取Properties文件的六种方法</a></p></li><li><p><a href="https://blog.csdn.net/u010983881/article/details/49762595" target="_blank" rel="noopener">HashMap 和 HashTable 的区别到底是什么？</a></p></li><li><p>ArrayList 和 LinkedList 的区别？</p></li><li><p><a href="https://blog.csdn.net/shlearry/article/details/50553986" target="_blank" rel="noopener">java中 .currentTimeMillis的用法和含义</a></p></li><li><p><a href="https://www.iteye.com/blog/blackproof-1709336" target="_blank" rel="noopener">Class.forName和ClassLoader.loadClass</a></p></li><li><p>switch case中，在某个case中定义的变量，在其他case中可以直接拿来使用。return和break的区别是，前者直接返回，不执行这个函数下面的语句了。而后者是直接跳出当前的switch语句。</p><pre><code class="java">import java.io.*;import java.util.*;public class test{    public int[] testSwitch(int n){        switch(n){            case 1:            //boolean take = new boolean[10];                int[] res = new int[10];                for(int i = 0; i &lt; 5; i++)                    res[i] = i;                return res;            case 2:                 res = new int[5];                for(int j = 0; j &lt; 5; j++)                    res[j] = j+10;                return res;        }        return null;    }    public static void main(String[] args){        test t = new test();        int[] res1 = new int[20];        res1 = t.testSwitch(2);        for(int k = 0; k &lt; res1.length; k++)            System.out.println(res1[k]+&#39;\n&#39;);            }}</code></pre></li></ul><ul><li><a href="http://outofmemory.cn/code-snippet/2099/java-usage-FilenameFilter-shaixuan-file" target="_blank" rel="noopener">java使用FilenameFilter筛选文件</a><ul><li><a href="https://stackoverflow.com/questions/19932962/use-of-filenamefilter" target="_blank" rel="noopener">stackoverflow</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA的使用：提升看源码效率</title>
      <link href="/2019/10/09/IDEA%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/10/09/IDEA%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="IntelliJ-IDEA-常见文件类型的图标介绍"><a href="#IntelliJ-IDEA-常见文件类型的图标介绍" class="headerlink" title="IntelliJ IDEA 常见文件类型的图标介绍"></a>IntelliJ IDEA 常见文件类型的图标介绍</h3><p>参见博客: <a href="https://blog.csdn.net/qq_35246620/article/details/64157559" target="_blank" rel="noopener">IntelliJ IDEA 常见文件类型的图标介绍</a></p><h3 id="IDEA中配置参数，运行main函数"><a href="#IDEA中配置参数，运行main函数" class="headerlink" title="IDEA中配置参数，运行main函数"></a>IDEA中配置参数，运行main函数</h3><p>对于java程序，编译（build）指令： <code>javac</code>，运行（run）指令： <code>java</code> ，需要安装 JDK（这里又有Oracle JDK 和 OpenJDK，自行百度区别和使用），JRE。</p><p>对于windows 配置 <code>JAVA_HOME</code>，<code>PATH</code>，<code>classpath</code> 的方法见：<a href="https://blog.csdn.net/haiki66/article/details/88758199" target="_blank" rel="noopener">Java中JAVA_HOME, PATH,CLASSPATH的作用和配置值</a></p><p>IDEA下可以有两种运行程序的方法：</p><ol><li>最上方工具栏分别找到 <code>Build</code>  和 <code>Run</code>对程序进行编译，运行。使用这种方法时，如果main函数运行时需要传入参数，参数的配置方法为：鼠标指向最上面工具栏的：<code>Run</code> ，选中左键进入<code>Edit configurations</code>。如下图所示。其中<code>program argument1</code>处依次填入需要的参数。</li></ol><ul><li>这里我们可以留意到的是：<code>Main class</code> 的书写形式， main 函数所在的类，是以包名的形式呈现的。那么对于不同类中的 main 函数，通过修改 类名即可。这样简单的配置之后，我们就可以直接用 <code>Build</code> 和 <code>Run</code> 来处理程序啦~ 很多命令的处理过程，都由IDE进行</li></ul><p><img src="https://i.loli.net/2019/10/09/oLgrNqhYudD5pbT.jpg" alt="IDEA.JPG"></p><ol start="2"><li>在终端（terminal）下运行输入 <code>javac</code> 和 <code>java</code> 编译运行程序（也就是IDE帮我们做的一些命令）。<ul><li><code>javac -classpath &lt;lib&gt; -sourcepath &lt;src&gt; -d &lt;bin&gt;</code></li><li><code>java -classpath &lt;lib&gt;&lt;:/;&gt;&lt;bin&gt; &lt;main函数所在类&gt;</code></li><li>其中，凡是用 <code>&lt;&gt;</code>框起来的都是要根据自己的实际情况进行更改的。<ul><li><code>-classpath</code>也可以简写为 <code>-cp</code>，是用来加载外部包的，比如你写的项目里面，用到了一些jar 包，那么需要把这些jar包的路径告诉 javac 这个可执行程序，也就对应于 <code>&lt;lib&gt;</code>，比如我的这个项目，某些 jar 包的路径是 <code>./lib/</code>，表示当前项目的当前文件夹下的lib文件夹下。</li><li><code>-sourcepath</code> 需要输入的是当前项目所在的文件夹，查看当前项目所在路径可以试错，也可以自行百度。示例：<code>./src/</code></li><li><code>-d</code> 是指：编译之后生成的 <code>.class</code> 文件放在哪个文件夹下，这个的文件路径可以自己设置，一般在当前项目下，新建一个文件夹，如  <code>./bin</code> 或者 <code>./out</code> 。我们要知道的是，java 运行的都是 <code>.class</code> 文件。</li><li><code>javac</code> 和 <code>java</code> 中的  <code>&lt;lib&gt;&lt;bin&gt;</code> 都一样。需要注意的是，对于 <code>java</code> 命令中 &lt;&gt;<code>&lt;:/;&gt;</code> 是说，当在unix下使用此命令时，用冒号，在window下使用时，用分号。</li><li><code>&lt;main函数所在类&gt;</code> 就是方法 1 中提到的 以包名形式的包含main函数的类名。</li></ul></li></ul></li></ol><h3 id="IDEA中查看类继承关系"><a href="#IDEA中查看类继承关系" class="headerlink" title="IDEA中查看类继承关系"></a>IDEA中查看类继承关系</h3><p>鼠标点在类名上，右键，在复选框中找到 <code>Diagrams</code> —&gt; <code>show diagrams</code> ，则可以查看类的继承关系。</p><p><img src="https://i.loli.net/2019/10/10/EWPbBq7cZnfNDKe.png" alt="IDEA1.png"></p><h3 id="函数调用关系——SourceInsight"><a href="#函数调用关系——SourceInsight" class="headerlink" title="函数调用关系——SourceInsight"></a>函数调用关系——SourceInsight</h3><p>增：10月11在意外中发现了别人写的一篇博客，好仔细！推荐！</p><p>[C 源码阅读之函数(Function/Method)调用树图( Call Graph)及数据结构依赖图][<a href="http://blog.sina.com.cn/s/blog_6b6ab0890101qd9j.html]" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_6b6ab0890101qd9j.html]</a></p><p>这个有两种方式：</p><ol><li><p>鼠标点击需要查看的函数名，在上方的菜单栏查找一个图标，如下图所示，则会显示这个函数的调用关系。</p><p><img src="https://i.loli.net/2019/10/10/8LRf45onVOvhYju.png" alt="SourceInsight.png"></p></li><li><p>鼠标右键函数名，选择 <code>Show in Relation Window</code>，会出现和 1 一样的结果。</p><ol><li>看下图，左下角会有一些小的选择，按照箭头标注，最左边点击一下，会出现列表形式的函数调用关系，在第一列，是 <code>name</code> ，默认情况下，函数是以字母序排序的，如果想按照函数调用顺序，可以鼠标左键点一下 <code>name</code>，会以英文形式提示你，现在是以什么排序的。类似文件夹下，以创建时间，或者修改日期等排序那种。这个选择好之后，点击第二个箭头指的，显示出的关系图就是按照你选定的函数的出现方式。（升序，降序，出现顺序）</li><li>接着就是调用关系是横着显示还是竖着显示；</li><li>再接着是设置。</li></ol></li></ol><p><img src="https://i.loli.net/2019/10/10/cZkgdznxXUWfowR.png" alt="SourceInsight1.png"></p><p><img src="https://i.loli.net/2019/10/10/ZKvNI78q164dm3H.png" alt="SourceInsight3.png"></p><p>还可以设置要查看的函数调用关系，是查看当前函数调用（calls）了哪些函数，调用关系显示几层。这里主要想提及的是 <code>View Relationship</code> 这里，这个选择直接决定了显示什么关系。可以看到，关系主要是用于 <code>Types（类型）、Functions（函数）、Variables（变量）、class（类）等</code> ， 需要注意的是，类的关系也可以展示，但是我更喜欢用 IDEA 的类继承关系。根据自己的需要，选择想要查看的关系图，如函数调用关系，那么要设置的是 <code>functions</code>，<code>Calls</code>表示查看这个函数开始调用了哪些，<code>calls and callers</code> 则表示此函数的调用 + 对此函数的调用。<code>reference</code> 表示引用。</p><p><img src="https://i.loli.net/2019/10/10/NibgmIKpLftDQcG.png" alt="SourceInsight4.png"></p><h3 id="IDEA中-显示函数的用法"><a href="#IDEA中-显示函数的用法" class="headerlink" title="IDEA中 显示函数的用法"></a>IDEA中 显示函数的用法</h3><p><code>Alt + F7</code>，下面会显示出哪里使用了这个函数。</p><h3 id="IDEA中-类中的函数及变量等概览"><a href="#IDEA中-类中的函数及变量等概览" class="headerlink" title="IDEA中 类中的函数及变量等概览"></a>IDEA中 类中的函数及变量等概览</h3><p><code>Alt + 7</code></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非暴力沟通摘录及观后感</title>
      <link href="/2019/10/06/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%E6%91%98%E5%BD%95%E5%8F%8A%E8%A7%82%E5%90%8E%E6%84%9F/"/>
      <url>/2019/10/06/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%E6%91%98%E5%BD%95%E5%8F%8A%E8%A7%82%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="chapter-1-—-让爱融入生活"><a href="#chapter-1-—-让爱融入生活" class="headerlink" title="chapter 1 — 让爱融入生活"></a>chapter 1 — 让爱融入生活</h3><blockquote><p>感激生活的赐予，而不贪心。</p></blockquote><p>对于一些事，是经历过的也好，期盼中的也好，总是想“如果怎样就好了”。会对已有的，不论好坏的结果有不满，会对未来未发生的，不论好坏的结果有不切实际的幻想。珍惜生活中得到的，就是最好的。</p><blockquote><p>虽然每个人的价值观和生活方式或许不同，但作为人却有着<strong>共同的感受和需要</strong>。这样，在发生矛盾和冲突的时候，运用非暴力沟通，我们将能专注于彼此的感受和需要，从而促进倾听、理解以及由衷的互助。</p></blockquote><p>举个很简单的例子，比如A喜欢B，并告诉了B，而B可能拒绝A，并且给A的理由是：我们不合适，我们三观有冲突，生活方式不一样等等；或者说A和B的交流不是很顺畅，A会和别人说，我和B三观不同，没什么好聊的。虽然这些都是需要考量的因素，也是可以理解的点。但是我还是很喜欢这句话，作为人，有着共同的感受和需要。不能因为一些先天的外界因素，限制了我们的发展，并片面化自己的交友或者生活。</p><blockquote><p>爱的能力取决于审美能力。</p></blockquote><p>有一双明察秋毫的眼睛太重要了。不管做啥事，都要擦亮你的眼睛。而“擦亮”却不是抹抹眼睛就可以的事，它需要我们培养一种审美能力。比如，如何让找到的男朋友，或者喜欢的男生不是渣男。在这一点上，我一直觉得自己是瞎子。但是在交朋友上，我感觉自己可以欣赏到各种美。</p><blockquote><p>非暴力指暴力消退后，自然流露的爱。</p></blockquote><blockquote><p>非暴力沟通的四个要素：</p><ol><li>观察</li><li>感受</li><li>需要</li><li>请求</li></ol></blockquote><p>对现状进行观察，表达自己的感受，了解是哪些需要（价值、愿望等）导致的需要，为了改善生活，提出请求。</p><p>对于别人的质疑，指责等，不要先想着如何去反驳，表达自己的感受，可以学着倾听，对于别人的问题，倾听其包含的情感和需要。通过问题，去了解对方的心灵和愤怒。让对方知道，我们确实是在感受着他们的感受。</p><h3 id="chapter-2-是什么蒙蔽了爱"><a href="#chapter-2-是什么蒙蔽了爱" class="headerlink" title="chapter 2 - 是什么蒙蔽了爱"></a>chapter 2 - 是什么蒙蔽了爱</h3><p><strong>道德评判</strong></p><blockquote><p>对他人的评价实际上反映了我们的需要和价值观。</p></blockquote><blockquote><p>分类和评判提倡的是暴力。</p></blockquote><blockquote><p>要是达不到自己的期待，我也会觉得自己有毛病。我一心想分析和确定错误的性质，而忽视自己和他人的需要。因此，如果女友想多一些体贴，那她就“太粘人了”。可是，如果我想多一些体贴，那她“冷漠得像个木头”。如果同事更关心细节，他就是“有强迫症”。反之，如果我更在乎细节，他就是“粗心大意”。</p></blockquote><blockquote><p>“暴力是不好的。杀人者是邪恶的。”然而，如果我们从小就学习爱的语言 ，我们将会直接说出我们的价值观，而不会指责他人。此时我们就会说:“对于使用暴力来解决问题，我很担心；我主张通过其他方式来解决冲突。”</p></blockquote><p><strong>进行比较</strong></p><blockquote><p>比较也是一种评判。</p></blockquote><p><strong>回避责任</strong></p><blockquote><p>我们可以用负责任的语言代替回避责任的语言。</p></blockquote><p>回避责任的语言包括：“我不得不”，“你让我”。在这个方面感觉自己做的还可以，因为性格的原因，其实很多事都是自己选择了之后做的。因为都会带有自己的目的性。比如，我要参加学生会，因为我想去组织活动，认识更多的人，最好是能遇见一个男朋友。但是我不想成为更高层管理负责的人，是因为我不想处理其中的社交关系。所有不得不做的事，而且已经做了的事，其背后一定是有满足自我的某种目的。所以，其实没什么不得不做的事。</p><blockquote><p>一旦意识不到我们是自己的主人，我们就成了危险人物。</p></blockquote><p>少一些唯唯诺诺，多一些果断和自己的想法。</p><p><strong>强人所难</strong></p><blockquote><p>长期以来，我们强调人性本恶以及通过教育来控制天性。这导致了我们对自己的感受和需要常常心存疑虑，以致不愿去体会自己的内心世界。</p></blockquote><blockquote><p>人们越是习惯于评定是非，他们也就越倾向于追随权威，来获得正确和错误的标准。一旦专注于自身的感受和需要，我们就不再是好努力和好属下。</p></blockquote><p>无需言，做自己。己所不欲，勿施于人。</p><h3 id="chapter-3-区分观察和评论"><a href="#chapter-3-区分观察和评论" class="headerlink" title="chapter 3 - 区分观察和评论"></a>chapter 3 - 区分观察和评论</h3><blockquote><p>不区分观察和评论，人们将倾向于听到批评。</p><p>不带评论的观察是人类智力的最高形式。</p></blockquote><p>观察是将事实描述出来，而评论会在事实的基础上加入个人情感。</p><h3 id="chapter-4-体会和表达感受"><a href="#chapter-4-体会和表达感受" class="headerlink" title="chapter 4 - 体会和表达感受"></a>chapter 4 - 体会和表达感受</h3><blockquote><p>示弱有助于解决冲突。</p></blockquote><blockquote><p>区分感受和自我评价。</p></blockquote><blockquote><p>为了清晰地表达感受，我们编制了以下的词汇表。<br>（1）下列词语可用来表达我们的需要得到满足时的感受:</p><p>兴奋，喜悦 ，欣喜， 甜蜜，精力充沛，兴高采烈<br>感激，感动，乐观，自信，振作，振奋，开心<br>高兴，快乐，愉快，幸福，陶醉，满足，欣慰，心旷神怡，喜出望外<br>平静，自在，舒适，放松，踏实，安全，温暖，放心，无忧无虑</p><p>（2）下列词语可用来表达我们的需要没有得到满足时的感受:</p><p>害怕，担心，焦虑，忧虑，着急，紧张，心神不宁，心烦意乱，忧伤，沮丧，灰心丧气，气馁，泄气，绝望，伤感，凄凉，悲伤，恼怒，愤怒，烦恼，苦恼，生气，厌烦，不满，不快，不耐烦，不高兴，震惊，失望，困惑，茫然，寂寞，孤独，郁闷，难过，悲观，沉重，麻木，精疲力尽，委靡不振，疲惫不堪，昏昏欲睡，无精打采，尴尬，惭愧，内疚妒忌，遗憾，不舒服</p></blockquote><p>不要总是你觉得，可以直接说出描述心情的形容词。</p><h3 id="chapter-5-感受的根源"><a href="#chapter-5-感受的根源" class="headerlink" title="chapter 5 - 感受的根源"></a>chapter 5 - 感受的根源</h3><blockquote><p>别人的行为可能会刺激我们，但并不是我们感受的根源。</p></blockquote><blockquote><p>非暴力沟通强调，感受的根源在于我们自身。我们的需要和期待，以及对他人言行的看法，导致了我们的感受。</p></blockquote><p>一般表达感受的形式是：他们做了XXX，我很XXX，因为我需要XXX。</p><blockquote><p>听到不中听的话时，我们可以有四种选择：1）责备自己；2）指责他人；3）体会自己的感受和需要；4）体会他人的感受和需要。</p></blockquote><blockquote><p>如果我们想利用他人的内疚，我们通常采取的办法是，把自己不快的感受归咎于对方。家长也许会和孩子说:“你成绩不好让爸爸妈妈伤透了心！”言下之意是，他们快乐或不快乐是孩子的行为造成的。看到父母的痛苦，孩子可能会感到内疚，并因此调整行为来迎合他们。遗憾的是，这种调整只是为了避免内疚，而非出自对学习的热爱。</p></blockquote><p>不要利用别人的内疚，把责任推到别人身上。因为，你只是得到了一时的妥协，而没有从根本上解决问题。</p><blockquote><p>批评往往暗含着期待。对别人的批评实际上间接表达了我们尚未满足的需要。</p></blockquote><p>之所以会将无法满足自己愿望的事归结给别人，是因为，自己有所期待，但是并未通过对他人的期待而被满足。比如国庆去看烟花，去了灯市口，而不是珠市口，没看到烟花的时候，内心是非常难过的，但是把这种难过归咎于给我们指路的人，刚开始不说清楚，我们都到了才说，因为只有这样的抱怨才能让我没有看到烟花这件事有一个解释。然而，可以表达的感受可以换成这样：我非常想看烟花，我去了他第一次给我们说的地点，我认为也可能会看到烟花，寻思着位置也差不多。</p><blockquote><p>如果我们不看重自己的需要，别人可能也不会。实际上，如果直接说出需要，获得积极回应的可能性就会增加。</p></blockquote><p>我累了，我想休息。而不是说自己今天干了什么什么一大堆没用的。</p><p>勇敢的表达自己的想法和需要，有时候就得牺牲别人的需要。</p><blockquote><p>为他人的情绪负责，牺牲自己迎合他人，代价实在很大。</p></blockquote><blockquote><p>对于大多数人来说，<strong>个人成长</strong>一般会经历三个阶段:（1）“情感的奴隶”—我们认为自己有义务使他人快乐；（2）“面目可憎”时期——此时，我们拒绝考虑他人的感受和需要；（3）“生活的主人”——我们意识到，虽然我们对自己的意愿、感受和行动负有完全的责任，但无法为他人负责。与此同时，我们还认识到，我们无法牺牲他人来满足自己的需要。</p></blockquote><blockquote><p>真诚待人比委屈求全更为可贵。如果别人感到不安，我们可以认真地倾听，但无须责备自己。</p></blockquote><h3 id="—随记—"><a href="#—随记—" class="headerlink" title="—随记—"></a>—随记—</h3><p>2019.10.8 - 今日学习速递 - 胡伟武老师的讲座摘录</p><p>我的感受：有的人视时间如金，而有的人却挥金如土。</p><blockquote><p>千里马的栅栏已经打开，不要眷恋原来的“草料”。</p><p>不以物喜，不以己悲；受辱不辩，闻谤不咎。</p><p>学而时习之，不亦乐乎。习是实践。</p><p>失败是成功之母，而学习是成功之父。</p><p>通过思考把握事物的简单性。</p><p>因戒生定，因定生惠。</p><p>成熟：当你取得成就不去说了，当受了委屈不去辩解。</p></blockquote><h3 id="chapter-6-请求帮助"><a href="#chapter-6-请求帮助" class="headerlink" title="chapter 6 - 请求帮助"></a>chapter 6 - 请求帮助</h3><p>今天看到的很多东西，都和自己息息相关，非常的受用，所以摘录了很多段，就不分开写了。</p><ul><li><p>不要总是提醒自己要避免出现什么，而是提醒自己主动做些什么。</p></li><li><p>我们提出的请求越具体越好。如果我们的意思含糊不清，别人就难以了解我们到底想要什么。此外，使用抽象的语言还会使我们无法深入了解自己。请求他人采取具体的行动将揭示我们的动机。</p></li><li><p>许多来向我求助的人后来发现，他们感到沮丧或灰心，很大程度上是因为他们不清楚自己对他人究竟有什么样的期待。</p></li><li><p>如果我们<strong>只是表达自己的感受</strong>，别人可能就不清楚我们想要什么。如果一个人<strong>提出了明确的请求，却没有提及感受和需要</strong>，也有能导致交流的困难。</p></li><li><p>就像那位乘火车去机场的先生，我们希望有人倾听并了解我们的处境。或者，我们期待的是如实的反馈—我们想了解他人的真实想法。当然，有时我们希望他人采取某种行动。对自己的认识越深刻，表达越清楚，我们就越可能得到称心的回应。</p></li><li><p>当对方给予反馈，表达我们的感激；如果对方不愿反馈，倾听他们的感受和需要。</p></li><li><p>了解他人的反应：</p><ul><li>对方此时此刻的感受</li><li>对方正在想什么</li><li>对方是否接受我们的请求</li></ul></li><li><p>参加集体讨论时，说清楚我们希望得到怎样的反馈，是至关重的。如果不清楚发言的目的，我们的讨论也许只是在浪费时间，而无满足任何人的需要。此外，如果不清楚发言者是否已经得到满意的答复，讨论就可能无目的地继续下去，而无法满足任何人的需要。</p><ul><li>“我不清楚你为什么要提到这篇文章。你是否可以告诉我们，你期待得到怎样的反馈呢？”这样的提醒也许就可以避免浪费宝贵的会议时间。</li></ul></li><li><p>如何区分命令和请求:请求没有得到满足时，提出请求的人如果批评和指责，那就是命令；如果想利用对方的内疚来达到目的，也是命令。</p></li><li><p>一旦人们认为我们是在强迫他们，他们就会不太想满足我们的愿望。</p></li><li><p>一旦人们相信我们看中彼此的感情，并能兼顾对方的需要，那么他们也就会相信我们所表达的愿望是请求而非命令。</p></li></ul><h3 id="chapter-7-用全身心倾听"><a href="#chapter-7-用全身心倾听" class="headerlink" title="chapter 7 - 用全身心倾听"></a>chapter 7 - 用全身心倾听</h3><p>今日份的依旧纯摘抄，让我想到了很多类似的场景。</p><p>比如舍友给我说：“我把我男朋友惹生气了，因为他有时候真的是太自信了”。我可能会急于表达自己的理解和关怀，回答：“没事的”，接着又觉得这样不行，又开始神补刀，“你下次不要这样说他啦，他也有自己的性格吧啦啦啦”。这样导致的后果就是舍友也不愿意和我继续分享她的感受了。学了这一章，我觉得这样说比较好：“你是有点讨厌他的自信？希望他能够多一点谦逊？”。  是这么个套路吗。。。问号.jpg。</p><ul><li>“尽管有种种相似之处，生活的每时每刻就像一个刚出生的婴儿，一张新的面孔，我们从未见过，也不可能再次见到。我们无法停留在过去，也无法预见我们的反应。我们需要不带成见地感受变化。我们需要用全身心去倾听。”</li><li>不要急着做什么，站在那里。</li><li>试图分析问题妨碍了我们与他人的联系。如果我们只关心别人说了什么，并考虑他的情况符合哪种理论，我们是在诊断人—我们并没有倾听他们。在非暴力沟通中，倾听他人意味着，放下已有的想法和判断，一心一意地体会他人。倾听的这种品质体现了它与理解以及同情之间的区别。</li><li>作家约瑟夫·坎伯（ Joseph Campbell）说道:“为了幸福，必须把‘别人怎么看我’这个问题放在一边。”一旦我们把所谓的批评和指责看作是来自他人的礼物—为处于痛苦中的人提供服务的机会，我们就会感到这种幸福。</li><li>联合国前秘书长汉马斯克德（ Dag Hammarskjold）曾经说道:“你越是留意自己内心的声音，就越能够听到别人的声音。”一旦我们能够敏锐地察觉并照顾自己的感受和需要，我们就有能力迅速调整好状态，来倾听他人如果做不到这一点，我们还有另外两种选择。<br>其中一种选择是大声地提出请求。不过，如果对方正处于激烈的情绪中，他也可能无法留意我们的感受和需要。这时，我们的另一种选择是，换一个环境。我们需要时间和间来调整状态，等平静下来了，再回来。</li></ul><h3 id="chapter-8-倾听的力量"><a href="#chapter-8-倾听的力量" class="headerlink" title="chapter 8 - 倾听的力量"></a>chapter 8 - 倾听的力量</h3><blockquote><p>非暴力沟通鼓励我们表达自己最深的感受和需要，因此，我们有时许会发现运用非暴力沟通是富有挑战性的。然而，通过倾听，我们将意识到他人的人性以及彼此的共通之处，这会使自我表达变得容易些。我们越是倾听他人语言背后的感受和需要，我们就越不怕与他们坦诚地沟通。我们最不愿意示弱的时候往往是因为担心失去控制想显得强硬的候。</p></blockquote><p>示弱有时候是一种人生智慧，尤其是我这样比较强势的女生。每个人都需要有台阶下，要有一种温和的心态和姿态去和别人交流，相处。</p><blockquote><p>绝望有时也许会给一个人带来灵感！<br>你和我们说，在一个生气的人面前，永远不要用‘不过’‘ “可是”，“但是”之类的词语。一开始，我很想为自己辩护，我想和他说，‘可是我们真的没房间’。幸好，在那时，我想起了那句话。我一直记得。</p></blockquote><p>说实话，从小和父母一起看那种刑侦片，或者谍战片，在电视屏幕里见识过太多人。有那种小偷，绑匪，毒贩子、毒枭等等，一直都很害怕电视中，绑架人质的事情发生在自己的身上。自己的长大，意味着电视上的画面，在自己身边，乃至自己身上发生的可能性都增加。在微博上会看到一些社会热点，有人突然拿着菜刀看向路人等等。对于这些恶意的事件，面对这些意外的伤害，我一直在思考，如果当事人是自己，该如何处理。看了这一章，我觉得，在一些极端情况下，我依然要相信人性的善，要倾听对方的感受和需要。有没有用我不知道，但我确定，如果鲁莽地挣扎，绝对没用。</p><blockquote><p>当别人说“不”的时候，我们常常会认为他们是在拒绝我们。有时，我们甚至还会觉得自己受到了伤害。然而如果我们能够体会他人的感受和需要，我们也许就会发现是什么使他们无法答应我们的请求。</p></blockquote><p>这让我想起了，我总是喜欢叫着别人和我一起做一些事，因为总觉得一个人有点孤单。但是我对于一起玩的人又很挑剔，所以我愿意叫着玩的也就那几个。有一次，我非常想请我的朋友和我一起去闲逛，但是当我一提出请求，她就拒绝了。当时我很生气，我觉得她已经和我关系不好了，她已经不再是以前那个时刻和我要好的朋友了。但是我什么也没说，她和我说，她早上6点下的火车，非常的劳累，一点也不想转悠了，只想在寝室休息。现在一想，是啊，她有自己的感受，我应该去理解她的感受，而不是因为她没有满足我的请求而迁怒于对方。还好，我没有做出伤害她的事。</p><blockquote><p>有的时候，谈话的气氛很沉闷。我们体会不到说话的人有怎样的感受和需要，也不知道他对我们有什么期待。这样的谈话是很累人的。它只是在浪费我们的时间，而无法帮助我们与他人加深联系。这种局面的出现往往是因为说话的人并不清楚自己的感受、需要和请求。怎么做才可以扭转这种局面，使谈话生动有趣呢？我的建议是，尽快提醒说话的人留意自己的感受和需要。等得越久，也就越难做到这一点。我们这样做并不是要以自我为中心，而是请求他人体会自身的状态。使谈话生动有趣的另一种方法是直接表达我们的愿望。</p></blockquote><p>少说废话，可能是现在的成年人必须要锻炼的一种素质。所以，为了向合格的成年人再迈向一步，要管住自己的嘴了。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具成长类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string-problems-easy</title>
      <link href="/2019/10/05/string-problems-easy/"/>
      <url>/2019/10/05/string-problems-easy/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h3 id="1108-Defanging-an-IP-Address"><a href="#1108-Defanging-an-IP-Address" class="headerlink" title="1108.Defanging an IP Address"></a>1108.Defanging an IP Address</h3><p><strong>题目描述：</strong></p><p>Given a valid (IPv4) IP <code>address</code>, return a defanged version of that IP address.</p><p>A <em>defanged IP address</em> replaces every period <code>&quot;.&quot;</code> with <code>&quot;[.]&quot;</code>.</p><p><strong>Example 1:</strong></p><pre><code>Input: address = &quot;1.1.1.1&quot;Output: &quot;1[.]1[.]1[.]1&quot;</code></pre><h4 id="solution1-遍历"><a href="#solution1-遍历" class="headerlink" title="solution1-遍历"></a>solution1-遍历</h4><ul><li>用一个新的串来记录结果，遍历原串，当遇到’.’时，结果串用”[.]”替代，否则用原串字符</li><li>时间：O(n),空间：O(n)</li><li>本来是想用string的库做，但是对于插入定位这件事就难倒我了。<ul><li>用iterator，用for循环去判断是否到结尾，但是只要插入元素，add.end()的iterator变了</li><li>用replace，也不行，insert 和 find 结合，编译总是显示 out of range，在codeblock上是没错的。</li></ul></li></ul><pre><code class="c++">class Solution {public:    string defangIPaddr(string address) {        string res = &quot;&quot;, str = &quot;[.]&quot;;        string::iterator it;        for(it = address.begin(); it != address.end(); it++){            if(*it == &#39;.&#39;)                res += str;            else                res += *it;        }        return res;    }};</code></pre><h3 id="709-To-Lower-Case"><a href="#709-To-Lower-Case" class="headerlink" title="709. To Lower Case"></a>709. To Lower Case</h3><p><strong>题目描述</strong>：</p><p>Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;Hello&quot;Output: &quot;hello&quot;</code></pre><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><ul><li>ascii码表：大写字母 ：65-90，小写字母：97-122</li></ul><pre><code class="C++">class Solution {public:    string toLowerCase(string str) {        int len = str.size();        for(int i = 0; i&lt; len; i++){            if(str[i] &lt;= 90 &amp;&amp; str[i] &gt;= 65)                str[i] += 32;        }        return str;    }};</code></pre><h3 id="804-Unique-Morse-Code-Words"><a href="#804-Unique-Morse-Code-Words" class="headerlink" title="804. Unique Morse Code Words"></a>804. Unique Morse Code Words</h3><p><strong>问题描述</strong></p><p>将字符串转换为摩尔斯电码表示，就是一种映射，返回的是结果中摩尔斯电码的不同的个数</p><p><strong>Example:</strong></p><pre><code>Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]Output: 2Explanation: The transformation of each word is:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;.</code></pre><h4 id="solution-集合set的使用"><a href="#solution-集合set的使用" class="headerlink" title="solution-集合set的使用"></a>solution-集合set的使用</h4><ul><li>看到那么长的映射，以为是考智力，找规律，直接放弃，看了别人的解法，不得不钦佩</li><li>每遍历一个单词，依次遍历其字符，并记录对应的国际摩尔斯电码，当一个单词遍历完，则拼接出单词对应的结果。把结果放入集合set中，因为unordered_set是无序的，比set快，且其中元素无重复。最后返回set集合的大小，就是不同的转换。</li><li>时间：O(n)，空间：O(2n)；n是单词个数</li></ul><pre><code class="C++">class Solution {public:    int uniqueMorseRepresentations(vector&lt;string&gt;&amp; words) {        vector&lt;string&gt;code{&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;};        unordered_set&lt;string&gt;ret;//一提到找不同，首当其冲的就是集合        for(string str : words){            string res = &quot;&quot;;            for(char c : str){                res += code[c - &#39;a&#39;];//这点很厉害，直接定位到数组中对应的元素            }            ret.insert(res);        }        return ret.size();    }};</code></pre><h3 id="657-Robot-Return-to-Origin"><a href="#657-Robot-Return-to-Origin" class="headerlink" title="657. Robot Return to Origin"></a>657. Robot Return to Origin</h3><p><strong>题目描述：</strong></p><p>Valid moves are R (right), L (left), U (up), and D (down). If the robot  returns to the origin after it finishes all of its moves, return true.  Otherwise, return false.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;UD&quot;Output: true Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.</code></pre><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><ul><li>想要返回true，需要左右移动，上下移动的次数一样多</li></ul><pre><code class="C++">class Solution {public:    bool judgeCircle(string moves) {        int l = 0, u = 0;        for(char c : moves){            switch(c){                case &#39;L&#39;:l++;break;                case &#39;R&#39;:l--;break;                case &#39;U&#39;:u++;break;                case &#39;D&#39;:u--;break;            }           }        return l == u &amp;&amp; l == 0;            }};</code></pre><h3 id="929-Unique-Email-Addresses"><a href="#929-Unique-Email-Addresses" class="headerlink" title="929. Unique Email Addresses"></a>929. Unique Email Addresses</h3><p><strong>题目描述</strong>：</p><p>For example, in <code>alice@leetcode.com</code>, <code>alice</code> is the local name, and <code>leetcode.com</code> is the domain name.</p><p>local name：如果有”.”，忽略，如果有”+”，第一个加号之后的都忽略，可用来过滤邮件（这两条规则对于domain name不适用）</p><p>返回能够收到邮件的不同地址个数。</p><p><strong>Example 1:</strong></p><pre><code>Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]Output: 2Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails</code></pre><h4 id="solution-遍历"><a href="#solution-遍历" class="headerlink" title="solution-遍历"></a>solution-遍历</h4><ul><li><p>将email地址分为local和doamin两部分处理，只有两部分都满足题目要求时，将处理的结果拼接成合法的地址，insert到set中，最后返回set中的地址个数。</p></li><li><p>时间：O(n)，n是email的个数；空间：O(n)</p></li><li><p>看别人比较快的代码，似乎domain部分不需要做判断</p></li></ul><pre><code class="C++">class Solution {public:    int numUniqueEmails(vector&lt;string&gt;&amp; emails) {        unordered_set&lt;string&gt;res; //用set存储唯一的地址        for(string email : emails){            int pos = email.find(&quot;@&quot;),len = email.size();            string ret1 = &quot;&quot;;            string local(email,0,pos);            string domain(email,pos+1,len-pos);            bool isLocal = checkLocal(local,ret1);            //bool isDomain = checkDomain(domain);// &amp;&amp; isDomain            if(isLocal){                //cout&lt;&lt;ret1+&quot;@&quot;+domain&lt;&lt;endl;                 res.insert(ret1+&quot;@&quot;+domain);            }                       }        return res.size();    }    bool checkLocal(string local, string &amp;ret1){        for(char c : local){            if(c == &#39;.&#39;)//点则跳过，                continue;            else if(c == &#39;+&#39;)//之后的都忽略                break;            else                ret1+=c;        }        return true;    }    //没看懂题目，domain里面原来可以有多个&#39;.&#39;    /*bool checkDomain(string domain){        for(char c : domain){            if((c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || c == &#39;.&#39;)//记得加等号！！！                continue;            else                return false;        }        return true;    }*/};</code></pre><h3 id="557-Reverse-Words-in-a-String-III"><a href="#557-Reverse-Words-in-a-String-III" class="headerlink" title="557. Reverse Words in a String III"></a>557. Reverse Words in a String III</h3><p><strong>题目描述</strong>：</p><p>Given a string, you need to reverse the order of characters in each  word within a sentence while still preserving whitespace and initial  word order.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;Let&#39;s take LeetCode contest&quot;Output: &quot;s&#39;teL ekat edoCteeL tsetnoc&quot;</code></pre><h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><pre><code class="C++">class Solution {public:    string reverseWords(string s) {        int len = s.size();        int beg = 0;        int pos = s.find(&quot; &quot;,0);//老年人的劝告，少用这种find空格的方式        while(pos != std::string::npos){            reverseWord(s,beg,pos-1);            beg = pos+1;            pos = s.find(&quot; &quot;,beg);        }        reverseWord(s,beg,len-1);        return s;    }    void reverseWord(string&amp; str,int beg, int en){        for(int i = beg,j = en; i &lt; j; i++,j--){            str[i] ^= str[j];            str[j] ^= str[i];            str[i] ^= str[j];        }    }};</code></pre><h3 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344. Reverse String"></a>344. Reverse String</h3><p>题目描述：</p><p>Write a function that reverses a string. The input string is given as an array of characters <code>char[]</code>.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>You may assume all the characters consist of <a href="https://en.wikipedia.org/wiki/ASCII#Printable_characters" target="_blank" rel="noopener">printable ascii characters</a>.</p><p><strong>Example 1:</strong></p><pre><code>Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></pre><h4 id="solution1-按异或操作符实现元素交换"><a href="#solution1-按异或操作符实现元素交换" class="headerlink" title="solution1-按异或操作符实现元素交换"></a>solution1-按异或操作符实现元素交换</h4><ul><li>看运行时间，似乎也不是很有效</li><li>时间O(n)，空间O(1)</li><li>swap：和1的做法差不多，但是时间会少一些</li></ul><pre><code class="C++">class Solution {public:    void reverseString(vector&lt;char&gt;&amp; s) {        char tmp;        int len = s.size();        for(int i = 0; i &lt; len/2; i++){            tmp = s.at(i) ;            s.at(i) = s.at(len - i - 1);            s.at(len - i - 1) = tmp;        }    }};</code></pre><h4 id="solution2-用string的库函数-reverse"><a href="#solution2-用string的库函数-reverse" class="headerlink" title="solution2-用string的库函数.reverse"></a>solution2-用string的库函数.reverse</h4><pre><code class="C++">class Solution {public:    void reverseString(vector&lt;char&gt;&amp; s) {        reverse(s.begin(),s.end());    }};</code></pre><h3 id="1170-Compare-Strings-by-Frequency-of-the-Smallest-Character"><a href="#1170-Compare-Strings-by-Frequency-of-the-Smallest-Character" class="headerlink" title="1170. Compare Strings by Frequency of the Smallest Character"></a>1170. Compare Strings by Frequency of the Smallest Character</h3><p><strong>题目描述</strong></p><p>Let’s define a function <code>f(s)</code> over a non-empty string <code>s</code>, which <strong>calculates the frequency of the smallest character</strong> in <code>s</code>. For example, if <code>s = &quot;dcce&quot;</code> then <code>f(s) = 2</code> because the smallest character is <code>&quot;c&quot;</code> and its frequency is 2.</p><p>Now, given string arrays <code>queries</code> and <code>words</code>, return an integer array <code>answer</code>, where each <code>answer[i]</code> is the number of words such that <code>f(queries[i])</code> &lt; <code>f(W)</code>, where <code>W</code> is a word in <code>words</code>.</p><p>answer的个数和queries的个数一样，值的范围是[0,w.size()];</p><p><strong>Example 2:</strong></p><pre><code>Input: queries = [&quot;bbb&quot;,&quot;cc&quot;], words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]Output: [1,2]Explanation: On the first query only f(&quot;bbb&quot;) &lt; f(&quot;aaaa&quot;). On the second query both f(&quot;aaa&quot;) and f(&quot;aaaa&quot;) are both &gt; f(&quot;cc&quot;).</code></pre><h4 id="solution-sort"><a href="#solution-sort" class="headerlink" title="solution-sort"></a>solution-sort</h4><ul><li>没有任何技术含量的，一步步按照人脑实现</li><li>先分别统计最小字符的个数，然后进行比较</li><li>时间：O(n^2)，n是字符的个数，空间：O(3n)，包括存储次数，以及结果的vector</li></ul><pre><code class="C++">class Solution {public:    //计算每个字符串内最小的字符出现的次数        int numbers(string query){            int num1 = 1;            char tmp = query[0];            for(int i = 1; i&lt; query.size();i++){                if(query[i] == tmp){                    num1++;                }else                    break;            }            return num1;    }    vector&lt;int&gt; numSmallerByFrequency(vector&lt;string&gt;&amp; queries, vector&lt;string&gt;&amp; words) {        vector&lt;int&gt; q,w;    //分别计算queries和words中字符串的最小字符个数        for(string query:queries){            sort(query.begin(),query.end());             int numq = numbers(query);            q.push_back(numq);        }        for(string word:words){            sort(word.begin(),word.end());                        int numw = numbers(word);             w.push_back(numw);        }        //统计结果        //sort(q.begin(),q.end());//输出时不能改变原来的顺序        sort(w.begin(),w.end());        vector&lt;int&gt;res;        int lenw = w.size();        for(int numq : q){            int ret = 0;            for(int i = 0; i &lt; lenw; i++){                if(numq &lt; w[i]){                    ret = lenw-i;                    break;                }                                }            res.push_back(ret);        }        return res;    }};</code></pre><h4 id="solution2-比较精巧，但是得仔细理解"><a href="#solution2-比较精巧，但是得仔细理解" class="headerlink" title="solution2-比较精巧，但是得仔细理解"></a>solution2-比较精巧，但是得仔细理解</h4><pre><code>class Solution {public:    //用hash表的形式获取字符串的最小字符出现频率，这样就不需要对原串进行排序了    int getF(string s){        int f[26] = {0,};        for(char c:s){            f[c-&#39;a&#39;]++;        }        for(int i: f){            if(i &gt; 0)                return i;        }        return 0;    }    vector&lt;int&gt; numSmallerByFrequency(vector&lt;string&gt;&amp; queries, vector&lt;string&gt;&amp; words) {        vector&lt;int&gt;fr(12,0);//用来统计words中，最小字符串的长度在1-10之间的个数        for(string word:words){            int f = getF(word);            fr[f]++;        }        //从后向前统计，大于当前个数的最小字符串是多少个        for(int i = 9; i &gt;=0; i--){            fr[i] += fr[i+1];        }        vector&lt;int&gt;res;        for(string query:queries){            int f = getF(query);            res.push_back(fr[f+1]);//fr必须是12，如果是11，当这里的f是10，那么访问fr[11]，需要的就是12个元素大小的空间        }        return res;    }};</code></pre><h3 id="824-Goat-Latin"><a href="#824-Goat-Latin" class="headerlink" title="824. Goat Latin"></a>824. Goat Latin</h3><p><strong>题目描述</strong></p><p>The rules of Goat Latin are as follows:</p><ul><li><p>If a word begins with a vowel (a, e, i, o, or u), append <code>&quot;ma&quot;</code> to the end of the word.</p><pre><code> For example, the word &#39;apple&#39; becomes &#39;applema&#39;.</code></pre></li><li><p>If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add <code>&quot;ma&quot;</code>.</p><pre><code> For example, the word `&quot;goat&quot;` becomes `&quot;oatgma&quot;`.</code></pre></li><li><p>Add one letter <code>&#39;a&#39;</code> to the end of each word per its word index in the sentence, starting with 1.</p><pre><code> For example, the first word gets `&quot;a&quot;` added to the end, the second word gets `&quot;aa&quot;` added to the end and so on.</code></pre></li></ul><p>Return the final sentence representing the conversion from <code>S</code> to Goat Latin. </p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;I speak Goat Latin&quot;Output: &quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot;</code></pre><h4 id="solution-string库函数使用，下标移动"><a href="#solution-string库函数使用，下标移动" class="headerlink" title="solution-string库函数使用，下标移动"></a>solution-string库函数使用，下标移动</h4><ul><li>主要思路：按照第一个字符是否为元音，分为两种处理方法<ul><li>是元音，直接在结尾添加ma</li><li>不是元音，将子串开头字符添加到结尾，删除开头字符，添加ma</li></ul></li><li>对于拼接好的单词，还需要根据这是第几个单词，在单词最后加入几个a，这个用cnt来记录当前处理的是第几个元素，生成cnt长度的新子串，添加在单词后即可。</li><li>时间：O(n)，n是单词的个数，空间：O(C)，C是a的个数</li></ul><pre><code class="C++">class Solution {public:    void convert(string&amp; S,int beg, int pos){        switch(S[beg]){                case &#39;a&#39;: case &#39;A&#39;:                case &#39;e&#39;: case &#39;E&#39;:                case &#39;i&#39;: case &#39;I&#39;:                case &#39;o&#39;: case &#39;O&#39;:                case &#39;u&#39;: case &#39;U&#39;:                    S.insert(pos,&quot;ma&quot;);                    break;                default:                    S.insert(pos,1,S[beg]);                    S.erase(beg,1);                    S.insert(pos,&quot;ma&quot;);                    break;                        }    }    string toGoatLatin(string S) {        int pos = S.find(&quot; &quot;,0);        int beg = 0;        int cnt = 0;        while(pos!=std::string::npos ){            cnt++;            convert(S,beg,pos);            pos = S.find(&quot; &quot;,pos);            string tmp(cnt,&#39;a&#39;);            S.insert(pos,tmp);            beg = pos+cnt+1;            pos = S.find(&quot; &quot;,beg);        }        cnt++;//处理最后一个元素        convert(S,beg,S.size());        int len = S.size();        string tmp(cnt,&#39;a&#39;);        S.insert(len,tmp);        return S;    }};</code></pre><h3 id="521-Longest-Uncommon-Subsequence-I"><a href="#521-Longest-Uncommon-Subsequence-I" class="headerlink" title="521. Longest Uncommon Subsequence I"></a>521. Longest Uncommon Subsequence I</h3><p><strong>题目描述</strong></p><p>Given a group of two strings, you need to find the longest uncommon  subsequence of this group of two strings.<br>The longest uncommon subsequence is defined as the longest subsequence  of one of these strings and this subsequence should not be <strong>any</strong> subsequence of the other strings.</p><p>A <strong>subsequence</strong> is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty<br>string is a subsequence of any string.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;aba&quot;, &quot;cdc&quot;Output: 3Explanation: The longest uncommon subsequence is &quot;aba&quot; (or &quot;cdc&quot;), because &quot;aba&quot; is a subsequence of &quot;aba&quot;, but not a subsequence of any other strings in the group of two strings. </code></pre><h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h4><ul><li>看solution，完全是脑筋急转弯</li><li>按道理，要把两个串的所有子序列求出来，对比看有没有子序列才对吧？但是这种情况是指，有公共子序列。对于没有的情况，就是长度最长的串本身。</li><li>时间：O(1)，空间：O(1)</li></ul><pre><code class="C++">class Solution {public:    int findLUSlength(string a, string b) {        if(a == b)            return -1;        int len1 = a.size(),len2 = b.size();        return len1&gt;=len2?len1:len2;            }};</code></pre><h3 id="917-Reverse-Only-Letters"><a href="#917-Reverse-Only-Letters" class="headerlink" title="917. Reverse Only Letters"></a>917. Reverse Only Letters</h3><p><strong>题目描述</strong></p><p>Given a string <code>S</code>, return the “reversed” string where all  characters that are not a letter stay in the same place, and all letters reverse their positions.</p><p><strong>Example 2:</strong></p><pre><code>Input: &quot;a-bC-dEf-ghIj&quot;Output: &quot;j-Ih-gfE-dCba&quot;</code></pre><h4 id="solution1-双指针遍历，交换"><a href="#solution1-双指针遍历，交换" class="headerlink" title="solution1-双指针遍历，交换"></a>solution1-双指针遍历，交换</h4><ul><li>最左，最右双指针遍历<ul><li>遇到非字母的，则跳过</li><li>只有当两个都是字母时交换；</li></ul></li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution {public:    string reverseOnlyLetters(string S) {        int len = S.size();        int left = 0, right = len-1;        while(left &lt; right){            char l = S[left] ,r = S[right];            if(isLetter(l)  &amp;&amp; isLetter(r)){                char tmp = S[left];                S[left] = S[right];                S[right] = tmp;                left++;                right--;            }else if(!isLetter(l) &amp;&amp; !isLetter(r)){                left++;                right--;            }else if(!isLetter(l))                left++;            else                right--;        }        return S;    }    bool isLetter(char s){        if((s &gt;= &#39;a&#39; &amp;&amp; s &lt;= &#39;z&#39;) || (s &gt;=&#39;A&#39; &amp;&amp; s &lt;= &#39;Z&#39;) )            return true;        else             return false;    }};</code></pre><h4 id="solution2-stack"><a href="#solution2-stack" class="headerlink" title="solution2-stack"></a>solution2-stack</h4><ul><li>看解答，发现还是很有意思的一个思路，因为需要逆序字符串，因此可以用栈，这道题目就是将字符串逆序输出，其他字符保持在原位置不变。</li><li>时间：O(2n),需要扫描两边原字符串，空间：O(n)，额外的stack及返回字符串</li></ul><pre><code class="C++">class Solution {public:    bool isLetter(char s){        if((s &gt;= &#39;a&#39; &amp;&amp; s &lt;= &#39;z&#39;) || (s &gt;=&#39;A&#39; &amp;&amp; s &lt;= &#39;Z&#39;) )            return true;        else             return false;    }    string reverseOnlyLetters(string S) {        stack&lt;char&gt; tmp;        for(char c:S){            if(isLetter(c))                tmp.push(c);        }        string res;        for(char c:S){            if(isLetter(c)){                res.append(1,tmp.top());                tmp.pop();            }else                res.append(1,c);              }        return res;    }};</code></pre><h3 id="788-Rotated-Digits"><a href="#788-Rotated-Digits" class="headerlink" title="788. Rotated Digits"></a>788. Rotated Digits</h3><p><strong>题目描述</strong></p><p>A number is valid if each digit remains a digit after rotation. 0, 1,  and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9  rotate to each other, and the rest of the numbers do not rotate to any  other number and become invalid.</p><p>Now given a positive number <code>N</code>, how many numbers X from <code>1</code> to <code>N</code> are good?</p><p><strong>Example</strong>:</p><pre><code>Input: 10Output: 4Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.</code></pre><h4 id="solution-dp记录表"><a href="#solution-dp记录表" class="headerlink" title="solution-dp记录表"></a>solution-dp记录表</h4><ul><li>本以为代码越敲，就会渐入佳境，结果却是：连题目都读不懂了呜呜呜</li><li>这道题乍得一看有点难，看了别人的解法才知道题目想表达的意思。</li><li>越来越大的数字都是由小数字组成的，那么通过读小数字是否为good num就可以判断大数是否为good</li><li>当数字为good时，必须包含2||5||6||9，同时可以包含0，1，8</li><li>只包含0，1，8 时只能说是valid的，不能是good的</li><li>当数字包含 3，4，7时，一定是invalid的</li><li>时间：O(n)，n是数字的个数，空间，O(n)</li></ul><pre><code class="C++">class Solution {public:    int rotatedDigits(int N) {        int dp[N+1] = {0,} ;        int cnt = 0;        for(int i = 0; i &lt;= N;i++){        if(i &lt; 10){            if(i == 0 || i == 1 || i == 8)                dp[i] = 1;            else if(i == 2 || i == 5 || i == 6 || i == 9){                       dp[i] = 2;                 cnt++;            }        }else{            int a = dp[i/10], b = dp[i%10];            if(a == 1 &amp;&amp; b == 1)                dp[i] = 1;            else if(a &gt;= 1 &amp;&amp; b &gt;= 1){                dp[i] = 2;//说明这个数的组成是2，5，6，9，0，1，8                cnt++;                               }                  }        }        return cnt;    }};</code></pre><h3 id="696-Count-Binary-Substrings"><a href="#696-Count-Binary-Substrings" class="headerlink" title="696. Count Binary Substrings"></a>696. Count Binary Substrings</h3><p><strong>题目描述</strong></p><p>Give a string <code>s</code>, count the number of non-empty  (contiguous) substrings that have the same number of 0’s and 1’s, and  all the 0’s and all the 1’s in these substrings are grouped  consecutively.  </p><p>Substrings that occur multiple times are counted the number of times they occur.</p><p><strong>Example 2:</strong></p><pre><code>Input: &quot;10101&quot;Output: 4Explanation: There are 4 substrings: &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;01&quot; that have equal number of consecutive 1&#39;s and 0&#39;s.</code></pre><h4 id="solution-线性扫描"><a href="#solution-线性扫描" class="headerlink" title="solution-线性扫描"></a>solution-线性扫描</h4><ul><li>遇到相同的就加，遇到不同的就开始统计，看这种连续性是几个</li><li>相当于把1和0分成group</li><li>时间：O(n),空间：O(1)</li></ul><pre><code class="C++">class Solution {public:    int countBinarySubstrings(string s) {        int len = s.size();        int pre = 0,cur = 1, sum = 0;//pre是上一个group中相同元素的个数，cur是当前的，这就是相当于对0和1分组        for(int i = 1; i &lt; len; i++){            if(s[i] == s[i-1]){                cur++;            }else{                sum += min(cur,pre);                pre = cur;                cur = 1;            }                    }        sum += min(cur,pre);        return sum;    }};</code></pre><h3 id="937-Reorder-Data-in-Log-Files"><a href="#937-Reorder-Data-in-Log-Files" class="headerlink" title="937. Reorder Data in Log Files"></a>937. Reorder Data in Log Files</h3><p><strong>题目描述</strong></p><p>Reorder the logs so that all of the letter-logs come before any  digit-log.  The letter-logs are ordered lexicographically ignoring  identifier, with the identifier used in case of ties.  The digit-logs  should be put in their original order.</p><p>Return the final order of the logs.</p><p><strong>Example 1:</strong></p><pre><code>Input: logs = [&quot;dig1 8 1 5 1&quot;,&quot;let1 art can&quot;,&quot;dig2 3 6&quot;,&quot;let2 own kit dig&quot;,&quot;let3 art zero&quot;]Output: [&quot;let1 art can&quot;,&quot;let3 art zero&quot;,&quot;let2 own kit dig&quot;,&quot;dig1 8 1 5 1&quot;,&quot;dig2 3 6&quot;]</code></pre><h4 id="solution-stable-sort"><a href="#solution-stable-sort" class="headerlink" title="solution-stable_sort"></a>solution-stable_sort</h4><ul><li>通过对标识符后的第一个字符进行比较，得出是isalpha or isdigit</li><li>isalpha,则进入结果vector，否则，进入临时vector<ul><li>这样分开装的原因是，两者的排序要求不同，对于前者，则需要对标识符之外的串进行比较，而对于后者，则简单的排在前者后面就可以。</li></ul></li><li>比较花时间的地方就是：如何对vector中的字符串，去掉某部分后进行大小比较，用comparator，要注意的是：cmp函数写在类内需要用static关键字修饰，类外则可以不用。</li><li>时间：O(n)，n是字符串的个数，空间：O(n)，两部分用于存储字符串的vector</li></ul><pre><code>bool cmp(string str1, string str2){        int pos1 = str1.find(&#39; &#39;);        int pos2 = str2.find(&#39; &#39;);        string sa = str1.substr(pos1+1);        string sb = str2.substr(pos2+1);        if(sa.compare(sb) == 0)//如果除了标识符之外的地方相等，那么就要对标识符也做判断进行排序了            return str1 &lt; str2;        else            return sa &lt; sb;    }class Solution {public:    //很迷，就一个static搞了我半个小时,如果放在类内作为比较函数，则必须要加static    /*    static bool cmp(string str1, string str2){        int pos1 = str1.find(&#39; &#39;);        int pos2 = str2.find(&#39; &#39;);        return str1.substr(pos1+1) &lt; str2.substr(pos2+1);    }    */    vector&lt;string&gt; reorderLogFiles(vector&lt;string&gt;&amp; logs) {        vector&lt;string&gt;res;        vector&lt;string&gt;tmp;        for(string str:logs){            int pos = str.find(&#39; &#39;);//find还可以用来查找某个完整的单词呢·就是string了            if(isdigit(str[pos+1]))                tmp.push_back(str);            else                res.push_back(str);        }        stable_sort(res.begin(),res.end(),cmp);//不仅要比较，对于后面都相等的，还需要保持原来的顺序         for(string s:tmp){            res.push_back(s);        }        return res;    }};</code></pre><h3 id="1071-Greatest-Common-Divisor-of-Strings"><a href="#1071-Greatest-Common-Divisor-of-Strings" class="headerlink" title="1071. Greatest Common Divisor of Strings"></a>1071. Greatest Common Divisor of Strings</h3><p>For strings <code>S</code> and <code>T</code>, we say “<code>T</code> divides <code>S</code>“ if and only if <code>S = T + ... + T</code>  (<code>T</code> concatenated with itself 1 or more times)</p><p>Return the largest string <code>X</code> such that <code>X</code> divides str1 and <code>X</code> divides str2.</p><h4 id="solution-gcd"><a href="#solution-gcd" class="headerlink" title="solution-gcd"></a>solution-gcd</h4><ul><li>就是两个整数的最大公约数的变形，还做了一个多小时。。。。蠢啊</li><li>自己写的代码也一眼难尽，丑陋！</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution {public:    string gcdOfStrings(string str1, string str2) {        //使得较长串始终为第一个串,这tm都能写错，这谁顶得住？？        if(str1.size() &lt; str2.size()){            string tmp = str2;            str2 = str1;            str1 = tmp;        }        int len2 = str2.size();        //==0，表示两个字符串相等        //&gt;0，表示被比较字符串小        if(str1.compare(0,len2,str2) != 0)            return &quot;&quot;;        if(str2.empty())            return str1;        return gcdOfStrings(str2,str1.substr(len2));    }};</code></pre><h4 id="solution-gcd-1"><a href="#solution-gcd-1" class="headerlink" title="solution-gcd"></a>solution-gcd</h4><ul><li>别人的解释，对于两个串，S1 = nT，S2 = mT，n&gt;m，S3 = (n-m)T = xT; S1 = xT, S2 = mT,…,直到S2为空，返回S1，因为S1始终是长一点的那个。</li></ul><pre><code class="C++">class Solution {public:    string gcdOfStrings(string str1, string str2) {        int len2 = str2.size();        if(str1.size() &lt; len2)            return gcdOfStrings(str2,str1);        if(str2.empty())            return str1;        if(str1.compare(0,len2,str2) != 0)            return &quot;&quot;;        return gcdOfStrings(str1.substr(len2),str2);//str2始终是短的那个，所以一直在后面    }};</code></pre><h3 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. Roman to Integer</h3><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p><pre><code>Symbol       ValueI             1V             5X             10L             50C             100D             500M             1000</code></pre><p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><p><strong>Example 5:</strong></p><pre><code>Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</code></pre><ul><li>总的来说，解题思路是，结果是每一位的和，但是存在加完了前面的需要减去的情况，比如IV，对于这种特例，两种解决方案。</li></ul><h3 id="solution1-hash-map"><a href="#solution1-hash-map" class="headerlink" title="solution1-hash_map"></a>solution1-hash_map</h3><ul><li>从后向前遍历，如果s[i] &lt; s[i+1]，那么需要减去s[i]，否则加上就行。</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution {public:    int romanToInt(string s){        unordered_map&lt;char,int&gt; M = {{'I',1},                                     {'V',5},                                     {'X',10},                                     {'L',50},                                     {'C',100},                                     {'D',500},                                     {'M',1000}};        int sum = M[s.back()];        for(int i = s.size() - 2; i &gt;= 0; i--){            if(M[s[i]] &lt; M[s[i+1]])                sum -= M[s[i]];            else                 sum += M[s[i]];        }        return sum;    }};</code></pre><h3 id="solution2"><a href="#solution2" class="headerlink" title="solution2-"></a>solution2-</h3><ul><li>先搜索字符串内有没有这类组合，有的话分别减去2，20，200，接着从前向后遍历，依次相加即可；因为加的过程中会多加</li><li>时间：O(n)，空间：O(2n)</li></ul><pre><code class="C++">class Solution {public:    int romanToInt(string s) {        int sum = 0;        if(s.find(&quot;IV&quot;,0) != string::npos) sum-=2;//原本是加4，但是后面遍历加的时候是先加了1，又加了5，就是多加了2        if(s.find(&quot;IX&quot;,0) != string::npos) sum-=2;        if(s.find(&quot;XL&quot;,0) != string::npos) sum-=20;        if(s.find(&quot;XC&quot;,0) != string::npos) sum-=20;        if(s.find(&quot;CD&quot;,0) != string::npos) sum-=200;        if(s.find(&quot;CM&quot;,0) != string::npos) sum-=200;        for(char c: s){            switch(c){                case &#39;I&#39;:sum+=1;break;                case &#39;V&#39;:sum+=5;break;                case &#39;X&#39;:sum+=10;break;                case &#39;L&#39;:sum+=50;break;                case &#39;C&#39;:sum+=100;break;                case &#39;D&#39;:sum+=500;break;                case &#39;M&#39;:sum+=1000;break;                                }        }        return sum;    }};</code></pre><h3 id="520-Detect-Capital"><a href="#520-Detect-Capital" class="headerlink" title="520. Detect Capital"></a>520. Detect Capital</h3><p><strong>题目描述</strong></p><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p><p>We define the usage of capitals in a word to be right when one of the following cases holds:</p><ol><li><p>All letters in this word are capitals, like “USA”.</p></li><li><p>All letters in this word are not capitals, like “leetcode”.</p></li><li><p>Only the first letter in this word is capital, like “Google”.</p><p>Otherwise, we define that this word doesn’t use capitals in a right way.  </p></li></ol><h4 id="solution-4"><a href="#solution-4" class="headerlink" title="solution"></a>solution</h4><ul><li>字符串的前两位决定了接下来的字符串需要是大写还是小写才能合法，如果是大写，那么转入判断大写的函数，一旦发现小写就返回false，反之亦然。</li><li>注意要判断 word 只有一个字符的特例</li><li>时间：O(n)，空间：(1)</li></ul><pre><code class="C++">class Solution {public:    bool detectCapitalUse(string word) {        if(word.size() == 1)            return true;        if(word[0] &gt;= &#39;A&#39; &amp;&amp; word[0] &lt;= &#39;Z&#39;){            if(word[1] &gt;= &#39;A&#39; &amp;&amp; word[1] &lt;= &#39;Z&#39;)                return isUpper(word.substr(2));            else                 return isLower(word.substr(2));        }        else             return isLower(word.substr(1));            }    bool isUpper(string str){        for(char c:str){            if(c &lt; &#39;A&#39; || c &gt; &#39;Z&#39;)                return false;        }        return true;    }    bool isLower(string str){        for(char c:str){            if(c &lt; &#39;a&#39; || c &gt; &#39;z&#39;)                return false;        }        return true;    }};</code></pre><h3 id="606-Construct-String-from-Binary-Tree"><a href="#606-Construct-String-from-Binary-Tree" class="headerlink" title="606. Construct String from Binary Tree"></a>606. Construct String from Binary Tree</h3><p>You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.</p><p><strong>Example 2:</strong></p><pre><code>Input: Binary tree: [1,2,3,null,4]       1     /   \    2     3     \        4 Output: &quot;1(2()(4))(3)&quot;</code></pre><ul><li>需要注意的是，对于字符串使用“+”,则连续拼接的不能是两个常字符串，需要把整数转换为字符串<ul><li>在整数后面+””强制类型转换为字符串</li><li>to_string(整数)</li><li>ostringstre</li><li>sprintf等</li></ul></li></ul><h4 id="solution1-递归，先序遍历"><a href="#solution1-递归，先序遍历" class="headerlink" title="solution1-递归，先序遍历"></a>solution1-递归，先序遍历</h4><ul><li>每到一个节点，只考虑以这个节点为根的子树</li><li>三种情况<ul><li>左右孩子都没有，则返回当前值即可</li><li>有左孩子，但是没有右孩子，给左孩子加上括号，遍历左孩子即可</li><li>有左右孩子，给左孩子及右孩子加括号，分别遍历</li></ul></li><li>值得注意的是，没有单独考虑有右孩子，没左孩子的情况，这是因为，左孩子不管有没有，都不需要特殊处理，是需要加括号的，而右孩子没有的情况下，是没有括号的。</li></ul><pre><code class="C++">class Solution {public:    string tree2str(TreeNode* t) {        if(t == NULL)            return &quot;&quot;;        string str = to_string(t-&gt;val);//拼接的时候一直有问题，必须转成字符串？？？？？fuck，我的一个小时。。。        if((t-&gt;left) == NULL &amp;&amp; (t-&gt;right) == NULL)            return  str;         if((t-&gt;right) == NULL)            return str + &quot;(&quot; + tree2str(t-&gt;left) + &quot;)&quot;;        return str + &quot;(&quot; + tree2str(t-&gt;left) + &quot;)(&quot; + tree2str(t-&gt;right) + &quot;)&quot;;    }};</code></pre><h4 id="solution2-stack-1"><a href="#solution2-stack-1" class="headerlink" title="solution2-stack"></a>solution2-stack</h4><ul><li>先序遍历，顺序为根，左，右</li><li>对每一个未访问的当前节点，设置为已访问，res+=”(“ + to_string(val)</li><li>对当前节点的左右孩子进行判断，还是三种情况：<ul><li>如果是有右孩子但是没左孩子，那么结果中直接加上”()”，不需要将元素入栈</li><li>如果有右孩子，右孩子入栈</li><li>如果有左孩子，左孩子入栈，这样的先后顺序使得左孩子可以先被访问</li></ul></li><li>每一步只处理一个节点，当前栈顶节点，被访问过则弹出，没被访问过则访问</li><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="C++">class Solution {public:    string tree2str(TreeNode* t) {        if(t == NULL)            return &quot;&quot;;        stack&lt;TreeNode*&gt; s;        set&lt;TreeNode*&gt; visited;        string res = &quot;&quot;;        s.push(t);        while(!s.empty()){            t = s.top();            if(visited.find(t) != visited.end()){                s.pop();                res+= &quot;)&quot;;                //cout&lt;&lt;res&lt;&lt;endl;            }else{                visited.insert(t);                res+=&quot;(&quot; + to_string(t-&gt;val);                if(t-&gt;left == NULL &amp;&amp; t-&gt;right != NULL)                    res+=&quot;()&quot;;                if(t-&gt;right != NULL)//先push右边，再push左边，这样就可以先访问左边，后右边                    s.push(t-&gt;right);                if(t-&gt;left != NULL)                    s.push(t-&gt;left);            }        }        return res.substr(1,res.size()-2);//为了通用性，给第一个元素也是加了左右括号，最后要去掉    }};</code></pre><h3 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383. Ransom Note"></a>383. Ransom Note</h3><p><strong>题目描述</strong></p><p>ransom note 可以被magazine 构造，就是看 magazine中拥有的字符，是否足够形成ransome note，不用管字母顺序</p><p><strong>example</strong></p><pre><code>canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</code></pre><h4 id="solution1-库函数调用"><a href="#solution1-库函数调用" class="headerlink" title="solution1-库函数调用"></a>solution1-库函数调用</h4><ul><li>有点类似原串中找子序列的感觉，依次比较就完事了，结果却是理解错题目了。。</li><li>不用管字母出现的次序</li><li>时间：O(n)，空间：O(1)，效率非常低</li></ul><pre><code class="C++">class Solution {public:    bool canConstruct(string ransomNote, string magazine) {           for(char c : ransomNote){            int pos = magazine.find(c);            if(pos != string::npos)                magazine.erase(pos,1);            else                return false;        }        return true;    }};</code></pre><h4 id="solution2-map-数组"><a href="#solution2-map-数组" class="headerlink" title="solution2-map\数组"></a>solution2-map\数组</h4><ul><li>对原串中有的字符进行映射，依次累加对应字符的次数</li><li>对匹配串中的字符进行映射，一旦字符对应次数小于=0，则说明没法匹配了，返回false</li></ul><pre><code class="C++">/*class Solution {public:    bool canConstruct(string ransomNote, string magazine) {        unordered_map&lt;char,int&gt; maga(26);        for(char c: magazine){            maga[c]++;        }        for(char c : ransomNote){            if(maga[c] &lt;= 0 )                return false;            maga[c]--;        }        return true;    }};*/class Solution {public:    bool canConstruct(string ransomNote, string magazine) {        int maga[26] = {0,};        for(char c: magazine){            maga[c-&#39;a&#39;]++;        }        for(char c : ransomNote){            if(maga[c-&#39;a&#39;] &lt;= 0 )                return false;            maga[c-&#39;a&#39;]--;        }        return true;    }};</code></pre><h3 id="387-First-Unique-Character-in-a-String"><a href="#387-First-Unique-Character-in-a-String" class="headerlink" title="387. First Unique Character in a String"></a>387. First Unique Character in a String</h3><p><strong>题目描述</strong></p><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p><p><strong>example</strong></p><pre><code>s = &quot;loveleetcode&quot;,return 2.</code></pre><h4 id="solution-map"><a href="#solution-map" class="headerlink" title="solution-map"></a>solution-map</h4><ul><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="C++">class Solution {public:    int firstUniqChar(string s) {        int len = s.size();        int cnt[26] = {0,};        for(char c:s)            cnt[c-&#39;a&#39;]++;        //因为要找出第一个单独出现的字符，那么遍历原串就可以是原来的顺序啊 ~~~你怎么这么笨，map仅仅作为一个查询的东西        for(int i = 0 ; i &lt; len; i++){            if(cnt[s[i]-&#39;a&#39;] == 1)                return i;        }        return -1;    }};</code></pre><h3 id="541-Reverse-String-II"><a href="#541-Reverse-String-II" class="headerlink" title="541. Reverse String II"></a>541. Reverse String II</h3><p><strong>题目描述</strong></p><p>Given a string and an integer k, you need to reverse the first k  characters for every 2k characters counting from the start of the string. </p><p>If there are less than k characters left, reverse all of them. </p><p>If there are less than 2k but greater than or equal to k characters,  then reverse the first k characters and left the other as original.</p><p><strong>Example:</strong></p><pre><code>Input: s = &quot;abcdefg&quot;, k = 2Output: &quot;bacdfeg&quot;</code></pre><h4 id="solution-5"><a href="#solution-5" class="headerlink" title="solution"></a>solution</h4><ul><li>将字符串按照2K分组（可能有余数，可能没有），对每个组内的前k个做逆转</li><li>对于最后一个不足2k的，单独处理<ul><li>有k个，逆转</li><li>不够k个，全逆转！！！仔细读题目谢谢！</li></ul></li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution {public:    string reverseStr(string s, int k) {        int len = s.size();        if(len &lt; k){            reverse(s,0,len-1);//对于结束的点要注意            return s;        }        //这种情况很容易忽略,都是不看题目的锅        if(len &lt; 2*k){            reverse(s,0,k-1);        }        //len至少是大于2k的        int cnt = len/(2*k);        int start = 0;        for(int i = 0; i &lt; cnt; i++){            start = 2*i*k;            reverse(s,start,start+k-1);        }        start += 2*k;        if(len - start &gt;= k)            reverse(s,start,start+k-1);        if(len - start &lt; k)            reverse(s,start,len -1);        return s;    }    void reverse(string&amp; s, int start, int en){        for(int i = start, j = en; i &lt; j; i++,j--){            s[i] ^= s[j];            s[j] ^= s[i];            s[i] ^= s[j];        }    }};</code></pre><h4 id="solution2-1"><a href="#solution2-1" class="headerlink" title="solution2"></a>solution2</h4><pre><code class="C++">class Solution {public:    string reverseStr(string s, int k) {        int start = 0;        int len = s.size();        while(start &lt; len){            if(start + k &lt; len)                reverse(s.begin()+start, s.begin()+start+k );            else                reverse(s.begin()+start,s.end());            start += k + k;         }        return s;    }};</code></pre><h3 id="345-Reverse-Vowels-of-a-String"><a href="#345-Reverse-Vowels-of-a-String" class="headerlink" title="345. Reverse Vowels of a String"></a>345. Reverse Vowels of a String</h3><p><strong>Example 1:</strong></p><pre><code>Input: &quot;hello&quot;Output: &quot;holle&quot;</code></pre><h4 id="solution-双指针"><a href="#solution-双指针" class="headerlink" title="solution- 双指针"></a>solution- 双指针</h4><ul><li>分别向前，向后扫描，交换元音字母</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution {public:    bool isVowel(char c){        if(c == &#39;a&#39; || c == &#39;A&#39;|| c == &#39;e&#39;|| c == &#39;E&#39;|| c == &#39;i&#39;|| c == &#39;I&#39;|| c == &#39;o&#39;|| c == &#39;O&#39; || c == &#39;u&#39; || c == &#39;U&#39;)            return true;        else            return false;    }    string reverseVowels(string s) {        int len = s.size();        int i = 0, j = len-1;        while(i &lt; j){            while(i &lt; j &amp;&amp; !isVowel(s[i])){                    i++;            }             while(i &lt; j &amp;&amp; !isVowel(s[j])){                                  j--;            }            if(i &lt; j){                cout&lt;&lt;s[i]&lt;&lt;&quot;:&quot;&lt;&lt;s[j]&lt;&lt;endl;                char tmp = s[i];                s[i] = s[j];                s[j] = tmp;                            }            i++;            j--;                }        return s;    }  };</code></pre><h3 id="551-Student-Attendance-Record-I"><a href="#551-Student-Attendance-Record-I" class="headerlink" title="551. Student Attendance Record I"></a>551. Student Attendance Record I</h3><p><strong>题目描述</strong></p><p>You are given a string representing an attendance record for a student. The record only contains the following three characters:  </p><ol><li><p><strong>‘A’</strong> : Absent. </p></li><li><p><strong>‘L’</strong> : Late.</p></li><li><p><strong>‘P’</strong> : Present. </p><p>A student could be rewarded if his attendance record doesn’t contain <strong>more than one ‘A’ (absent)</strong> or <strong>more than two continuous ‘L’ (late)</strong>.    </p></li></ol><h4 id="solution-统计"><a href="#solution-统计" class="headerlink" title="solution-统计"></a>solution-统计</h4><ul><li>时间：O(n)，空间：O(1)</li><li>题目得仔细看，一不小心就写错了</li></ul><pre><code class="C++">class Solution {public:    bool checkRecord(string s) {        int len = s.size();        int cntA = 0;        for(int i = 0; i &lt; len; i++){            if(s[i] == &#39;A&#39;)                cntA++;        }        if(cntA &gt; 1 || s.find(&quot;LLL&quot;) != string::npos)            return false;        else            return true;        }};</code></pre><h4 id="solution2-if-else"><a href="#solution2-if-else" class="headerlink" title="solution2-if-else"></a>solution2-if-else</h4><ul><li>别人写的，还没有理解其妙处</li></ul><pre><code class="C++">class Solution {public:    bool checkRecord(string s) {        int l = 0, a = 0;        for(char c:s){            if(c == &#39;A&#39;)                a++;            if(c == &#39;L&#39;)//为啥这里不可以用if else？c不是只能等于一个数？我知道了，对于连续的L，会一直计数，然后下面的if会判断是否已经到了不合格的时候，一旦不连续，则直接被置0，从头开始                l++;            else                l = 0;            if(a &gt; 1 || l &gt; 2)                return false;        }        return true;    }};</code></pre><h3 id="415-Add-Strings"><a href="#415-Add-Strings" class="headerlink" title="415. Add Strings"></a>415. Add Strings</h3><p><strong>题目描述</strong></p><p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as string, return the sum of <code>num1</code> and <code>num2</code></p><h4 id="solution-6"><a href="#solution-6" class="headerlink" title="solution"></a>solution</h4><ul><li>就是小学生加法，一步步加，比如 A+B，需要考虑A长度，B长度，以及进位</li><li>这么简单的题，也能耗个几天才做完，自己写的代码里有一半都有点冗余，所以直接放参考别人写的了</li><li>每次只需要考虑当前位的A[i],B[j],carry</li><li>时间：O(n)，空间：O(n)，n表示相加的数最长长度</li></ul><pre><code class="C++">class Solution {public:    string addStrings(string num1, string num2) {        string res = &quot;&quot;;            int sum = 0;        int i = num1.size()-1, j = num2.size()-1,carry = 0;        while(i &gt;= 0 || j &gt;= 0 || carry == 1){            int x = i&lt;0?0:num1[i]-&#39;0&#39;;            int y = j&lt;0?0:num2[j]-&#39;0&#39;;            sum = x+y+carry;            carry = sum/10;            res+=to_string(sum%10);            i--;            j--;        }        reverse(res.begin(),res.end());        return res;    }};</code></pre><h3 id="67-Add-Binary"><a href="#67-Add-Binary" class="headerlink" title="67. Add Binary"></a>67. Add Binary</h3><p><strong>题目描述</strong></p><p>Given two binary strings, return their sum (also a binary string).</p><p><strong>Example 2:</strong></p><pre><code>Input: a = &quot;1010&quot;, b = &quot;1011&quot;Output: &quot;10101&quot;</code></pre><h4 id="solution-类似string的加法"><a href="#solution-类似string的加法" class="headerlink" title="solution-类似string的加法"></a>solution-类似string的加法</h4><ul><li>需要考虑的就是a[i]，b[j]，carry</li></ul><pre><code class="C++">class Solution {public:    string addBinary(string a, string b) {        int i = a.size()-1,j = b.size()-1;        int carry = 0;        string res = &quot;&quot;;        while(i &gt;= 0 || j &gt;= 0 || carry == 1 ){            int sum = carry;            if(i &gt;= 0){                sum += a[i]-&#39;0&#39;;                i--;            }            if(j &gt;=0 ){                sum += b[j]-&#39;0&#39;;                j--;            }            res += to_string(sum%2);            carry = sum/2;         }        reverse(res.begin(),res.end());        return res;           }};</code></pre><h3 id="925-Long-Pressed-Name"><a href="#925-Long-Pressed-Name" class="headerlink" title="925. Long Pressed Name"></a>925. Long Pressed Name</h3><p><strong>题目描述</strong></p><p>name是真名字，typed是不小心有多打的，typed是不是真的多打的</p><h4 id="solution-7"><a href="#solution-7" class="headerlink" title="solution"></a>solution</h4><ul><li>因为typed中有长重复输入，那么如果它是name的长输入，长度一定是大于等于name的，如果两者是相等的，直接返回成功。</li><li>遍历typed，将typed中的连续相同字符用cnt表示为一个group</li><li>遍历name，依次探测typed中 group 的元素个数以及元素本身是否匹配</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution {public:    bool isLongPressedName(string name, string typed) {        if(name == typed)            return true;        int len1= name.size(),len2 = typed.size();        if(len1 &gt; len2)            return false;        int i = 0, j = 0;        while(i &lt; len1 &amp;&amp; j &lt; len2){            if(name[i] != typed[j])                return false;            i++;            j++;            int cnt = 0;            int typeTmp = typed[j-1],nameTmp = name[i-1];            while((typed[j] == typeTmp ) &amp;&amp; (j &lt; len2)){                cnt++;                j++;            }            while((name[i] == nameTmp) &amp;&amp; (i &lt; len1)){                if(cnt &gt; 0){                    cnt--;                    i++;                }else                    return false;            }        }        return i == len1 &amp;&amp; j == len2;    }};</code></pre><h3 id="819-Most-Common-Word"><a href="#819-Most-Common-Word" class="headerlink" title="819. Most Common Word"></a>819. Most Common Word</h3><p><strong>题目描述</strong></p><p>Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. </p><p>Words in the list of banned words are given in lowercase, and free of  punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.</p><p><strong>Example:</strong></p><pre><code>Input: paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;banned = [&quot;hit&quot;]Output: &quot;ball&quot;</code></pre><h4 id="solution-8"><a href="#solution-8" class="headerlink" title="solution"></a>solution</h4><ul><li>做题之前先想清楚再做，每次都是，要不做一半，发现理解错题意了，要不就是做到最后，越做越乱</li><li>新语法：sstringstream，map的make_pair</li><li>思路就是：<ul><li>首先把paragraph做处理，把其他punctuation都变为“ ”，在这个过程中，把大写都转换为小写。因为在banned中的单词都是小写。这里要注意的是，把逗号之类的转换为空格，加上本来就存在的空格，会出现两个空格的清空，用string的find空格，会出错！！！</li><li>遍历段落中的单词，记录出现次数最多并且不再banned中的<ul><li>这里的一个技巧点，并不是总需要一步一步向下走，像这种一边查看是否在banned中，一边就可以去比较出现次数，出现次数一旦是最多的，就可以记录，而不是先将所有的单词出现次数记录一遍，然后再去遍历这个次数，找出最多</li></ul></li></ul></li><li>因为用到了在banned中find的操作，因此将vector转换为set了</li><li>要返回的是string，这个string的次数还要出现最多，因此选用map作为存储中间结果的数据结构</li><li>时间：O(n+m),空间：O(n+m)，n和m分别为para和banned的大小</li></ul><pre><code class="C++">class Solution {public:    string mostCommonWord(string para, vector&lt;string&gt;&amp; banned) {        unordered_set&lt;string&gt;s(banned.begin(),banned.end());        unordered_map&lt;string,int&gt;mymap;        int len = para.size();        for(char &amp;c : para)            c = isalpha(c)?tolower(c):&#39; &#39;;        pair&lt;string,int&gt; res(&quot;&quot;,0);        istringstream iss(para);        string word;       while(iss &gt;&gt; word){            if((s.find(word) == s.end()) &amp;&amp; (++mymap[word] &gt; res.second))                res = make_pair(word,mymap[word]);        }               return res.first;    }};</code></pre><h3 id="443-String-Compression"><a href="#443-String-Compression" class="headerlink" title="443. String Compression"></a>443. String Compression</h3><p><strong>Example 1:</strong></p><pre><code>Input:[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]Output:Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]Explanation:&quot;aa&quot; is replaced by &quot;a2&quot;. &quot;bb&quot; is replaced by &quot;b2&quot;. &quot;ccc&quot; is replaced by &quot;c3&quot;.</code></pre><h4 id="solution-9"><a href="#solution-9" class="headerlink" title="solution"></a>solution</h4><ul><li>思路比较简单，但是有点难写</li><li>考虑两种情况<ul><li>连续出现的字符，首先定位一个字符，接着一直向后扫描</li><li>相邻两个字符不一致（这里比较时用的是：当前字符和下一个字符）/已经到了字符末尾<ul><li>记录当前字符，记录当前字符出现的次数</li></ul></li></ul></li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution {public:    int compress(vector&lt;char&gt;&amp; chars) {        int len = chars.size();        int cur = 0, newIndex = 0;//cur：当前比较的字符，newIndex：是新记录的vector，因为新的结果大小 &lt;= 原vector，因此可以一边遍历重复使用，最后返回index        for(int i = 0; i&lt; len; i++){            if(i+1 == len || chars[i] != chars[i+1]){                chars[newIndex++] = chars[i];                 //记录当前重复字符出现的次数，对于只出现一次的，则没有这步                if(cur &lt; i){                    string cnt = to_string(i-cur+1);                    for(char c: cnt)                        chars[newIndex++] = c;                }                              cur = i+1;            }        }        return newIndex;         }};</code></pre><h3 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h3><p><strong>题目描述</strong></p><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><h4 id="solution2-辅助栈"><a href="#solution2-辅助栈" class="headerlink" title="solution2-辅助栈"></a>solution2-辅助栈</h4><ul><li>如果是左括号，进栈，如果是右括号，匹配栈顶是否为对应的左括号</li><li>时间：O(n)，空间：O(n)-辅助栈</li></ul><pre><code class="C++">class Solution {public:    bool isValid(string s) {        stack&lt;char&gt;ch;        for(int i = 0; i &lt; s.size(); i++){            if(s[i] == &#39;(&#39; || s[i] == &#39;{&#39; || s[i] == &#39;[&#39;)                ch.push(s[i]);            else{                if(ch.empty()) return false;//这个很重要，要弹出，首先就要判断栈是否为空                if(s[i] == &#39;)&#39; &amp;&amp; ch.top() != &#39;(&#39;)                    return false;                if(s[i] == &#39;}&#39; &amp;&amp; ch.top() != &#39;{&#39;)                    return false;                if(s[i] == &#39;]&#39; &amp;&amp; ch.top() != &#39;[&#39;)                    return false;                ch.pop();            }               }        return ch.empty();             }};</code></pre><h3 id="434-Number-of-Segments-in-a-String"><a href="#434-Number-of-Segments-in-a-String" class="headerlink" title="434. Number of Segments in a String"></a>434. Number of Segments in a String</h3><p><strong>题目描述</strong></p><p>Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.</p><p><strong>Example:</strong></p><pre><code>Input: &quot;Hello, my name is John&quot;Output: 5</code></pre><h4 id="solution-查找空格-错误"><a href="#solution-查找空格-错误" class="headerlink" title="solution-查找空格-错误"></a>solution-查找空格-错误</h4><ul><li>这道题就是在考察各种特殊情况<ul><li>结尾有没有空格</li><li>字符串为空</li><li>只有一个字符串</li></ul></li><li>事实证明我写的这个不行，突然想到了前几天用到的istringstream</li></ul><pre><code class="C++">class Solution {public:    int countSegments(string s) {        if(s.empty())            return 0;        int cnt = 0;        istringstream ss(s);        string w;        while(ss&gt;&gt;w){            cnt++;        }        return cnt;      }};</code></pre><h3 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125. Valid Palindrome"></a>125. Valid Palindrome</h3><p><strong>题目描述</strong></p><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;A man, a plan, a canal: Panama&quot;Output: true</code></pre><h4 id="solution1"><a href="#solution1" class="headerlink" title="solution1"></a>solution1</h4><ul><li>对原字符串进行处理，注意题目的意思包括字符和数字</li><li>判断是否为回文</li><li>时间：O(n),空间：O(1)</li></ul><pre><code class="C++">class Solution {public:    bool isPalindrome(string s) {        if(s.empty())            return true;        int len = s.size();        for(int i = 0; i &lt; len; i++){            char c = s[i];            //s[i] = isalpha(c)?tolower(s[i]):&#39;&#39;;//&#39; &#39;不知道为啥不能在这里放            if(isalpha(c))                s[i] = tolower(c);            else if(isdigit(c)){                continue;            }            else                s[i] = &#39; &#39;;                          }         int k = 0, j = len-1;         while(k &lt; j){            while(s[k] == &#39; &#39; &amp;&amp; k &lt; j)  k++;                          while(s[j] == &#39; &#39; &amp;&amp; k &lt; j)  j--;            if(s[k] != s[j])                return false;            k++;            j--;//一定要记得在这里更新循环值        }       return true;    }};</code></pre><h4 id="solution2-2"><a href="#solution2-2" class="headerlink" title="solution2"></a>solution2</h4><ul><li>isnumalp()：既可以判断是否为数字，又可以判断是否为字母</li><li>transform()：对大小写的转换</li></ul><pre><code class="C++">class Solution {public:    bool isPalindrome(string s) {        if(s.empty())            return true;        transform(s.begin(),s.end(),s.begin(),::tolower);        int i = 0, j = s.size()-1;        while(i &lt; j){            bool flag1 = isAlphaNumeric(s[i]), flag2 = isAlphaNumeric(s[j]);            if(flag1 &amp;&amp; flag2){                if(s[i] == s[j]){                    i++;                    j--;                }else                    return false;                                }else if(flag1){                j--;            }else if(flag2){                i++;            }else{                i++;                j--;            }        }        return true;           }    bool isAlphaNumeric(char c){        if((c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) ||(c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;))            return true;        else            return false;    }};</code></pre><h3 id="680-Valid-Palindrome-II"><a href="#680-Valid-Palindrome-II" class="headerlink" title="680. Valid Palindrome II"></a>680. Valid Palindrome II</h3><p> <strong>题目描述</strong></p><p>Given a non-empty string <code>s</code>, you may delete <strong>at most</strong> one character.  Judge whether you can make it a palindrome. </p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;abca&quot;Output: True</code></pre><h4 id="solution-10"><a href="#solution-10" class="headerlink" title="solution"></a>solution</h4><ul><li><p>回文就是正着反着读出来都一样</p></li><li><p>出栈读取和原字符串一样，这里的区别是，可以有一次机会，某个字符可以不是回文</p></li><li><p>这里有个问题就是，在遍历过程中，当两个字符不一致的时候，到达是哪一个字符向前走一个，因此，想到了递归</p></li><li><p>不断地缩小问题，双指针，一个从前往后，一个从后往前，每次比较两个字符   - 如果相等，则缩小范围</p><ul><li>如果不相等，则向左或者向右缩小范围 </li></ul></li><li><p>时间：O(n)，空间：O(n)</p></li></ul><pre><code class="C++">class Solution {public:    bool isEqual(string s, int beg, int en){         //cout&lt;&lt;s.substr(beg,en-beg+1)&lt;&lt;endl;        /* // 内存超了        if(beg &gt; en)            return true;        if(s[beg] == s[en])            return isEqual(s, beg+1, en-1);        else            return false;                      */         for(int i = beg, j = en; i &lt; j ; i++, j--){            if(s[i] != s[j])                return false;        }        return true;                     }    bool validPalindrome(string s) {        int len = s.size();        int beg = 0, en = len-1;        while(beg &lt;= en){            if(s[beg] != s[en]){                return (isEqual(s,beg+1,en)) || (isEqual(s,beg,en-1));            }                beg++;            en--;        }                return true;           }};</code></pre><h3 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28. Implement strStr()"></a>28. Implement strStr()</h3><p><strong>题目描述</strong></p><p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p><p><strong>Example 1:</strong></p><pre><code>Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2</code></pre><p><strong>solution</strong></p><pre><code class="C++">class Solution {public:    int strStr(string haystack, string needle) {        if(needle.empty() || haystack == needle)            return 0;        int len1 = haystack.size(),len2= needle.size();        if( len1 &lt; len2 )            return -1;        int pos = haystack.find(needle,0);        if(pos != string::npos)            return pos;        else            return -1;        }};</code></pre><h3 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h3><p><strong>题目描述</strong></p><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p><p><strong>Example 1:</strong></p><pre><code>Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;</code></pre><h4 id="solution-11"><a href="#solution-11" class="headerlink" title="solution"></a>solution</h4><ul><li>依次遍历vector，依次比较每个单词对应的元素,用set中元素是unique的特性来存储相同元素</li><li>时间：有一个排序的过程，O(Nlog(N))?，双层循环：O(n*N)，n是最短字符串的长度，N是vector的大小</li><li>空间：O(1)</li></ul><pre><code class="C++">class Solution {public:    static bool cmp(const string&amp; s1, const string&amp; s2){        return s1.size() &lt; s2.size();    }    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {        int vLen = strs.size();        if(strs.empty())            return &quot;&quot;;        if( vLen == 1)            return strs[0];        sort(strs.begin(),strs.end(),cmp);//表示最长公共前缀是最短的那个字符串,直接用sort是对字符本身的排序，而这里需要的是对字符串的长度进行排序        int sLen = strs[0].size();        //cout&lt;&lt;sLen&lt;&lt;endl;        for(int i = 0; i&lt; sLen; i++){            char tmp = strs[0][i];            for(int j = 1; j &lt; vLen; j++){                if(strs[j][i] != tmp)                    return strs[0].substr(0,i);;            }         }                return strs[0];            }};</code></pre><h3 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a>58. Length of Last Word</h3><p><strong>题目描述</strong></p><p>Given a string <em>s</em> consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word in the string.</p><h4 id="solution-12"><a href="#solution-12" class="headerlink" title="solution"></a>solution</h4><ul><li>看别人的代码，总有一种胜读十年书的感觉</li><li>时间：O(n)，空间：O(1)</li><li>note:isblank()</li><li>让别人的智慧来熏陶一下自己，自己的代码就放在后面来激励一下自己吧</li></ul><pre><code class="C++">class Solution {public:    int lengthOfLastWord(string s) {        if(s.empty())            return 0;        int i = s.size()-1;        while(i &gt;= 0 &amp;&amp; isblank(s[i]))            i--;        int len = 0;        while(i &gt;= 0 &amp;&amp; !isblank(s[i])){            len++;            i--;        }        return len;    }};</code></pre><pre><code class="c++">class Solution {public:    int lengthOfLastWord(string s) {        if(s.empty())            return 0;        int len = s.size();        int i = len-1;        while(i &gt;= 0 &amp;&amp; s[i] == &#39; &#39;) i--;        if(i &lt; 0)            return 0;        int start = i;        while(i &gt;= 0){            if(s[i] == &#39; &#39;)//这里是统计最后一个单词的停止地方                return start - i;        }            i--;        return start - i;    }};</code></pre><h3 id="686-Repeated-String-Match"><a href="#686-Repeated-String-Match" class="headerlink" title="686. Repeated String Match"></a>686. Repeated String Match</h3><p><strong>题目描述</strong></p><p>Given two strings A and B, find the minimum number of times A has to  be repeated such that B is a substring of it. If no such solution,  return -1.</p><p>For example, with A = “abcd” and B = “cdabcdab”.</p><p>Return 3, because by repeating A three times (“abcdabcdabcd”), B is a  substring of it; and B is not a substring of A repeated two times  (“abcdabcd”).</p><h4 id="solution-13"><a href="#solution-13" class="headerlink" title="solution"></a>solution</h4><ul><li>B是A*k的子串，求最小的k</li><li>首先肯定需要A的长度大于等于B，之后比较B是否包含在A内</li><li>当长度是k时不包含，则再加一个A如果还不包含，那指定不包含了</li><li>时间：O(n)，空间：O(n)：n是字符的个数</li></ul><pre><code class="c++">class Solution {public:    int repeatedStringMatch(string A, string B) {        if(A.find(B) != string::npos)            return 1;        int time = 1;        string resA = A;        while(resA.size() &lt; B.size()){            resA += A;//这里不能是A的自加，因为A变化后，下次加的是其新值            time++;        }        int pos1 = resA.find(B);        if(pos1 != string::npos)            return time;        resA += A;        int pos2 = resA.find(B);        if(pos2 != string::npos)            return time+1;        return -1;    }};</code></pre><h3 id="859-Buddy-Strings"><a href="#859-Buddy-Strings" class="headerlink" title="859. Buddy Strings"></a>859. Buddy Strings</h3><p><strong>题目描述</strong></p><p>Given two strings <code>A</code> and <code>B</code> of lowercase letters, return <code>true</code> if and only if we can swap two letters in <code>A</code> so that the result equals <code>B</code>.</p><p><strong>Example 1:</strong></p><pre><code>Input: A = &quot;ab&quot;, B = &quot;ba&quot;Output: trueInput: A = &quot;aa&quot;, B = &quot;aa&quot;Output: true</code></pre><h4 id="solution1-遍历-1"><a href="#solution1-遍历-1" class="headerlink" title="solution1-遍历"></a>solution1-遍历</h4><ul><li>A、B的长度不等，那么一定不可能相等</li><li>A、B长度为2，A[1] == B[0] &amp;&amp; A[0] == B[1]</li><li>如果两者都相等，除非有个元素是重复出现过，否则也不可以。</li><li>主要思路是：依次比较A和B的每个元素，如果第一次不相等，则记录位置，等到第二次不相等的时候，看A，B不相等的元素是否和第一次不相等位置的元素正好匹配</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution {public:    bool buddyStrings(string A, string B) {        int lenA = A.size(), lenB = B.size();        if(lenA != lenB)            return false;        if(lenA == 2)            return (A[1] == B[0]) &amp;&amp; (A[0] == B[1]);        if(A == B)            return hasDup(A);//对于相等的A和B，当且仅当A有重复元素时，可以交换相同元素，否则，不可以        int i = 0,first = 0;//first记录第一次不一致的位置        bool flag = false,flag1 = false;//flag为true时表示已经有过不一致,flag1为true表示有过第二次不一致，而且已经有过一次交换的机会了，不能再有不一致了        while(i &lt; lenA){            if(A[i] == B[i]){                i++;            }else if(flag){                if(!flag1  &amp;&amp; A[first] == B[i] &amp;&amp; B[first] == A[i]){                     i++;                     flag1 = true;                }else                    return false;            }else{                flag = true;                first = i;                i++;            }        }        return true;;       }    bool hasDup(string s){        int len = s.size();        for(int i = 0; i &lt; len-1; i++){            if(s.find(s[i],i+1) != string::npos)                return true;        }        return false;    }   };</code></pre><h4 id="solution2-利用额外空间"><a href="#solution2-利用额外空间" class="headerlink" title="solution2-利用额外空间"></a>solution2-利用额外空间</h4><ul><li>主要的不同就是<ul><li>对于相同的两个字符串，判断是否有重复元素，用了set</li><li>对于不同的元素位置的记录，使用了vector</li></ul></li><li>时间：O(n)，都是一遍扫描，空间：O(n)：用到了set，vector</li></ul><pre><code class="C++">class Solution {public:    bool buddyStrings(string A, string B) {        int lenA = A.size(), lenB = B.size();        if(lenA != lenB)            return false;        //这里我第一个想到的就是set，但是不知道怎么用，看了别人写的，简直太机智了        if(A == B){            if(set&lt;char&gt;(A.begin(), A.end()).size() &lt; A.size())                 return true;//这里只判断了有重复元素的情况        }        vector&lt;int&gt; index;        int i = 0;         while(i &lt; lenA){            if(A[i] != B[i])                index.push_back(i);            i++;        }        //size == 2这点是判断没有重复元素的情况        return (index.size()==2) &amp;&amp; (A[index[0]] == B[index[1]]) &amp;&amp; (A[index[1]] == B[index[0]]);    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my first article</title>
      <link href="/2019/10/03/my-first-article/"/>
      <url>/2019/10/03/my-first-article/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h4 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h4><blockquote><p>洪卫的博客：<a href="https://www.cnblogs.com/shwee/p/11421156.html" target="_blank" rel="noopener">https://www.cnblogs.com/shwee/p/11421156.html</a></p><p>叶落阔的博客及3-hexo的模板：<a href="https://yelog.org/" target="_blank" rel="noopener">https://yelog.org/</a></p></blockquote><h4 id="搭建博客过程"><a href="#搭建博客过程" class="headerlink" title="搭建博客过程"></a>搭建博客过程</h4><ul><li>这是我的第一篇博客，为什么用 npm i hexo-deployer-git 不能生成一个放图片的文件夹呢？</li><li>首先生成： <code>hexo g</code>，然后在本地预览 <code>hexo s</code>，最后部署在github上<code>hexo d</code></li></ul><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><ul><li>公式的使用在每篇文档开头设置mathjax： $v_i$</li></ul><pre><code class="C++">#include&lt;iostream&gt;using namespace std;int main(){    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> problem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList-problems-easy</title>
      <link href="/2019/08/28/LinkedList-problems-easy/"/>
      <url>/2019/08/28/LinkedList-problems-easy/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><pre><code class="c++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */</code></pre><h3 id="876-Middle-of-the-Linked-List"><a href="#876-Middle-of-the-Linked-List" class="headerlink" title="876.Middle of the Linked List"></a>876.Middle of the Linked List</h3><p><strong>题目描述：</strong></p><p>Given a non-empty, singly linked list with head node head, return a middle node of linked list.<br>If there are two middle nodes, return the second middle node.</p><p><strong>Example</strong> :</p><pre><code>Input: [1,2,3,4,5,6]Output: Node 4 from this list (Serialization: [4,5,6])Since the list has two middle nodes with values 3 and 4, we return the second one.</code></pre><h4 id="Solution-1-遍历"><a href="#Solution-1-遍历" class="headerlink" title="Solution 1-遍历"></a>Solution 1-遍历</h4><ul><li>将链表遍历一遍，得到链表的长度，求出中间节点的位置，重新从头开始遍历，输出中间节点。</li></ul><p>时间：O(2n)，空间O(1)？</p><pre><code class="c++">class Solution {public:    ListNode* middleNode(ListNode* head) {        if(head == NULL)            return NULL;        ListNode* tmp = head;        int cnt = 0;        while(tmp != NULL){            cnt++;            tmp = tmp-&gt;next;        }        int i = cnt/2;        tmp = head;        while(i != 0){            tmp = tmp-&gt;next;            i--;        }        return tmp;    }};</code></pre><h4 id="Solution-2-快慢指针"><a href="#Solution-2-快慢指针" class="headerlink" title="Solution 2-快慢指针"></a>Solution 2-快慢指针</h4><ul><li>这个本来是想到了，但是自己不知道为什么演算错了。。。要考虑奇偶个数的情况；</li></ul><p>时间：O(n/2)，空间O(1)-快慢指针</p><pre><code class="c++">class Solution {public:    ListNode* middleNode(ListNode* head) {        if(head == NULL)            return NULL;        ListNode* slow = head, *fast = head;        //快指针比慢指针快一倍的速度，不是两个。。。        while(slow-&gt;next != NULL &amp;&amp; fast-&gt;next != NULL){            //奇数个元素            if(fast-&gt;next-&gt;next != NULL){                fast = fast-&gt;next-&gt;next;                slow = slow-&gt;next;            }else{                //返回方法一                fast = fast-&gt;next;                slow = slow-&gt;next;                //return slow-&gt;next;  //返回方法二            }        }        return slow;    }};</code></pre><h4 id="Solution-3-辅助数组"><a href="#Solution-3-辅助数组" class="headerlink" title="Solution 3-辅助数组"></a>Solution 3-辅助数组</h4><ul><li><p>使用数组把所有元素放进去，按照数组随机存取的特性，直接定位到元素，这样就不是原来链接起来的链表了,用空间换时间。</p></li><li><p>时间O(n)，空间O(n)-vec用的空间</p></li></ul><pre><code class="c++">class Solution {public:    ListNode* middleNode(ListNode* head) {        if(head == NULL)            return NULL;        vector&lt;ListNode*&gt;vec{head};//注意初始化是{}，不是[]        ListNode* cur = vec.back();        while(cur-&gt;next != NULL){            vec.push_back(cur-&gt;next);            cur = cur-&gt;next;                    }        return vec[vec.size()/2];//相对于第一种的优点就是考虑到了数组的随机访问快    }};</code></pre><h3 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h3><p><strong>题目描述：</strong></p><p>Reverse a singly linked list.</p><p><strong>Example:</strong></p><pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><h4 id="solution1-迭代"><a href="#solution1-迭代" class="headerlink" title="solution1-迭代"></a>solution1-迭代</h4><ul><li>主要目的是不要让链表断了，用三个指针分别表示当前节点，前一个，后一个.</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="c++">class Solution {public:    ListNode* reverseList(ListNode* head) {        if(head == NULL)            return NULL;        ListNode *cur=NULL,*pre=NULL,*post=NULL;        cur=head;        while(cur!=NULL)   //要注意判断条件        {            post=cur-&gt;next;            cur-&gt;next=pre;            pre=cur;            cur=post;        }             return pre;            }};//这个和上面的差不多，根本不是递归，就是迭代吧/*class Solution {public:    ListNode* reverseList(ListNode* head) {        if(head == NULL)            return NULL;        ListNode *cur=NULL,*pre=NULL,*post=NULL;        cur=head;        return reverse(pre,cur,post);    }    ListNode* reverse(ListNode* pre, ListNode* cur, ListNode* post){        if(cur == NULL)            return pre;        post = cur-&gt;next;        cur-&gt;next = pre;        pre  = cur;        return reverse(pre,post,post);    }};*/</code></pre><h4 id="Solution2-递归"><a href="#Solution2-递归" class="headerlink" title="Solution2-递归"></a>Solution2-递归</h4><ul><li>主要是要理解递归。边界条件，cur == NULL则链表是空的，cur-&gt;next == NULL意味着链表已经到最后一个节点了，那么这个节点是新的head，开始返回。</li><li>递归时会为每个参数变量压栈，返回后就是当时的cur，那么cur的next是逆转的节点，这个节点的next就是cur。思路参考<a href="https://www.youtube.com/watch?v=MRe3UsRadKw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=MRe3UsRadKw</a></li><li>做的时候难点在于：指针的理解，<code>**</code>的理解及传参，以及如何改变head指针。</li><li>时间：O(n)，空间：O(n)-因为递归而使用的栈空间    </li></ul><pre><code class="c++">class Solution {public:    ListNode* reverseList(ListNode* head) {        if(head == NULL)            return NULL;        ListNode *cur = head;        reverse(cur,&amp;head);        return head;    }     void reverse(ListNode* cur,ListNode** head){         if(cur-&gt;next == NULL){             *head = cur;             return ;         }         reverse(cur-&gt;next,head);         cur-&gt;next-&gt;next = cur;         cur-&gt;next = NULL;     }};</code></pre><h3 id="237-Delete-Node-in-a-Linked-List"><a href="#237-Delete-Node-in-a-Linked-List" class="headerlink" title="237.Delete Node in a Linked List"></a>237.Delete Node in a Linked List</h3><p><strong>题目描述：</strong></p><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p><p>Given linked list – head = [4,5,1,9], which looks like following:</p><p><img src="https://assets.leetcode.com/uploads/2018/12/28/237_example.png" alt="img"></p><p><strong>Example 1:</strong></p><pre><code>Input: head = [4,5,1,9], node = 5Output: [4,1,9]Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</code></pre><h4 id="solution-值替换"><a href="#solution-值替换" class="headerlink" title="solution-值替换"></a>solution-值替换</h4><ul><li>因为尾节点不为空：所以可以不删除当前节点，而是删除后一个节点。把给定当前节点，想要找到要删除节点的前一个节点，只能从头遍历;</li><li>将后一个节点的值赋值给当前节点，并让当前节点指向下下个节点，从而删除下个节点</li><li>如果要删除尾节点元素，那么就不能这样做，必须给head，从头向后遍历。</li></ul><pre><code class="c++">class Solution {public:    void deleteNode(ListNode* node) {        /*        node-&gt;val = node-&gt;next-&gt;val;        ListNode* tmp = node-&gt;next;        node-&gt;next =  node-&gt;next-&gt;next;        delete(tmp);   //还是应该把这个指针释放掉，不然会内存泄漏，但不这样写也能通过    */        auto next = node-&gt;next;//直接操作指针        *node = *next;        delete next;       }};</code></pre><h3 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21.Merge Two Sorted Lists"></a>21.Merge Two Sorted Lists</h3><p><strong>题目描述：</strong></p><p>Merge two sorted linked lists and return it as a new list. The new  list should be made by splicing together the nodes of the first two  lists.</p><p><strong>Example:</strong> </p><pre><code>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><h4 id="solution1-迭代-1"><a href="#solution1-迭代-1" class="headerlink" title="solution1-迭代"></a>solution1-迭代</h4><ul><li>面对list的问题，可以尝试一个dummyHead，避免对特殊情况的处理</li></ul><pre><code class="c++">class Solution {public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {        ListNode *pNewHead = NULL; //合并后新的头结点        ListNode *pTail = NULL;      //不断连接新节点的尾节点        ListNode *pl1 = l1, *pl2 = l2;        if(l1 == NULL)   //对于特殊情况：两个链表为空做判断，都为空时这句话就可以捕获到            return l2;        else if(l2 == NULL)            return l1;        else{            if((l1-&gt;val) &lt; (l2-&gt;val)){                pNewHead = l1;                l1 = l1-&gt;next;            }else{                pNewHead = l2;                l2 = l2-&gt;next;            }            }        pTail = pNewHead;        while(l1 != NULL &amp;&amp; l2 !=NULL){            if((l1-&gt;val) &lt; (l2-&gt;val)){                pTail-&gt;next = l1;                pTail = pTail-&gt;next;                l1 = l1-&gt;next;            }else{                pTail-&gt;next = l2;                pTail = pTail-&gt;next;                l2 = l2-&gt;next;            }                 }        //对于两个链表不一样长的情况做处理 ，因为是直接在链表本身上做连接，不是新创建一条链表，所以这里剩下的节点只需要一个指针指向即可，不需要遍历连接。        if(l1 != NULL){            pTail-&gt;next = l1;        }        if(l2 != NULL){            pTail-&gt;next = l2;        }                    return pNewHead;     }    };</code></pre><h4 id="solution2-递归"><a href="#solution2-递归" class="headerlink" title="solution2-递归"></a>solution2-递归</h4><p>因为在递归调用的过程当中，系统为每一层的返回点、局部量等开辟了栈来存储，因此递归次数过多容易造成栈溢出。所以选择递归时要慎重。思路看代码吧~</p><pre><code class="c++">class Solution {public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {        if(l1 == NULL)            return l2;        if(l2 == NULL)            return l1;        if((l1-&gt;val) &lt; (l2-&gt;val)){            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);            return l1; //就是cur节点，一直指向当前链表的尾节点        }else{            l2-&gt;next = mergeTwoLists(l1,l2-&gt;next);            return l2;        }                        }};</code></pre><h3 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83.Remove Duplicates from Sorted List"></a>83.Remove Duplicates from Sorted List</h3><p><strong>题目描述：</strong></p><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p><p><strong>Example 1:</strong></p><pre><code>Input: 1-&gt;1-&gt;2Output: 1-&gt;2</code></pre><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><ul><li>看清楚题目，不要求把重复的所有元素都删除</li><li>cur表示当前节点，依次和下一个节点比较，如果值一样，则与下一个节点比较，并每次删除一个值一样的节点</li><li>时间：O(n)，必须从头遍历到尾，空间：O(1)</li></ul><pre><code class="c++">class Solution {public:    ListNode* deleteDuplicates(ListNode* head) {        if(head == NULL)            return NULL;        ListNode* cur = head;       // ListNode* tmp = NULL;        while(cur){            while(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val){               // tmp = cur-&gt;next;                cur-&gt;next = cur-&gt;next-&gt;next;                //delete(tmp);            }            cur = cur-&gt;next;        }        return head;    }};</code></pre><h3 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141.Linked List Cycle"></a>141.Linked List Cycle</h3><p><strong>题目描述</strong></p><p>Given a linked list, determine if it has a cycle in it.</p><p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p><p><strong>Example 1:</strong></p><pre><code>Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where tail connects to the second node.</code></pre><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><h4 id="solution1—快慢指针"><a href="#solution1—快慢指针" class="headerlink" title="solution1—快慢指针"></a>solution1—快慢指针</h4><ul><li>第一种解法就是快慢指针，而且只需要O(1)空间，O(n)时间，但是奇怪的是，我因为指针指向原因，错了三次？</li></ul><pre><code class="c++">class Solution {public:    bool hasCycle(ListNode *head) {        if(head == NULL || head-&gt;next == NULL)            return false;        ListNode* slow = head, *fast = head-&gt;next;        while(fast != slow){            if(fast == NULL || fast-&gt;next == NULL){                return false;            }            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;        }        return true;    }</code></pre><h4 id="solution2-辅助集合"><a href="#solution2-辅助集合" class="headerlink" title="solution2-辅助集合"></a>solution2-辅助集合</h4><ul><li>检查某个节点是否被第二次访问，使用hash表，查看当前元素在hash表中是否存在，则需要find函数(set)</li><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="c++">class Solution {public:    bool hasCycle(ListNode *head) {        if(head == NULL || head-&gt;next == NULL)            return false;        ListNode* tmp = head;        set&lt;ListNode*&gt;mySet;        mySet.insert(tmp);        tmp = tmp-&gt;next;        while(tmp != NULL){            if(mySet.find(tmp) == mySet.end()){                mySet.insert(tmp);                tmp = tmp-&gt;next;            }else                return true;        }        return false;    }};</code></pre><h3 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234.Palindrome Linked List"></a>234.Palindrome Linked List</h3><p><strong>题目描述</strong></p><p>Given a singly linked list, determine if it is a palindrome.</p><p>回文是指：正向和反向读取得到的是一样的</p><p><strong>Example 1:</strong></p><pre><code>Input: 1-&gt;2Output: false</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: 1-&gt;2-&gt;2-&gt;1Output: true</code></pre><h4 id="solution1-辅助栈"><a href="#solution1-辅助栈" class="headerlink" title="solution1-辅助栈"></a>solution1-辅助栈</h4><ul><li>遍历链表，使用栈存储，再次遍历链表，和出栈的元素比较</li><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="c++">class Solution {public:    bool isPalindrome(ListNode* head) {        if(head == NULL || head-&gt;next == NULL)            return true;        stack&lt;int&gt;node;        ListNode* tmp = head;        while(tmp != NULL){            node.push(tmp-&gt;val);            tmp = tmp-&gt;next;        }        tmp = head;        while(tmp != NULL){            int v = node.top();            if(tmp-&gt;val != v)                return false;            node.pop();            tmp = tmp-&gt;next;        }        return true;    }</code></pre><h4 id="solution2-递归-1"><a href="#solution2-递归-1" class="headerlink" title="solution2-递归"></a>solution2-递归</h4><ul><li>边界条件：cur == NULL，返回true</li><li>用一个指针指在链表头；递归不断执行，到了链表结尾，然后出栈，不断返回，表头指针不断往前走，也是一个后面和前面比较的过程。但是我在想，怎么能让它比较到中间的时候就停止呢？</li><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="c++">class Solution {public:    ListNode* temp ;    bool isPalindrome(ListNode* head) {        if(head == NULL || head-&gt;next == NULL)            return true;        temp = head;        return check(head);    }    bool check(ListNode* p){        if(p == NULL)            return true;        bool isPal = check(p-&gt;next) &amp; (p-&gt;val == temp-&gt;val);        temp = temp-&gt;next;        return isPal;     }};</code></pre><h3 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="203.Remove Linked List Elements"></a>203.Remove Linked List Elements</h3><p><strong>题目描述</strong></p><p>Remove all elements from a linked list of integers that have value <strong>val</strong>.</p><p><strong>Example:</strong></p><pre><code>Input:  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6Output: 1-&gt;2-&gt;3-&gt;4-&gt;5</code></pre><h4 id="solution-遍历"><a href="#solution-遍历" class="headerlink" title="solution-遍历"></a>solution-遍历</h4><ul><li>删除具有相同值的元素。因为要删除，所以需要记录当前元素的上一个，才能把指针连接到下一个<br>为了处理头结点，引入dummyHead。或者直接，用cur-&gt;next和值做比较</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution {public:    ListNode* removeElements(ListNode* head, int val) {        if(head == NULL)            return NULL ;        ListNode* dummyHead = new ListNode(0);        dummyHead-&gt;next = head;        ListNode* pre = dummyHead, *cur = head;        while(cur != NULL){            if(cur-&gt;val == val){                pre-&gt;next = cur-&gt;next;                cur = pre-&gt;next;            }else{                pre = cur;                cur = cur-&gt;next;                            }                 }        return dummyHead-&gt;next;                    }};</code></pre><h3 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160.Intersection of Two Linked Lists"></a>160.Intersection of Two Linked Lists</h3><p><strong>题目描述</strong></p><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" alt="img"></p><p>begin to intersect at node c1.</p><h4 id="solution1-求长度"><a href="#solution1-求长度" class="headerlink" title="solution1-求长度"></a>solution1-求长度</h4><ul><li>求出两个链表的长度，因为两个链表可能不一样长，则让长的那个先走几步，然后两个一起走，去比较是否有一致的节点</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="c++">class Solution {public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {        if(headA == NULL || headB == NULL)            return NULL;        //查询链表长度        ListNode* p1 = headA, *p2 = headB;        int lenA = 0, lenB = 0;        while(p1 != NULL){            lenA++;            p1 = p1-&gt;next;        }        while(p2 != NULL){            lenB++;            p2 = p2-&gt;next;        }        //将长的那个链表定位到与短链表一样长的地方        p1 = headA, p2 = headB;        int step = (lenA&gt;lenB)?(lenA-lenB):(lenB-lenA);        if(lenA &gt;= lenB){            while(step){                p1 = p1-&gt;next;                step--;            }        }else{            while(step){                p2 = p2-&gt;next;                step--;            }        }        //开始同时遍历并比较两个链表的节点        while(p1 != NULL &amp;&amp; p2 != NULL){            if(p1 != p2){//判断的是节点是否相同，不是节点的值                p1 = p1-&gt;next;                p2 = p2-&gt;next;            }            else                return p1;          }        return NULL;            }};</code></pre><h4 id="solution2—辅助栈"><a href="#solution2—辅助栈" class="headerlink" title="solution2—辅助栈"></a>solution2—辅助栈</h4><ul><li>如果有交集，那么倒着遍历时第一个不一样的节点就是分岔处。</li><li>顺序遍历，将元素分别存储在辅助的栈中。依次从栈中弹出元素比较</li><li>时间：O(n)，空间：O(n)</li><li>没写。。。</li></ul><h4 id="solution3-链表粘合"><a href="#solution3-链表粘合" class="headerlink" title="solution3-链表粘合"></a>solution3-链表粘合</h4><pre><code class="c++">class Solution {public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {        if(headA == NULL || headB == NULL)            return NULL;        ListNode *p1 = headA, *p2 = headB;        //只有拼接后的两条链都遍历完，才结束        while(p1 != NULL &amp;&amp; p2 != NULL &amp;&amp; p1 != p2){            p1 = p1-&gt;next;            p2 = p2-&gt;next;            if(p1 == p2)                return p1;            if(p1 == NULL)  p1 = headB;            if(p2 == NULL)  p2 = headA;        }        return p1;//p1 == p2 的情况是两条链的公共节点是第一个的时候，不会执行while里面的语句，否则，在有前缀节点的情况下，一定是在循环内找到交点。如果没有交点，则p1是返回NULL    }};</code></pre><h3 id="707-Design-Linked-List"><a href="#707-Design-Linked-List" class="headerlink" title="707. Design Linked List"></a>707. Design Linked List</h3><p><strong>题目描述：</strong></p><p>Design your implementation of the linked list. You can choose to use  the singly linked list or the doubly linked list. A node in a  singly linked list should have two attributes: <code>val</code> and <code>next</code>. <code>val</code> is the value of the current node, and <code>next</code> is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute <code>prev</code> to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p><p>Implement these functions in your linked list class:</p><ul><li>get(index) : Get the value of the <code>index</code>-th node in the linked list. If the index is invalid, return <code>-1</code>.</li><li>addAtHead(val) : Add a node of value <code>val</code> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li><li>addAtTail(val) : Append a node of value <code>val</code> to the last element of the linked list.</li><li>addAtIndex(index, val) : Add a node of value <code>val</code> before the <code>index</code>-th node in the linked list. If <code>index</code> equals to  the length of linked list, the node will be appended to the end of  linked list. If index is greater than the length, the node will not be  inserted. If index is negative, the node will be inserted at the head of  the list.</li><li>deleteAtIndex(index) : Delete the <code>index</code>-th node in the linked list, if the index is valid.</li></ul><p><strong>Example</strong>:</p><p><strong>Note:</strong></p><ul><li>All values will be in the range of <code>[1, 1000]</code>.</li><li>The number of operations will be in the range of <code>[1, 1000]</code>.</li><li>Please do not use the built-in LinkedList library.</li></ul><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>这道题对我来说最大的挑战不是思路，是C++语法的问题。<br>首先是不知道在类里面怎么去声明一个节点的类型，一个是不知道构造函数怎么用了，汗。。。<br>别人的思路的一个亮点：因为题目中要求了使用了头、尾，还有index的合法与不合法，所以设置三个全局变量head,tail,len, 在更新节点数量的时候要记着把len值做改变。</p><pre><code class="c++">class MyLinkedList {private:    struct ListNode{        int val;        ListNode* next;        ListNode(int v):val(v),next(NULL){}    };    ListNode* head;    ListNode* tail;    int len ;public:    /** Initialize your data structure here. */    MyLinkedList() {        head = NULL;        tail = NULL;        len = 0;    }    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */    int get(int index) {        if(index &gt;= len || index &lt; 0)            return -1;        ListNode* p  = head;        for(int i = 0;i &lt; index; i++){            p = p-&gt;next;        }        return p-&gt;val;           }    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */    void addAtHead(int val) {        ListNode* newHead = new ListNode(val);        newHead-&gt;next = head;        head = newHead;        if(len == 0)            tail = newHead;        ++len;    }        /** Append a node of value val to the last element of the linked list. */    void addAtTail(int val) {        ListNode* newTail = new ListNode(val);        if(len == 0){            head = newTail;            tail = newTail;        }                    tail-&gt;next = newTail;        tail = newTail;        newTail-&gt;next = NULL;        ++len;    }    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */    void addAtIndex(int index, int val) {        if(index == len)            addAtTail(val);        else if(index &gt; len)            return ;        else if(index &lt;= 0)            addAtHead(val);        else{            ListNode* p = head;            ListNode* newNode = new ListNode(val);            //找到要插入index的前一个节点，这样直接操作前一个节点的指向即可，所以是index-1，删除同理            for(int i = 0; i &lt; index-1;i++){                p = p-&gt;next;            }            newNode-&gt;next = p-&gt;next;            p-&gt;next = newNode;            ++len;        }                        }    /** Delete the index-th node in the linked list, if the index is valid. */    void deleteAtIndex(int index) {        if(index &lt; 0 || index &gt;= len)            return ;        ListNode* tmp = NULL;//用来做delete操作，在OJ中，我发现不用delete也可以，但是为了养成好习惯，建议始终把不要的节点delete掉，以免内存泄漏        //如果删除头节点,删除完就可以return了        if(index == 0){            tmp = head;            head = head-&gt;next;            delete tmp;            --len;            return;        }        ListNode* p = head;        for(int i = 0; i &lt; index-1; i++){            p = p-&gt;next;        }        //删除尾节点        if(index == len-1)            tail = p;        tmp = p-&gt;next;        p-&gt;next = p-&gt;next-&gt;next;        delete tmp;        --len;    }};/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linkedList </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack-problems-easy</title>
      <link href="/2019/08/23/stack-problems-easy/"/>
      <url>/2019/08/23/stack-problems-easy/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h3 id="1021-Remove-Outermost-Parentheses"><a href="#1021-Remove-Outermost-Parentheses" class="headerlink" title="1021.Remove Outermost Parentheses"></a>1021.Remove Outermost Parentheses</h3><p>题目描述太复杂的情况下看看给的case就大概知道题意了</p><p><strong>Example 2:</strong></p><pre><code>Input: &quot;(()())(())(()(()))&quot;Output: &quot;()()()()(())&quot;Explanation: The input string is &quot;(()())(())(()(()))&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;.After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;.</code></pre><h4 id="solution1-记录左括号个数，分割primitive串"><a href="#solution1-记录左括号个数，分割primitive串" class="headerlink" title="solution1-记录左括号个数，分割primitive串"></a>solution1-记录左括号个数，分割primitive串</h4><ul><li>因为是一道和栈相关的题目，所以第一反应就是使用栈，比如”(()())(())”，设定一个全局遍历s0(“()”)；遇到”(“进栈，遇到”)”时，栈顶的匹配”(“出栈；如果此时栈为空，那么说明最后出栈的那对是外层括号，不计入最终的结果，直接开始遍历下一个元素。否则，res+=s0; 这种方法很闹心的一个地方是，对于”(()(()))”没法做。</li><li>另一种解法就是现在的解法，抛开stack，用string的知识来做。为的是找到最外层的括号，那么就从左向右遍历字符串，并用cnt记录当前左括号的个数，如果有匹配的右括号，则cnt–，有左括号时cnt++，当cnt==0时，即表示当前的右括号是外层括号，那么就把这个外层括号剥去，中间的加入res，那么此时有了待加入字符串的结束为止，还需要一个起始位置，则用start来表示，相当于字符串的截取。每次有了新的子串，start则初始化为新的起始位置。</li><li>时间O(n)，空间：O(n)——存储结果</li></ul><pre><code class="C++">class Solution {public:    string removeOuterParentheses(string S) {        int len = S.size();        string res = &quot;&quot;;             int cnt = 1;//记录左括号的个数，当有右括号与左括号匹配时，减一        int start = 0;//整个串被分为多个primative的串，记录每次新primative串的开始位置              for(int i = 1; i &lt; len;i++){            if(S[i] == &#39;(&#39;){                cnt++;            }else{                cnt--;            }                         if(cnt == 0){                if(i - start &gt;1){                    string tmp(S.begin()+start+1,S.begin()+i);                    res += tmp;                }                start = i+1;            }        }        return res;          }};</code></pre><h4 id="solution2"><a href="#solution2" class="headerlink" title="solution2-"></a>solution2-</h4><ul><li>别人的解法，和上面的思路差不多，但是只用open去记录当前的字符是否是结果的一部分。<br>（我的比这个看起来复杂，主要是被题目给的example引导着做复杂了。即先找出整个大括号包含的字符串，再去除外面的那层，看这个解法，完全可以边走边判断）</li><li>open的数值意义：当前没有匹配的左括号的个数，左括号时加，右括号时减</li><li>如果open&gt;0 &amp;&amp; c == ‘(‘，那么加入res，open++</li><li>如果c == ‘)’ &amp;&amp; open &gt;1，那么加入res，open–；大于1的目的是把最外层的去掉</li><li>时间：O(n)，空间：O(n)——存储结果</li></ul><pre><code class="c++">class Solution {public:    string removeOuterParentheses(string S) {        int open = 0;        string res = &quot;&quot;;        for(char c:S){            if(c == &#39;(&#39; &amp;&amp; open++ &gt; 0) res += c; //最外面的左括号跳过            if(c == &#39;)&#39; &amp;&amp; open-- &gt; 1 ) res += c;                   }        return res;    }};</code></pre><h3 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047.Remove All Adjacent Duplicates In String"></a>1047.Remove All Adjacent Duplicates In String</h3><p><strong>题目描述</strong></p><p>Given a string <code>S</code> of lowercase letters, a <em>duplicate removal</em> consists of choosing two adjacent and equal letters, and removing them.</p><p>We repeatedly make duplicate removals on S until we no longer can.</p><p>Return the final string after all such duplicate removals have been made.  It is guaranteed the answer is unique.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;abbaca&quot;Output: &quot;ca&quot;Explanation: For example, in &quot;abbaca&quot; we could remove &quot;bb&quot; since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is &quot;aaca&quot;, of which only &quot;aa&quot; is possible, so the final string is &quot;ca&quot;.</code></pre><h4 id="solution1-反向遍历，栈"><a href="#solution1-反向遍历，栈" class="headerlink" title="solution1-反向遍历，栈"></a>solution1-反向遍历，栈</h4><ul><li>每次将压入的元素和栈顶元素比较，如果一致就是重复，则新元素不入栈，栈顶元素出栈，这样可以很好的把中间有其他相同元素隔开的多个相同元素找出来。</li><li>反向遍历只是为了正向输出结果</li><li>时间：O(n)，空间：O(n)</li></ul><pre><code class="c++">class Solution {public:    string removeDuplicates(string S) {        stack&lt;char&gt;s;        int len = S.size();        string res = &quot;&quot;;        for(int i = len-1; i &gt;= 0 ; i--){            if(!s.empty()){                if(s.top() == S[i]){                    s.pop();                }else{                    s.push(S[i]);                }            }else{                s.push(S[i]);            }             }        while(!s.empty()){            res += s.top();            s.pop();        }           return res;       }</code></pre><h4 id="solution2-用string变相作为栈"><a href="#solution2-用string变相作为栈" class="headerlink" title="solution2-用string变相作为栈"></a>solution2-用string变相作为栈</h4><ul><li>这种写法，应该对string中的方法有充足的了解</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">class Solution {public:    string removeDuplicates(string S) {        string res = &quot;&quot;;        for(char c : S){            if(res.size() &amp;&amp; res.back() == c)                 res.pop_back();//凡是涉及到删除元素的操作，都要首先判断是否有元素            else                res.push_back(c);           }        return res;    }};</code></pre><h3 id="682-Baseball-Game"><a href="#682-Baseball-Game" class="headerlink" title="682.Baseball Game"></a>682.Baseball Game</h3><ul><li>“C”表示无效前一轮分数，“D”表示将前一轮有效分数乘2作为本轮分数，“+”表示将前两轮的分数之和作为本轮分数。</li></ul><p><strong>Example 1:</strong></p><pre><code>Input: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]Output: 30Explanation: Round 1: You could get 5 points. The sum is: 5.Round 2: You could get 2 points. The sum is: 7.Operation 1: The round 2&#39;s data was invalid. The sum is: 5.  Round 3: You could get 10 points (the round 2&#39;s data has been removed). The sum is: 15.Round 4: You could get 5 + 10 = 15 points. The sum is: 30.</code></pre><h4 id="solution-辅助栈，字符串处理"><a href="#solution-辅助栈，字符串处理" class="headerlink" title="solution-辅助栈，字符串处理"></a>solution-辅助栈，字符串处理</h4><ul><li>完全按照人脑思维，对每个字符可能的情况进行判断</li><li>需要注意的就是，输入是一个字符串的数组，即数组中每个元素为字符串，当score为整数，且位数多于两位，则需要一个个遍历，算出字符串对应的整数。手动的算了。这里要注意有负数的情况。</li><li>时间：O(n)，空间：O(2)——一个辅助栈</li></ul><pre><code class="C++">class Solution {public:    int calPoints(vector&lt;string&gt;&amp; ops) {        stack&lt;int&gt;score;        for(string s : ops){            char c = s[0];            if(c == &#39;C&#39;){                score.pop();            }else if(c == &#39;D&#39;){                int tmp = score.top();                score.push(tmp*2);            }else if(c == &#39;+&#39;){                int tmp1 = score.top();                score.pop();                int cur = tmp1 + score.top();                score.push(tmp1);                score.push(cur);            }else{                int num = 0;                bool flag = false;//是否为负数                for(char c : s){                    if(c == &#39;-&#39;){                        flag = true;                        continue;                    }                    int val = c - &#39;0&#39;;                    num = num*10 + val;                }                if(flag)                    score.push(-num);                else                     score.push(num);            }         }        int sum = 0;        while(!score.empty()){            sum += score.top();            score.pop();        }        return sum;    }</code></pre><h4 id="solution2-vector"><a href="#solution2-vector" class="headerlink" title="solution2-vector"></a>solution2-vector</h4><ul><li>我简直就是一个被残害的少年，为什么想不开总是用stack，既不能随机访问，还得控制顺序</li><li>语法：STL 算法求和<ul><li>int sum = accumulate(score.begin(),score.end(),10);//以10为基础开始加</li><li>string sum = accumulate(v.begin() , v.end() , string(“ “));将字符串连接起来</li></ul></li><li>找到了一个C++11里面字符串转整数的操作stoi(s,0,10)——将s从第0位开始，转换成10进制数。</li><li>判断是否为数字：isdigit()</li></ul><pre><code class="C++">class Solution {public:    int calPoints(vector&lt;string&gt;&amp; ops) {        vector&lt;int&gt;score;        int index = 0;        for(string s : ops){            if(isdigit(s[0]) || s[0] == &#39;-&#39;){               score.push_back(stoi(s));                            }else if(s == &quot;+&quot;){                score.push_back(score[index]+score[index-1]);            }else if(s == &quot;D&quot;){                score.push_back(score[index]*2);            }else{                score.pop_back();            }        index = score.size()-1;        }        return accumulate(score.begin(),score.end(),0);            }};</code></pre><h3 id="844-Backspace-String-Compare"><a href="#844-Backspace-String-Compare" class="headerlink" title="844.Backspace String Compare"></a>844.Backspace String Compare</h3><p><strong>题目描述</strong></p><p>Given two strings <code>S</code> and <code>T</code>, return if they are equal when both are typed into empty text editors. <code>#</code> means a backspace character.</p><p><strong>Example :</strong></p><pre><code>Input: S = &quot;ab##&quot;, T = &quot;c#d#&quot;Output: trueExplanation: Both S and T become &quot;&quot;.Input: S = &quot;a#c&quot;, T = &quot;b&quot;Output: falseExplanation: S becomes &quot;c&quot; while T becomes &quot;b&quot;.</code></pre><h4 id="solution1-辅助栈"><a href="#solution1-辅助栈" class="headerlink" title="solution1-辅助栈"></a>solution1-辅助栈</h4><ul><li>想先比较一下两个字符串的大小，但是不行，因为如果一个比另一个多个#，也返回true；比如”ab##””c#d##”;</li><li>最朴素的做法就是用两个辅助栈,当遇到’#’且栈不为空时就pop，否则入栈，然后从栈中依次弹出元素，比较是否相等，最后还要判断栈内有没有剩余元素 。</li><li>时间O(n)，空间O(n)</li></ul><pre><code class="C++">class Solution {public:    bool backspaceCompare(string S, string T) {        stack&lt;char&gt; s;        stack&lt;char&gt; t;        for(int i = 0; i &lt; S.size(); i++){            if(S[i] == &#39;#&#39;){                if(!s.empty()){                    s.pop();                }            }else                s.push(S[i]);                          }        for(int j = 0; j&lt; T.size(); j++){            if(T[j] == &#39;#&#39;){                if(!t.empty())                    t.pop();            }else                t.push(T[j]);                        }        while(!s.empty() &amp;&amp; !t.empty()){            if(s.top() != t.top())                return false;            s.pop();            t.pop();        }        if(!s.empty() || !t.empty())            return false;//一个栈内元素比另一个的多        return true;    }</code></pre><h4 id="solution2-双指针"><a href="#solution2-双指针" class="headerlink" title="solution2-双指针"></a>solution2-双指针</h4><ul><li>从后向前遍历，用count记录出现过的‘#’</li><li>如果count &gt; 0 &amp;&amp; 当前是一个非‘#’，说明可以对这个进行删除，count–；</li><li>如果当前是 ‘#’，则count++</li><li>否则比较两个元素，如果不相等，则false</li><li>测试用例需要考虑‘#’对的位置，最开头，中间，结尾，两个字符串长度不一样。能想出这种做法，并且把边界条件控制的很好的人，也是绝了。</li><li>时间：O(n)，空间：O(1)</li></ul><pre><code class="C++">/*class Solution {public:    bool backspaceCompare(string S, string T) {        stack&lt;char&gt; s;        stack&lt;char&gt; t;        int lens = S.size();        int lent = T.size();        for(int i = 0; i &lt; lens; i++){            if(S[i] == &#39;#&#39;){                if(!s.empty()){                    s.pop();                }            }else                s.push(S[i]);                          }        for(int j = 0; j&lt; lent; j++){            if(T[j] == &#39;#&#39;){                if(!t.empty())                    t.pop();            }else                t.push(T[j]);                        }        while(!s.empty() &amp;&amp; !t.empty()){            if(s.top() != t.top())                return false;            s.pop();            t.pop();        }        if(!s.empty() || !t.empty())            return false;//一个栈内元素比另一个的多        return true;    }};*/class Solution {public:    bool backspaceCompare(string S, string T) {        int i = S.size()-1;        int j = T.size()-1;        int countS = 0,countT = 0;        //存在两个字符串不一样长的情况        while(i &gt;= 0 || j &gt;= 0){            while(i &gt;= 0 &amp;&amp; (S[i] == &#39;#&#39; || countS &gt; 0)){                if(S[i] == &#39;#&#39;){                    countS++;                }else{                    countS--;                }                i--;            }            while(j &gt;=0 &amp;&amp; (T[j] == &#39;#&#39; || countT &gt; 0)){                if(T[j] == &#39;#&#39;){                    countT++;                }else{                    countT--;                }                j--;            }            if(i &lt; 0 || j &lt; 0)                return i == j;            if(S[i] != T[j])                return false;            else{                 i--;                 j--;            }                   }               return i == j;    }};</code></pre><h3 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232.Implement Queue using Stacks"></a>232.Implement Queue using Stacks</h3><pre><code class="C++">class MyQueue {public:    stack&lt;int&gt;s1;    stack&lt;int&gt;s2;    /** Initialize your data structure here. */    MyQueue() {}    /** Push element x to the back of queue. */    void push(int x) {        s1.push(x);    }    /** Removes the element from in front of queue and returns that element. */    int pop() {        while(!s1.empty()){            s2.push(s1.top());            s1.pop();         }        int res = s2.top();        s2.pop();        while(!s2.empty()){            s1.push(s2.top());            s2.pop();        }          return res;       }    /** Get the front element. */    int peek() {        while(!s1.empty()){            s2.push(s1.top());            s1.pop();         }        int res = s2.top();        while(!s2.empty()){            s1.push(s2.top());            s2.pop();        }          return res;       }    /** Returns whether the queue is empty. */    bool empty() {        if(s1.empty())            return true;        else            return false;    }};/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */</code></pre><h3 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225.Implement Stack using Queues"></a>225.Implement Stack using Queues</h3><pre><code class="C++">class MyStack {public:    queue&lt;int&gt;q;    /** Initialize your data structure here. */    MyStack() {}    /** Push element x onto stack. */    void push(int x) {        q.push(x);    }    /** Removes the element on top of the stack and returns that element. */    int pop() {        int res = q.back();        int len = q.size();        queue&lt;int&gt;tmp;        while(len &gt; 1){            tmp.push(q.front());            q.pop();            len--;        }        q.pop();        while(!tmp.empty()){            q.push(tmp.front());            tmp.pop();        }        return res;    }    /** Get the top element. */    int top() {        return q.back();    }    /** Returns whether the stack is empty. */    bool empty() {        return q.empty();    }};/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */</code></pre><h3 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155.Min Stack"></a>155.Min Stack</h3><pre><code class="c++">/*solution- 用一个全局变量来保存最小值，这样可以在常数时间内返回最小值- 在push(),pop()时，更新minElenm*/class MinStack {public:    int minElem = 0x7fffffff;    stack&lt;int&gt; s;    /** initialize your data structure here. */    MinStack() {    }    void push(int x) {        s.push(x);        if(x &lt; minElem)            minElem = x;    }    void pop() {        int x = s.top();        s.pop();        if(x == minElem){            minElem = 0x7fffffff;            stack&lt;int&gt; tmp;            while(!s.empty()){                int t = s.top();                s.pop();                tmp.push(t);                if(t &lt; minElem){                    minElem = t;                }            }            while(!tmp.empty()){                s.push(tmp.top());                tmp.pop();            }                    }            }    int top() {        return s.top();    }    int getMin() {        return minElem;    }};/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */</code></pre><h3 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20.Valid Parentheses"></a>20.Valid Parentheses</h3><p><strong>题目描述</strong></p><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><p><strong>Example 1:</strong></p><pre><code>Input: &quot;([)]&quot;Output: false</code></pre><h4 id="错！solution1-cnt统计左括号个数"><a href="#错！solution1-cnt统计左括号个数" class="headerlink" title="错！solution1-cnt统计左括号个数"></a>错！solution1-cnt统计左括号个数</h4><ul><li>用cnt计数，分别表示三种括号的左括号个数，当有右括号时，cnt–，左括号时，cnt++。但是”({)”这种，无法正确判断。——只能用于只有一种括号的情况</li><li>时间：O(n)，空间：O(1)</li></ul><h4 id="solution2-辅助栈"><a href="#solution2-辅助栈" class="headerlink" title="solution2-辅助栈"></a>solution2-辅助栈</h4><ul><li>如果是左括号，进栈，如果是右括号，匹配栈顶是否为对应的左括号</li><li>时间：O(n)，空间：O(n)-辅助栈</li></ul><pre><code class="c++">class Solution {public:    bool isValid(string s) {        stack&lt;char&gt;ch;        for(int i = 0; i &lt; s.size(); i++){            if(s[i] == &#39;(&#39; || s[i] == &#39;{&#39; || s[i] == &#39;[&#39;)                ch.push(s[i]);            else{                if(ch.empty()) return false;//这个很重要，要弹出，首先就要判断栈是否为空                if(s[i] == &#39;)&#39; &amp;&amp; ch.top() != &#39;(&#39;)                    return false;                if(s[i] == &#39;}&#39; &amp;&amp; ch.top() != &#39;{&#39;)                    return false;                if(s[i] == &#39;]&#39; &amp;&amp; ch.top() != &#39;[&#39;)                    return false;                ch.pop();            }               }        return ch.empty();             }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
